<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[闷骚的悟空]]></title>
  <subtitle><![CDATA[立一业谋生 择一城终老 携一人白首]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://hi.zongquan.wang/"/>
  <updated>2016-03-30T04:40:57.000Z</updated>
  <id>http://hi.zongquan.wang/</id>
  
  <author>
    <name><![CDATA[闷骚的悟空]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[How to install iOSOpenDev manually]]></title>
    <link href="http://hi.zongquan.wang/2016/03/29/How_to_install_iOSOpenDev_manually/"/>
    <id>http://hi.zongquan.wang/2016/03/29/How_to_install_iOSOpenDev_manually/</id>
    <published>2016-03-29T15:30:35.000Z</published>
    <updated>2016-03-30T04:40:57.000Z</updated>
    <content type="html"><![CDATA[<p>OS X 10.10+ &amp; Xcode 7+</p>
<p><a href="https://github.com/wzqcongcong/iOSOpenDev" target="_blank" rel="external">https://github.com/wzqcongcong/iOSOpenDev</a></p>
<hr>
<ol>
<li><p><strong>Dependency</strong></p>
<p><code>brew install ldid dpkg</code></p>
</li>
<li><p><strong>Theos</strong></p>
<p><a href="https://github.com/theos/theos/wiki" target="_blank" rel="external">Wiki</a></p>
<p><a href="http://iphonedevwiki.net/index.php/Theos/Setup" target="_blank" rel="external">Setup</a></p>
</li>
<li><p><strong>iOSOpenDev</strong></p>
<p><a href="https://github.com/kokoabim/iOSOpenDev/wiki" target="_blank" rel="external">Wiki</a></p>
<p>3.1. update <strong>.zshrc</strong></p>
<p><code>export iOSOpenDevPath=$HOME/Tools/iOS/iOSOpenDev</code></p>
<p><code>export iOSOpenDevDevice=</code></p>
<p><code>export PATH=$iOSOpenDevPath:$PATH</code></p>
<p>3.2. get <strong>iOSOpenDev</strong></p>
<ul>
<li><p><code>git clone --recursive https://github.com/kokoabim/iOSOpenDev.git $iOSOpenDevPath</code></p>
</li>
<li><p>copy the <a href="https://github.com/wzqcongcong/iOSOpenDev" target="_blank" rel="external"><strong>templates</strong></a> dir into <em>$iOSOpenDevPath</em></p>
</li>
</ul>
<p>3.3. setup <strong>Xcode</strong></p>
<ul>
<li><p>copy the <a href="https://github.com/wzqcongcong/iOSOpenDev" target="_blank" rel="external"><strong>.xcspec</strong></a> files into <em>/Applications/Xcode/Content/Developer/Platforms/[PLATFORM_PATH]/Developer/Library/Xcode/Specifications</em> (mkdir if not existed)</p>
</li>
<li><p><code>mkdir -p /Applications/Xcode/Content/Developer/Platforms/[PLATFORM_PATH]/Developer/usr/bin</code></p>
</li>
<li><p><code>ln -fhs $iOSOpenDevPath/bin/iosod /Applications/Xcode/Content/Developer/Platforms/[PLATFORM_PATH]/Developer/usr/bin</code></p>
</li>
<li><p><code>ln -fhs $iOSOpenDevPath/bin/ldid /Applications/Xcode/Content/Developer/Platforms/[PLATFORM_PATH]/Developer/usr/bin</code></p>
</li>
</ul>
<p>3.4. setup <strong>SDK</strong></p>
<ul>
<li><p>add the following key/value into <strong>[SDK_PATH]/SDKSettings.plist</strong>:</p>
<pre><code>DefaultProperties<span class="class">.CODE_SIGNING_REQUIRED</span> =&gt; NO
DefaultProperties<span class="class">.ENTITLEMENTS_REQUIRED</span> =&gt; NO
DefaultProperties<span class="class">.AD_HOC_CODE_SIGNING_ALLOWED</span> =&gt; YES
</code></pre></li>
</ul>
<p>3.5. setup <strong>templates</strong></p>
<ul>
<li><code>ln -fhs $iOSOpenDevPath/templates ~/Library/Developer/Xcode/Templates/iOSOpenDev</code></li>
<li>open <strong>TemplateInfo.plist</strong> of <strong>Base.xctemplate</strong> and <strong>Empty Project.xctemplate</strong> with Xcode, then set the value of user defined key <em>[iOSOpenDevPath]</em> to <em>$HOME/Tools/iOS/iOSOpenDev</em>.</li>
</ul>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>OS X 10.10+ &amp; Xcode 7+</p>
<p><a href="https://github.com/wzqcongcong/iOSOpenDev" target="_blank" rel="external">https://github.com/w]]>
    </summary>
    
      <category term="iOS" scheme="http://hi.zongquan.wang/tags/iOS/"/>
    
      <category term="开发" scheme="http://hi.zongquan.wang/categories/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Fuck My 29 Years' Life]]></title>
    <link href="http://hi.zongquan.wang/2016/03/13/Fuck_My_29_Years_Life/"/>
    <id>http://hi.zongquan.wang/2016/03/13/Fuck_My_29_Years_Life/</id>
    <published>2016-03-13T10:48:18.000Z</published>
    <updated>2016-03-18T14:06:48.000Z</updated>
    <content type="html"><![CDATA[<p>无意间看到了这么一篇文章 <a href="http://www.ifanr.com/632328" target="_blank" rel="external">《人工智能除了下围棋还能干啥？这篇科普文将震撼你的世界观》</a>（后面以常量“彼文”代之），点开之后，手指本能而又温柔地划了几下触摸板，用膀胱扫了一眼滚动条，尼玛好短的滚动条，这也意味着，尼玛好长的文章😂。看惯了不到140个字的微博的我，本能地想要直接关闭彼文，然后愉快地去刷会V2EX或者开发者头条，但是理智再一次告诉我，骚年，不要老吃快餐了，否则营养跟不上啊，好歹碰到这么一篇长文，何不咬着牙并快乐地看完呢，更何况这可是关于当下热门的人狗大战哟🤔。</p>
<p>于是，在洗澡之前，我坚持看完了彼文。</p>
<p>于是，在洗澡之后，我写下了此文。</p>
<p>那么问题来了，洗澡中间发生了什么😂？</p>
<a id="more"></a>
<p>除了捡肥皂，剩下的当然就是思考人生啦。啊哈哈。</p>
<p><em>此文跟人狗大战、人工智能等等这些高大上的概念没有半毛钱的关系，是的，彼文只是一个药引子，感谢彼文，让我有机会好好地回头看了看我走过的路。</em></p>
<p>说白了，这就是一篇无聊的回忆录而已，甚至连回忆录都不配，能骗多少流量就骗多少。</p>
<p>首先套用彼文的结构，上个图：</p>
<p><img src="/img/Fuck_My_29_Years_Life/fuck.png" alt="fuck"></p>
<p>这么一看，原来我是从大学毕业开始步入了编程（不喜欢所谓的程序猿这个自嘲的叫法）这条不归路，已经有6年了（有种刚刚6年制小学毕业的感觉😂）。那么从小学到大学毕业，我尼玛一直在干蛋呢？虽然我是个健忘的人，虽然我的过去有些模糊了，但我还是绞尽浆糊般的脑汁地回忆着，忆着，着。</p>
<p>一开始上小学（幼儿园就算了，记忆约等于0），那个时候就被灌输了“学好数理化，走遍天下都不怕”的极端思想，立志当个强到没朋友的学霸。除了学习，就是看圣斗士星矢，看新白娘子传奇，看西游记，以及吃小浣熊干脆面。小学时跟数学老师关系特好，曾经抱着数学竞赛习题集到老师家边吃喝边看书。那个时候，感觉做老师的都好纯洁，当然，做学生的比做老师的还要纯洁。按照彼文的话讲，<em>2000 年左右出生的人，回到一个没有个人电脑、互联网、手机的 1985 年，会比从 1985 年回到 1955 年的主角看到更大的区别。</em>小学的时候，最自豪的就是家里有大彩电，身上穿小马甲，手上集齐全套三国卡，脚下能骑大人自行车。等等，手机是什么，能吃吗？</p>
<p>后来上了初中，日常就是跟小伙伴在回家的路上飚自行车。哦对，那个时候学校就开始开设计算机课了，教课的是个小年轻（现在想想，那个小年轻真是太low了😑，啊哈哈）。当我第一次按下电源键，打开电脑，稀里糊涂地在小年轻的指导下打开了画图程序，然后迷茫地按住鼠标乱画一通的时候，我一下子发现，啊，我画的画好好看啊😝。是的，我并没有惊叹计算机有多么的牛逼，而是继续自恋地画着画。从这一点来看，也许我注定不是一个好的程序员😂，因为缺少了那种最原始最崇高的热爱。相反，我把我最原始最崇高的热爱献给了艺术。说到这里，我不得不提一下，一个人的性格以及将来想要做什么，确实跟星座有关，其实也就是跟出生的月份有关。4月份出生的名人里，大多是艺术家，而不是编程的😳。哦，差点忘了一段，上小学时很喜欢用橡皮泥捏各种造型，以及用橡皮泥条拼各种画，当时我爸居然鄙视我搞这些东西，所以我现在一直鄙视我爸，要不是他，也许我现在已经从事艺术了。上了初中后，当然不会再去捏橡皮泥了，而是喜欢上了素描，现在我家墙上还贴着我当年的画作呢。の，初中的事似乎回忆地有点多了，但这不是巧合，对一个人的性格起塑造作用的时间段，正是初中。</p>
<p>后来又上了高中，“学好数理化，走遍天下都不怕”这个思想植入地越发深入，学霸的理想也越发强烈。我开始变得鄙视那些就知道谈恋爱搞暧昧的同学，哼哼，要知道，我在初中就看好过一个妹纸了，虽然然后就没有然后了。你们这些个感情用事的学渣，注定没好结果，啊哈哈。依稀还记得，高三时还有个漂亮妹子想主动和我坐一桌，当时我居然跟老师说，她平时老爱玩，会影响我学习的🤓。哎，估计人家现在孩子都可以打酱油了。不好意思，跑题了。那个时候，每个教室都有一台电脑，老师上课偶尔会用来放放PPT，不过更重要的是，中午休息或者下午放学后，我们可以插上软盘，玩会幽游白书😜。其实那个时候就已经有什么计算机竞赛了，但对于我这种只知道数理化竞赛的人来说，计算机竞赛好像没啥含金量。哎，高中对学霸来讲是最乏味的阶段了，感觉过得跟水一样平静，跟纸一样纯洁。</p>
<p>后来又上了大学，是的，作为学霸的我，理所应当地选择了数学专业，毕竟高考数学满分嘛，不学数学对不起阅卷老师啊。然而学了之后才发现，大学里的数学好像很无聊的样纸，不是自己喜欢的东西。于是开始了本应该高中就可以做的事：翘课。翘课之后干啥捏，纯洁的我没有选择把妹，而是选择了玩游戏😂。后来，忘记了是大二还是大三，学校搞过一个讲座，是请了外面一个搞技术的人来忽悠我们，当时看到他在讲台上用命令行各种秀微操，甚是牛逼啊。妈，我要嫁给这种牛逼的人！不是，我是说我也要成为这种牛逼的人😎。正好学校也开设了C语言程序设计，你们懂的，从此一入码门深似海。其实上课期间也没学到些啥，也就是平时看看书自学点，毕竟比不上科班出身的那些计算机专业的同学。我也不知道为什么，最后大学毕业的我，居然选择研究生去学计算机。不过还好，之前学的数学对学计算机来说还算有益无害。可是艺术啊，与我命运相连的艺术就这么被抛弃了😔。上了研究生，由于是跨专业，所以大学阶段落下的计算机知识只能靠平时自己看看书来恶补了。可笑的是，即便在研究生阶段，真正有所实践的时候，也是研三帮老师搞项目赚外快的时候。那个时候真真切切地写着代码，感受着这迟来的爱，毕竟有钱赚嘛。</p>
<p>毕业之后，我就一路走到黑地选择了编程作为工作。说真的，假如上帝给我一千万，我也许就不会以编程为生了，而是会去搞艺术，什么绘画音乐之类的，那时候编程也许会变成平时的一个兴趣爱好，可以骄傲地告诉儿子/女儿，你爹我是懂艺术的里面最会编程的😏。等下，我连妹子都没有，还是不要意淫这种太污的场景了。然而现实是相反的，每天写着代码，靠编程来养家糊口，说错了，是养自己糊口。然后等到老的时候，再重新拾起绘画这个儿时的爱好，画画小插画啥的。不过到底我还是蛮喜欢编程的，我只想一边写着代码，一边安静地做个美男子，那种感觉就像是小时候用纸盒子做机器人一样，只不过现在的玩具不是纸盒子，而是代码。</p>
<p>我深信我还是热爱编程的，我也热爱艺术。高晓松说的好，人生不止苟且，还有编程与艺术。不好意思大紧，我抄袭你了😆。</p>
<p>回忆录就先到此为止吧。</p>
<p>To Be Continue</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>无意间看到了这么一篇文章 <a href="http://www.ifanr.com/632328">《人工智能除了下围棋还能干啥？这篇科普文将震撼你的世界观》</a>（后面以常量“彼文”代之），点开之后，手指本能而又温柔地划了几下触摸板，用膀胱扫了一眼滚动条，尼玛好短的滚动条，这也意味着，尼玛好长的文章😂。看惯了不到140个字的微博的我，本能地想要直接关闭彼文，然后愉快地去刷会V2EX或者开发者头条，但是理智再一次告诉我，骚年，不要老吃快餐了，否则营养跟不上啊，好歹碰到这么一篇长文，何不咬着牙并快乐地看完呢，更何况这可是关于当下热门的人狗大战哟🤔。</p>
<p>于是，在洗澡之前，我坚持看完了彼文。</p>
<p>于是，在洗澡之后，我写下了此文。</p>
<p>那么问题来了，洗澡中间发生了什么😂？</p>]]>
    
    </summary>
    
      <category term="Thinking" scheme="http://hi.zongquan.wang/tags/Thinking/"/>
    
      <category term="生活" scheme="http://hi.zongquan.wang/categories/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hack XtraFinder]]></title>
    <link href="http://hi.zongquan.wang/2016/01/12/Hack_XtraFinder/"/>
    <id>http://hi.zongquan.wang/2016/01/12/Hack_XtraFinder/</id>
    <published>2016-01-12T15:38:55.000Z</published>
    <updated>2016-01-13T04:58:29.000Z</updated>
    <content type="html"><![CDATA[<p>事情是这样的，我的系统是 OS X 10.11，就是那个有 SIP 的 10.11 😂。然后我装了一个 Finder 的插件：XtraFinder，这个插件有些功能在 10.11 下是不 work 的，所以插件作者出于好心，在检测到你的系统是 10.11 且 SIP 没有关闭的情况下，会弹出一个 alert 窗口作为提醒。</p>
<p><img src="/img/Hack_XtraFinder/alert.png" alt="Alert"></p>
<p>那么问题来了，作者检测 SIP 是否关闭的方法有个 bug，导致我明明是完全关闭了 SIP，但插件却认为 SIP 还在启用。第二个问题，这个 alert 每次重启插件（包括每次重启系统）时都会弹出来啊，出来啊，来啊，啊，搞得你每次都要去点一下确认才能将其关闭，烦的很 😒。我曾经给作者发邮件，希望他能 update 一下，只弹一次 alert 就好。当然了，作者没有鸟我。</p>
<p>作为偶尔会用 Hopper Disassembler 偷窥一下别人代码的我，就开始意淫能不能 hack 一下这个插件，改掉这个恶心的行为。</p>
<a id="more"></a>
<h3 id="工具">工具</h3><ul>
<li>Hopper Disassembler</li>
<li>Hex Fiend</li>
<li>Developer ID Application 证书</li>
</ul>
<h3 id="步骤">步骤</h3><ol>
<li><p>用 Hopper Disassembler 定位 hack point</p>
<p> 这个 alert 是插件一启动的时候就弹出的，所以很容易想到先去 check 一下 <code>[AppDelegate applicationDidFinishLaunching:]</code> 这个方法。Load Mach-O 文件后，直奔那个函数的伪代码：</p>
<p> <img src="/img/Hack_XtraFinder/hopper1.png" alt="Hopper Disassembler"></p>
<p> 从图中可以看到，插件作者通过 <code>csrutil status</code> 的返回结果来判断 SIP 的状态，只有返回结果中匹配到了字符串 <code>&quot;Debugging Restrictions: disabled&quot;</code> 才认为 SIP 关闭。但是，我是完全关闭 SIP 的，运行 <code>csrutil status</code> 的结果是 <code>System Integrity Protection status: disabled.</code>，显然无法匹配那个字符串，所以就被误认为是 SIP 尚未关闭。</p>
<p> 注意，上图中蓝色框中的内容是我修改之后的，原内容是 <code>if (rax != rcx) goto loc_100001df7;</code>，也就是当 <code>[rax rangeOfString:rdx] != NSNotFound</code> 的时候，字符串匹配成功，就跳过不弹 alert。看到这里你已经知道了，只要把条件反转就大功告成了。</p>
<p> 当然，除了反转判断条件之外，还可以修改那个用于匹配的字符串，比如修改成 <code>&quot;disabled&quot;</code> 就好了，都能够匹配成功。</p>
<p> 好了，伪代码是看明白了，下面就得看如何让这个判断条件反转了。</p>
<p> <img src="/img/Hack_XtraFinder/hopper2.png" alt="Hopper Disassembler"></p>
<p> 上图中红色框中的汇编代码对应前面分析的那块伪代码，而蓝色框中的十六进制 <code>0F 84 E1 01 00 00</code> 代表伪代码块中的最后那条命令 <code>0x0000000100001c10         je         0x100001df7</code>。<code>je</code> 这个指令表示 <em><code>如果等于则跳转到</code></em>，它的反指令是 <code>jne</code>，所以我们要做的就是把最后这条命令改为 <code>jne         0x100001df7</code>。参考一下<a href="http://neuzxy.blog.51cto.com/10270223/1716326" target="_blank" rel="external">这篇文章</a>，其实就是把 <code>0F 84 E1 01 00 00</code> 改为 <code>0F 85 E1 01 00 00</code>，把 4 改成 5。</p>
</li>
<li><p>用 Hex Fiend 修改 Mach-O 文件</p>
<p> 明白了改什么，下面就是开始操作了。用 Hex Fiend 打开 Mach-O 文件，直接查找替换即可。</p>
<p> <img src="/img/Hack_XtraFinder/hex1.png" alt="Hex Fiend"></p>
<p> 只有一点需要注意：如果直接查找 <code>0F 84 E1 01 00 00</code> 的话，可能有多处，所以为了准确定位，我们可以连同下一条命令一起来查找，如上图，我们查找 <code>0F 84 E1 01 00 00 48 8B 3D 6B 14 01 00</code>，这样就会只找到唯一的一处。</p>
<p> 替换完成后保存即可。</p>
</li>
<li><p>重新签名</p>
<p> 修改后的 Mach-O 文件是无法运行的，因为签名不对了。所以需要我们用自己的开发者证书重签一下：<code>codesign -f -s &quot;XXX 证书的 Common Name&quot; /Applications/XtraFinder.app/Contents/MacOS/XtraFinder</code>。</p>
<p> 大功告成，覆盖重启插件后，再也没有弹出 alert，XtraFinder 照常 work 😆。</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>事情是这样的，我的系统是 OS X 10.11，就是那个有 SIP 的 10.11 😂。然后我装了一个 Finder 的插件：XtraFinder，这个插件有些功能在 10.11 下是不 work 的，所以插件作者出于好心，在检测到你的系统是 10.11 且 SIP 没有关闭的情况下，会弹出一个 alert 窗口作为提醒。</p>
<p><img src="/img/Hack_XtraFinder/alert.png" alt="Alert"></p>
<p>那么问题来了，作者检测 SIP 是否关闭的方法有个 bug，导致我明明是完全关闭了 SIP，但插件却认为 SIP 还在启用。第二个问题，这个 alert 每次重启插件（包括每次重启系统）时都会弹出来啊，出来啊，来啊，啊，搞得你每次都要去点一下确认才能将其关闭，烦的很 😒。我曾经给作者发邮件，希望他能 update 一下，只弹一次 alert 就好。当然了，作者没有鸟我。</p>
<p>作为偶尔会用 Hopper Disassembler 偷窥一下别人代码的我，就开始意淫能不能 hack 一下这个插件，改掉这个恶心的行为。</p>]]>
    
    </summary>
    
      <category term="Mac" scheme="http://hi.zongquan.wang/tags/Mac/"/>
    
      <category term="开发" scheme="http://hi.zongquan.wang/categories/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Xcode Build Settings - Products Path]]></title>
    <link href="http://hi.zongquan.wang/2015/11/16/Xcode_Build_Settings_Products_Path/"/>
    <id>http://hi.zongquan.wang/2015/11/16/Xcode_Build_Settings_Products_Path/</id>
    <published>2015-11-16T12:21:54.000Z</published>
    <updated>2016-01-11T01:35:22.000Z</updated>
    <content type="html"><![CDATA[<p>假设一个 Project 的路径是 <code>XXX/ProjectX</code>。</p>
<p>当 build 完成后，我们会关注 2 个与 <strong>Product Files</strong> 有关的 settings ：</p>
<p><strong><code>$BUILT_PRODUCTS_DIR</code></strong> 和 <strong><code>$TARGET_BUILD_DIR</code></strong></p>
<p>这 2 个 settings 决定了我们 build 出来的 Products 被放置到了哪里。</p>
<h4 id="官方解释">官方解释</h4><ul>
<li><p><strong><code>$BUILT_PRODUCTS_DIR</code></strong>：Directory path. Identifies the directory under which all the product’s files can be found. This directory contains either product files or symbolic links to them.</p>
</li>
<li><p><strong><code>$TARGET_BUILD_DIR</code></strong>：Directory path. Identifies the root of the directory hierarchy that contains the product’s files (no intermediate build files).</p>
</li>
</ul>
<p>乍一看好像都是用来存放 <strong>Product Files</strong> 的目录，但是它们的作用是不一样的：</p>
<p>刚编译完的时候，Xcode 会先把 <strong>Product Files</strong> 生成到 <strong><code>$BUILT_PRODUCTS_DIR</code></strong> 中，然后再根据具体的 configuration 来决定要不要对生成的 <strong>Product Files</strong> 进行 deploy，如果不需要 deploy，那么 <strong>Product Files</strong> 最后还是留在 <strong><code>$BUILT_PRODUCTS_DIR</code></strong> 中，如果需要 deploy，那么 <strong>Product Files</strong> 会被 move 到 <strong><code>$TARGET_BUILD_DIR</code></strong> 中，而原来的 <strong><code>$BUILT_PRODUCTS_DIR</code></strong> 中就只有 symbolic links 了。</p>
<h4 id="举个例子">举个例子</h4><p>普通的 app 在 build 完之后，一般放置在 <code>$BUILT_PRODUCTS_DIR</code> 中即可，而对于 Xcode Plugin 来说，在 build 完之后一般会直接将其 deploy 到 Xcode 的 <strong>Plug-ins</strong> 目录中，此时 <code>$TARGET_BUILD_DIR</code> 就是 <strong>Plug-ins</strong> 目录，而 <code>$BUILT_PRODUCTS_DIR</code> 中只有 Plugin 的 symbolic links。</p>
<p><em>可以 clone 一下我之前写的一个<a href="https://github.com/wzqcongcong/AtAutoCompletion" target="_blank" rel="external">小插件</a>，build 一下看结果。</em></p>
<hr>
<h4 id="下面就看一下这_2_个路径是如何设置的">下面就看一下这 2 个路径是如何设置的</h4><a id="more"></a>
<p><strong>首先解释一些相关的 settings：</strong></p>
<p><strong>settingName (settingDisplayNameInXcodeBuildSettings)</strong></p>
<ul>
<li><p><strong><code>$SRCROOT</code></strong>：<code>XXX/ProjectX</code></p>
</li>
<li><p><strong><code>$SYMROOT (Build Products Path)</code></strong>：Directory path. Identifies the root of the directory hierarchy that contains product files and intermediate build files. Product and build files are placed in subdirectories of this directory. 看完官方解释，我再说一下它具体如何设置。</p>
<ol>
<li><p>默认值是 <code>$SRCROOT/build</code></p>
</li>
<li><p>可以在 Xcode 的 Preferences 里面设置 <code>Build Location</code>，如下图<br><img src="/img/Xcode_Build_Settings_Products_Path/location.png" alt="Build Location"></p>
</li>
<li><p>直接在 Target 的 <code>Build Settings</code> 里面设置 <code>Build Products Path</code>，如下图<br><img src="/img/Xcode_Build_Settings_Products_Path/build_products_path.png" alt="Build Products Path"></p>
</li>
</ol>
<p>这 3 种设置的优先级依次递增，也就是说，如果你同时设置了 2 和 3，那么最后 build 是按照 3 的值来处理的。</p>
</li>
<li><p><strong><code>$CONFIGURATION</code></strong>：Debug、Release、自定义的等等。</p>
</li>
<li><p><strong><code>$CONFIGURATION_BUILD_DIR (Per-Configuration Build Products Path)</code></strong>：= <code>$SYMROOT/$CONFIGURATION</code>，例如 <code>XXX/ProjectX/build/Debug</code>。</p>
</li>
<li><p><strong><code>$DEPLOYMENT_LOCATION (Deployment Location)</code></strong>：Boolean value. Specifies whether product files are placed in the installation or the build directory. 它决定了要不要对 <strong>Product Files</strong> 进行 deploy。</p>
</li>
<li><p><strong><code>$SKIP_INSTALL (Skip Install)</code></strong>：Boolean value. Specifies whether to place the product at the location indicated by <em><code>$DSTROOT</code></em> or the uninstalled products directory inside the directory indicated by <em><code>$TARGET_TEMP_DIR</code></em>. 它决定了具体要把 <strong>Product Files</strong> deploy 到哪里。</p>
</li>
</ul>
<p><strong>下面就轮到 2 个主角了。</strong></p>
<ul>
<li><p><strong><code>$BUILT_PRODUCTS_DIR</code></strong>：= <code>$CONFIGURATION_BUILD_DIR</code> = <code>$SYMROOT/$CONFIGURATION</code> <em>（其实除了这个值，还有一种取值，不过基本不用，所以这里为了便于理解把它忽略了。详情可查阅<a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Reference/XcodeBuildSettingRef/0-Introduction/introduction.html" target="_blank" rel="external">官方文档</a>）</em></p>
</li>
<li><p><strong><code>$TARGET_BUILD_DIR</code></strong>：</p>
<ol>
<li><p>如果 <code>$DEPLOYMENT_LOCATION</code> = <code>NO</code>，即不需要 deploy，那么 <code>$TARGET_BUILD_DIR</code> 就直接等同于 <code>$BUILT_PRODUCTS_DIR</code>。</p>
</li>
<li><p>如果 <code>$DEPLOYMENT_LOCATION</code> = <code>YES</code>，即需要 deploy，那么：</p>
</li>
</ol>
<p>2.1. 如果 <code>$SKIP_INSTALL</code> = <code>NO</code>，那么 <code>$TARGET_BUILD_DIR</code> = <code>$INSTALL_DIR</code> = <code>$DSTROOT/$INSTALL_PATH</code>。其中，<code>$DSTROOT</code> 的 display name 是 <code>Installation Build Products Location</code>，<code>$INSTALL_PATH</code> 的 display name 是 <code>Installation Directory</code>。另外需要注意，为了拼接出一个有效的 <code>$INSTALL_DIR</code>，<code>$INSTALL_PATH</code> 必须以 <code>/</code> 开头。</p>
<p>2.2. 如果 <code>$SKIP_INSTALL</code> = <code>YES</code>，那么 <code>$TARGET_BUILD_DIR</code> = <code>$TARGET_TEMP_DIR/UninstalledProducts</code>。</p>
<p>一般需要 deploy 的时候，都是设置 <code>$SKIP_INSTALL</code> 为 <code>NO</code>，然后设置具体的 <code>$DSTROOT</code> 和 <code>$INSTALL_PATH</code>，所以这里忽略对 <code>$TARGET_TEMP_DIR</code> 理解。</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>假设一个 Project 的路径是 <code>XXX/ProjectX</code>。</p>
<p>当 build 完成后，我们会关注 2 个与 <strong>Product Files</strong> 有关的 settings ：</p>
<p><strong><code>$BUILT_PRODUCTS_DIR</code></strong> 和 <strong><code>$TARGET_BUILD_DIR</code></strong></p>
<p>这 2 个 settings 决定了我们 build 出来的 Products 被放置到了哪里。</p>
<h4 id="官方解释">官方解释</h4><ul>
<li><p><strong><code>$BUILT_PRODUCTS_DIR</code></strong>：Directory path. Identifies the directory under which all the product’s files can be found. This directory contains either product files or symbolic links to them.</p>
</li>
<li><p><strong><code>$TARGET_BUILD_DIR</code></strong>：Directory path. Identifies the root of the directory hierarchy that contains the product’s files (no intermediate build files).</p>
</li>
</ul>
<p>乍一看好像都是用来存放 <strong>Product Files</strong> 的目录，但是它们的作用是不一样的：</p>
<p>刚编译完的时候，Xcode 会先把 <strong>Product Files</strong> 生成到 <strong><code>$BUILT_PRODUCTS_DIR</code></strong> 中，然后再根据具体的 configuration 来决定要不要对生成的 <strong>Product Files</strong> 进行 deploy，如果不需要 deploy，那么 <strong>Product Files</strong> 最后还是留在 <strong><code>$BUILT_PRODUCTS_DIR</code></strong> 中，如果需要 deploy，那么 <strong>Product Files</strong> 会被 move 到 <strong><code>$TARGET_BUILD_DIR</code></strong> 中，而原来的 <strong><code>$BUILT_PRODUCTS_DIR</code></strong> 中就只有 symbolic links 了。</p>
<h4 id="举个例子">举个例子</h4><p>普通的 app 在 build 完之后，一般放置在 <code>$BUILT_PRODUCTS_DIR</code> 中即可，而对于 Xcode Plugin 来说，在 build 完之后一般会直接将其 deploy 到 Xcode 的 <strong>Plug-ins</strong> 目录中，此时 <code>$TARGET_BUILD_DIR</code> 就是 <strong>Plug-ins</strong> 目录，而 <code>$BUILT_PRODUCTS_DIR</code> 中只有 Plugin 的 symbolic links。</p>
<p><em>可以 clone 一下我之前写的一个<a href="https://github.com/wzqcongcong/AtAutoCompletion">小插件</a>，build 一下看结果。</em></p>
<hr>
<h4 id="下面就看一下这_2_个路径是如何设置的">下面就看一下这 2 个路径是如何设置的</h4>]]>
    
    </summary>
    
      <category term="Xcode" scheme="http://hi.zongquan.wang/tags/Xcode/"/>
    
      <category term="开发" scheme="http://hi.zongquan.wang/categories/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[How to get File Attributes in Mac]]></title>
    <link href="http://hi.zongquan.wang/2015/01/22/How_to_get_File_Attributes_in_Mac/"/>
    <id>http://hi.zongquan.wang/2015/01/22/How_to_get_File_Attributes_in_Mac/</id>
    <published>2015-01-22T07:16:18.000Z</published>
    <updated>2015-11-10T02:03:41.000Z</updated>
    <content type="html"><![CDATA[<h4 id="Mac_File_Attributes">Mac File Attributes</h4><p>在 Mac 开发中，想要获取 file 或者 dir 的属性，有这么4种方式：</p>
<ul>
<li><p><strong>Linux C api</strong></p>
<p>  <code>int lstat(const char *restrict path, struct stat *restrict buf)</code></p>
<p>  获取到的 stat 有如下属性：</p>
<pre><code><span class="keyword">struct</span> stat { <span class="comment">/* when _DARWIN_FEATURE_64_BIT_INODE is defined */</span>
    <span class="keyword">dev_t</span>           st_dev;           <span class="comment">/* ID of device containing file */</span>
    <span class="keyword">mode_t</span>          st_mode;          <span class="comment">/* Mode of file (see below) */</span>
    <span class="keyword">nlink_t</span>         st_nlink;         <span class="comment">/* Number of hard links */</span>
    <span class="keyword">ino_t</span>           st_ino;           <span class="comment">/* File serial number */</span>
    <span class="keyword">uid_t</span>           st_uid;           <span class="comment">/* User ID of the file */</span>
    <span class="keyword">gid_t</span>           st_gid;           <span class="comment">/* Group ID of the file */</span>
    <span class="keyword">dev_t</span>           st_rdev;          <span class="comment">/* Device ID */</span>
    <span class="keyword">struct</span> timespec st_atimespec;     <span class="comment">/* time of last access */</span>
    <span class="keyword">struct</span> timespec st_mtimespec;     <span class="comment">/* time of last data modification */</span>
    <span class="keyword">struct</span> timespec st_ctimespec;     <span class="comment">/* time of last status change */</span>
    <span class="keyword">struct</span> timespec st_birthtimespec; <span class="comment">/* time of file creation(birth) */</span>
    <span class="keyword">off_t</span>           st_size;          <span class="comment">/* file size, in bytes */</span>
    <span class="keyword">blkcnt_t</span>        st_blocks;        <span class="comment">/* blocks allocated for file */</span>
    <span class="keyword">blksize_t</span>       st_blksize;       <span class="comment">/* optimal blocksize for I/O */</span>
    <span class="keyword">uint32_t</span>        st_flags;         <span class="comment">/* user defined flags for file */</span>
    <span class="keyword">uint32_t</span>        st_gen;           <span class="comment">/* file generation number */</span>
};
</code></pre></li>
</ul>
<ul>
<li><p><strong>Metadata</strong></p>
<p>  这种方式是基于 Spotlight 的，优点是在访问大量文件时速度快，缺点是要依赖 Spotlight 功能的开启。当 Spotlight 获取到 item 的 metadata 后，就可以通过下面2种方法来获取这些 metadata：</p>
<ul>
<li><p><code>CFTypeRef MDItemCopyAttribute(MDItemRef item, CFStringRef name)</code>，metadata attribute key 格式为 kMDItemXXX，详见文档。</p>
</li>
<li><p><code>NSMetadataQuery</code>，通过执行 Spotlight 查询来获取 result，metadata attribute key 格式同上。</p>
<p><strong>注意</strong>，这种方式是基于 Spotlight 获取到了这些 metadata，否则拿到的值可能就是 NULL 了。</p>
<p><strong>另外</strong>，在 terminal 中，这种方式也有相应的命令 <code>mdls</code> 可以使用。</p>
</li>
</ul>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p><strong>NSFileManager</strong></p>
<p>  通过调用 NSFileManager 的 <code>attributesOfItemAtPath:error:</code> 也可以拿到 file 的 attribute，attribute key 格式为 <code>NSFileXXX</code>，详见文档。</p>
</li>
</ul>
<ul>
<li><p><strong>NSURL</strong></p>
<p>  通过调用 NSURL 的 <code>getResourceValue:forKey:error:</code> 也可以拿到 file 的 attribute，resource key 格式为 <code>NSURLXXX</code>，详见文档。对比采用 NSFileManager，这种方式以 URL 的形式来访问该 file，拿到的 attribute 比 NSFileManager 也多。<strong>推荐使用。</strong></p>
</li>
</ul>
<h4 id="这里顺便提一下关于_delete_file/dir_的一点注意事项">这里顺便提一下关于 delete file/dir 的一点注意事项</h4><p>首先，NSFileManager 有一个判断 file/dir 能否删除的 api：<code>isDeletableFileAtPath:</code>，其次，还有一个负责删除的 api：<code>removeItemAtPath:error:</code>。</p>
<p>那么问题来了，<code>isDeletableFileAtPath:</code> 和 <code>removeItemAtPath:error:</code> 的行为不太一致！</p>
<p><code>removeItemAtPath:error:</code> 总是能够做出正确的行为，即能删除的话就删除，不能删除的话就不会删除。但是，<code>isDeletableFileAtPath:</code> 有时候不能做出正确的判断。</p>
<ul>
<li><p>对于 file 来说，<code>isDeletableFileAtPath:</code> 总是可以做出正确的判断，这个没问题。</p>
<p>  也就是说，根据 Apple 文档，当 file 的 parent dir 具有可写权限时，file 就是 deletable 的，不管 file 本身的权限如何。否则，就是 undeletable 的。</p>
</li>
<li><p>对于 dir 来说，就会出现刚才说的问题。</p>
<p>  理论上，根据 Apple 文档，除了判断 parent dir 的可写权限之外，<code>isDeletableFileAtPath:</code> 还会递归地去判断 child item，只有所有的 child item 都是 deletable 时，才会返回 YES。</p>
<p>  但是，事实上，<code>isDeletableFileAtPath:</code> 貌似没有去递归地检查 child item。</p>
<p>  举例说明，有这么一个 path：<user_dir>/<root_dir>/<file_no_matter_root_or_user>，path 中的名称标明了对应的权限。现在用 <code>isDeletableFileAtPath:</code> 去检查 <root_dir>。</root_dir></file_no_matter_root_or_user></root_dir></user_dir></p>
<p>  理论上，<root_dir> 中有个 <file_no_matter_root_or_user>，而 <file_no_matter_root_or_user> 是 undeletable 的（因为它的 parent dir <root_dir> 是 root 的，普通用户没有可写权限），所以 <root_dir> 就是 undeletable 的，所以应该返回 NO。但是 <code>isDeletableFileAtPath:</code> 返回的却是 YES。此时如果调用 <code>removeItemAtPath:error:</code> 去删除 <root_dir> 时，就会出现 error，提示没有权限。也就是说，<code>removeItemAtPath:error:</code> 跟实际情况是一致的，但 <code>isDeletableFileAtPath:</code> 却做出了错误的判断。所以对于这种情况，你需要手动地去递归调用 <code>isDeletableFileAtPath:</code> 来检查 <root_dir>。</root_dir></root_dir></root_dir></root_dir></file_no_matter_root_or_user></file_no_matter_root_or_user></root_dir></p>
<p>  感觉好坑啊，难道打开的姿势不对~~</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="Mac_File_Attributes">Mac File Attributes</h4><p>在 Mac 开发中，想要获取 file 或者 dir 的属性，有这么4种方式：</p>
<ul>
<li><p><strong>Linux C api</strong></p>
<p>  <code>int lstat(const char *restrict path, struct stat *restrict buf)</code></p>
<p>  获取到的 stat 有如下属性：</p>
<pre><code><span class="keyword">struct</span> stat { <span class="comment">/* when _DARWIN_FEATURE_64_BIT_INODE is defined */</span>
    <span class="keyword">dev_t</span>           st_dev;           <span class="comment">/* ID of device containing file */</span>
    <span class="keyword">mode_t</span>          st_mode;          <span class="comment">/* Mode of file (see below) */</span>
    <span class="keyword">nlink_t</span>         st_nlink;         <span class="comment">/* Number of hard links */</span>
    <span class="keyword">ino_t</span>           st_ino;           <span class="comment">/* File serial number */</span>
    <span class="keyword">uid_t</span>           st_uid;           <span class="comment">/* User ID of the file */</span>
    <span class="keyword">gid_t</span>           st_gid;           <span class="comment">/* Group ID of the file */</span>
    <span class="keyword">dev_t</span>           st_rdev;          <span class="comment">/* Device ID */</span>
    <span class="keyword">struct</span> timespec st_atimespec;     <span class="comment">/* time of last access */</span>
    <span class="keyword">struct</span> timespec st_mtimespec;     <span class="comment">/* time of last data modification */</span>
    <span class="keyword">struct</span> timespec st_ctimespec;     <span class="comment">/* time of last status change */</span>
    <span class="keyword">struct</span> timespec st_birthtimespec; <span class="comment">/* time of file creation(birth) */</span>
    <span class="keyword">off_t</span>           st_size;          <span class="comment">/* file size, in bytes */</span>
    <span class="keyword">blkcnt_t</span>        st_blocks;        <span class="comment">/* blocks allocated for file */</span>
    <span class="keyword">blksize_t</span>       st_blksize;       <span class="comment">/* optimal blocksize for I/O */</span>
    <span class="keyword">uint32_t</span>        st_flags;         <span class="comment">/* user defined flags for file */</span>
    <span class="keyword">uint32_t</span>        st_gen;           <span class="comment">/* file generation number */</span>
};
</code></pre></li>
</ul>
<ul>
<li><p><strong>Metadata</strong></p>
<p>  这种方式是基于 Spotlight 的，优点是在访问大量文件时速度快，缺点是要依赖 Spotlight 功能的开启。当 Spotlight 获取到 item 的 metadata 后，就可以通过下面2种方法来获取这些 metadata：</p>
<ul>
<li><p><code>CFTypeRef MDItemCopyAttribute(MDItemRef item, CFStringRef name)</code>，metadata attribute key 格式为 kMDItemXXX，详见文档。</p>
</li>
<li><p><code>NSMetadataQuery</code>，通过执行 Spotlight 查询来获取 result，metadata attribute key 格式同上。</p>
<p><strong>注意</strong>，这种方式是基于 Spotlight 获取到了这些 metadata，否则拿到的值可能就是 NULL 了。</p>
<p><strong>另外</strong>，在 terminal 中，这种方式也有相应的命令 <code>mdls</code> 可以使用。</p>
</li>
</ul>
</li>
</ul>]]>
    
    </summary>
    
      <category term="Mac" scheme="http://hi.zongquan.wang/tags/Mac/"/>
    
      <category term="开发" scheme="http://hi.zongquan.wang/categories/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Study iOS - Hardware]]></title>
    <link href="http://hi.zongquan.wang/2015/01/18/Study_iOS_Hardware/"/>
    <id>http://hi.zongquan.wang/2015/01/18/Study_iOS_Hardware/</id>
    <published>2015-01-18T07:42:25.000Z</published>
    <updated>2015-11-10T02:03:41.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：Hardware">Developing Applications for iOS 观后感系列：Hardware</h3><p><em>相关视频章节：14、17</em></p>
<hr>
<p>关于 iOS device 的 hardware，本篇主要了解2个方面：CoreLocation + CoreMotion</p>
<h3 id="CoreLocation">CoreLocation</h3><ul>
<li><p><strong><code>CLLocation</code></strong>：CoreLocation 中最基本的 class。</p>
<p>  CLLocation 的重要 property：</p>
<p>  <em><code>coordinate</code></em>：位置坐标，包含 latitude 和 longitude 两个元素。</p>
<p>  <em><code>altitude</code></em>：海拔。</p>
<p>  <em><code>horizontal/verticalAccuracy</code></em>：精度。Cellular &lt; WiFi &lt; GPS。</p>
</li>
<li><p><strong><code>CLLocationManager</code></strong>：用于获取 CLLocation。</p>
<p>  使用流程：</p>
<ol>
<li><p><em><code>check device</code></em></p>
<p> 主要是检查 device 是否支持以某种方式来获取某种 location，以及是否有权限来获取。</p>
<p> 关于权限，有3中状态：Authorized、Denied、Restricted。</p>
</li>
<li><p><em><code>init &amp; delegate</code></em>：通过 CLLocationManager 来获取 CLLocation 可以有2种方式，一种是主动 ask（poll），一种是 delegate。通常采用 delegate 的方式，delegate 触发后，你就可以访问 CLLocationManager 的 property <em><code>location</code></em> 来获取当前的 CLLocation 了。</p>
</li>
<li><p><em><code>configuration</code></em></p>
<p> 通过 property <em><code>desiredAccuracy</code></em> 来设定想要的精度。</p>
<p> 通过 property <em><code>distanceFilter</code></em> 告诉 CLLocationManager，只有当 location 的变化超过该范围时，才去触发 update delegate。</p>
</li>
<li><p><em><code>start monitor</code></em></p>
<p> 你可以进行如下几种形式的 monitor，每种 monitor 都有相应的 delegate 函数，参见文档。</p>
<ul>
<li><p><em><code>normal monitor</code></em>：standard monitor，通过设定精度，每当 update 触发时，就会通知 app。</p>
</li>
<li><p><em><code>significant change monitor</code></em>：仅当 location 发生明显变化时才通知 app，这里的 significant 并未定义具体是多少。</p>
</li>
<li><p><em><code>region monitor</code></em>：当 device 进入某个指定的 region 时，通知 app。</p>
</li>
<li><p><em><code>beacon monitor</code></em>：当 device 进入某个指定的 beacon 时，通知 app，这种 monitor 通常与 <em><code>Core Bluetooth</code></em> 相关。</p>
</li>
</ul>
<p><strong>注意</strong>，当你不再需要 monitor 时，不要忘了 stop monitor。</p>
<p><strong>注意</strong>，即使 app not running，这些 monitor 也还是能够 work 的。想要在 background 模式下继续 monitor，需要在 project 中设置一下，类似于 background fetch 的设置。当 delegate 触发后，app 就会被启动。这种情况下，<code>application:didFinishLaunchingWithOption:</code> 的 option dictionary 中就会包含一个 key <code>UIApplicationLaunchOptionsLocationKey</code>。</p>
</li>
</ol>
</li>
</ul>
<a id="more"></a>
<h3 id="CoreMotion">CoreMotion</h3><p>主要用于获取各种 motion sensor 的信息，如 accelerometer、gyro、magnetometer 等等。</p>
<p>iOS 中提供的 class 是 <em><code>CMMotionManager</code></em>，你可以通过 alloc/init 来获取。<strong>但是注意</strong>，处于性能考虑，每个 app 中只能有一个全局的 CMMotionManager instance，因此你需要创建一个单例模式来实现全局单例。</p>
<p>使用流程：</p>
<ol>
<li><p><em><code>check device</code></em>：检查 device 是否支持获取某种 motion data。</p>
<p> 这里需要提一下，除了 accelerometer、gyro、magnetometer 之外，iOS 还提供了一个 <em><code>CMDeviceMotion</code></em>，对前面3种 data 进行了综合封装，可以通过它一次性获取这3种 data。</p>
<p> <img src="/img/Study_iOS_Hardware/17.9.CoreMotion.png" alt="CoreMotion"></p>
<p> <img src="/img/Study_iOS_Hardware/17.10.CoreMotion.png" alt="CoreMotion"></p>
</li>
<li><p><em><code>start &amp; get motion data</code></em>：有两种获取 motion data 的方式：</p>
<ul>
<li><p>主动 ask（poll）：<em><code>start/stopXXXUpdates</code></em></p>
</li>
<li><p>通过设置 rate，注册 callback，被动接收。</p>
<p>  <img src="/img/Study_iOS_Hardware/17.11.CoreMotion.png" alt="CoreMotion"></p>
<p>  <img src="/img/Study_iOS_Hardware/17.12.CoreMotion.png" alt="CoreMotion"></p>
<p>  <img src="/img/Study_iOS_Hardware/17.13.CoreMotion.png" alt="CoreMotion"></p>
</li>
</ul>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：Hardware">Developing Applications for iOS 观后感系列：Hardware</h3><p><em>相关视频章节：14、17</em></p>
<hr>
<p>关于 iOS device 的 hardware，本篇主要了解2个方面：CoreLocation + CoreMotion</p>
<h3 id="CoreLocation">CoreLocation</h3><ul>
<li><p><strong><code>CLLocation</code></strong>：CoreLocation 中最基本的 class。</p>
<p>  CLLocation 的重要 property：</p>
<p>  <em><code>coordinate</code></em>：位置坐标，包含 latitude 和 longitude 两个元素。</p>
<p>  <em><code>altitude</code></em>：海拔。</p>
<p>  <em><code>horizontal/verticalAccuracy</code></em>：精度。Cellular &lt; WiFi &lt; GPS。</p>
</li>
<li><p><strong><code>CLLocationManager</code></strong>：用于获取 CLLocation。</p>
<p>  使用流程：</p>
<ol>
<li><p><em><code>check device</code></em></p>
<p> 主要是检查 device 是否支持以某种方式来获取某种 location，以及是否有权限来获取。</p>
<p> 关于权限，有3中状态：Authorized、Denied、Restricted。</p>
</li>
<li><p><em><code>init &amp; delegate</code></em>：通过 CLLocationManager 来获取 CLLocation 可以有2种方式，一种是主动 ask（poll），一种是 delegate。通常采用 delegate 的方式，delegate 触发后，你就可以访问 CLLocationManager 的 property <em><code>location</code></em> 来获取当前的 CLLocation 了。</p>
</li>
<li><p><em><code>configuration</code></em></p>
<p> 通过 property <em><code>desiredAccuracy</code></em> 来设定想要的精度。</p>
<p> 通过 property <em><code>distanceFilter</code></em> 告诉 CLLocationManager，只有当 location 的变化超过该范围时，才去触发 update delegate。</p>
</li>
<li><p><em><code>start monitor</code></em></p>
<p> 你可以进行如下几种形式的 monitor，每种 monitor 都有相应的 delegate 函数，参见文档。</p>
<ul>
<li><p><em><code>normal monitor</code></em>：standard monitor，通过设定精度，每当 update 触发时，就会通知 app。</p>
</li>
<li><p><em><code>significant change monitor</code></em>：仅当 location 发生明显变化时才通知 app，这里的 significant 并未定义具体是多少。</p>
</li>
<li><p><em><code>region monitor</code></em>：当 device 进入某个指定的 region 时，通知 app。</p>
</li>
<li><p><em><code>beacon monitor</code></em>：当 device 进入某个指定的 beacon 时，通知 app，这种 monitor 通常与 <em><code>Core Bluetooth</code></em> 相关。</p>
</li>
</ul>
<p><strong>注意</strong>，当你不再需要 monitor 时，不要忘了 stop monitor。</p>
<p><strong>注意</strong>，即使 app not running，这些 monitor 也还是能够 work 的。想要在 background 模式下继续 monitor，需要在 project 中设置一下，类似于 background fetch 的设置。当 delegate 触发后，app 就会被启动。这种情况下，<code>application:didFinishLaunchingWithOption:</code> 的 option dictionary 中就会包含一个 key <code>UIApplicationLaunchOptionsLocationKey</code>。</p>
</li>
</ol>
</li>
</ul>]]>
    
    </summary>
    
      <category term="Hardware" scheme="http://hi.zongquan.wang/tags/Hardware/"/>
    
      <category term="iOS" scheme="http://hi.zongquan.wang/tags/iOS/"/>
    
      <category term="开发" scheme="http://hi.zongquan.wang/categories/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Study iOS - L18N]]></title>
    <link href="http://hi.zongquan.wang/2015/01/18/Study_iOS_L18N/"/>
    <id>http://hi.zongquan.wang/2015/01/18/Study_iOS_L18N/</id>
    <published>2015-01-18T05:35:11.000Z</published>
    <updated>2015-11-10T02:03:41.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：L18N">Developing Applications for iOS 观后感系列：L18N</h3><p><em>相关视频章节：18</em></p>
<hr>
<p>L18N 主要涉及2方面：Xcode + code。</p>
<ul>
<li><p><strong>Xcode</strong></p>
<p>  首先需要在 Xcode 中设置 app 支持的语言：</p>
<p>  <img src="/img/Study_iOS_L18N/18.1.L18N.png" alt="L18N"></p>
<p>  然后你就可以对 storyboard 进行 L18N了，Xcode 会生成相应语言的 .strings 文件。</p>
</li>
<li><p><strong>code</strong></p>
<p>  对于不在 storyboard 中的 strings 如何 L18N 呢？那就得通过 code 来处理了。</p>
<p>  <img src="/img/Study_iOS_L18N/18.2.L18N.png" alt="L18N"></p>
<p>  在代码中调用上述 macros 之后，可以通过下面命令自动生成 .strings 文件：</p>
<p>  <img src="/img/Study_iOS_L18N/18.3.L18N.png" alt="L18N"></p>
<p>  <strong>注意</strong>，当你从 <em><code>Bundle</code></em> 中获取某个文件的 path 时，其搜索顺序是：先 bundle 的 top-level 层，后 .lproj 层。</p>
</li>
</ul>
<a id="more"></a>
<h3 id="Locale">Locale</h3><p>提到 L18N，就不得不提 Locale，因为它是整个 L18N 得以实现的基础。此外，Locale 也决定了 date 和 number 的格式。</p>
<p><strong>注意</strong>，Locale 和 language 不是等价的，language 一样的时候，Locale 不一定一样。</p>
<ul>
<li><p><strong><code>NSLocale</code></strong>：iOS 中主要靠该 class 来获取 Locale 相关的信息，该 class 知道如何设定不同格式的 date 和 number。也就是说，对 date 和 number 的设定主要就是给他们传递对应的 NSLocale 参数。</p>
</li>
<li><p><strong><code>NSNumberFormatter</code></strong></p>
<p>  <img src="/img/Study_iOS_L18N/18.6.L18N.NSNumberFormatter.png" alt="L18N"></p>
</li>
<li><p><strong><code>NSDateFormatter</code></strong></p>
<p>  <img src="/img/Study_iOS_L18N/18.7.L18N.NSDateFormatter.png" alt="L18N"></p>
</li>
<li><p><strong><code>NSString</code></strong></p>
<p>  <img src="/img/Study_iOS_L18N/18.8.L18N.NSString.png" alt="L18N"></p>
</li>
<li><p><strong><code>UIImage</code></strong></p>
<p>  当你调用 UIImage 的 <code>imageNamed:*</code> 时，它也是会去搜索相应的 .lproj 目录的。</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：L18N">Developing Applications for iOS 观后感系列：L18N</h3><p><em>相关视频章节：18</em></p>
<hr>
<p>L18N 主要涉及2方面：Xcode + code。</p>
<ul>
<li><p><strong>Xcode</strong></p>
<p>  首先需要在 Xcode 中设置 app 支持的语言：</p>
<p>  <img src="/img/Study_iOS_L18N/18.1.L18N.png" alt="L18N"></p>
<p>  然后你就可以对 storyboard 进行 L18N了，Xcode 会生成相应语言的 .strings 文件。</p>
</li>
<li><p><strong>code</strong></p>
<p>  对于不在 storyboard 中的 strings 如何 L18N 呢？那就得通过 code 来处理了。</p>
<p>  <img src="/img/Study_iOS_L18N/18.2.L18N.png" alt="L18N"></p>
<p>  在代码中调用上述 macros 之后，可以通过下面命令自动生成 .strings 文件：</p>
<p>  <img src="/img/Study_iOS_L18N/18.3.L18N.png" alt="L18N"></p>
<p>  <strong>注意</strong>，当你从 <em><code>Bundle</code></em> 中获取某个文件的 path 时，其搜索顺序是：先 bundle 的 top-level 层，后 .lproj 层。</p>
</li>
</ul>]]>
    
    </summary>
    
      <category term="UI" scheme="http://hi.zongquan.wang/tags/UI/"/>
    
      <category term="iOS" scheme="http://hi.zongquan.wang/tags/iOS/"/>
    
      <category term="开发" scheme="http://hi.zongquan.wang/categories/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Study iOS - Misc UI]]></title>
    <link href="http://hi.zongquan.wang/2015/01/17/Study_iOS_Misc_UI/"/>
    <id>http://hi.zongquan.wang/2015/01/17/Study_iOS_Misc_UI/</id>
    <published>2015-01-17T07:30:03.000Z</published>
    <updated>2015-11-10T02:03:41.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：Misc_UI">Developing Applications for iOS 观后感系列：Misc UI</h3><p><em>相关视频章节：all</em></p>
<hr>
<p>之前的文章已经学习了几种 iOS 中比较大而重要的 UIView，例如 UIScrollView、UITableView 等，本篇主要了解一下其它一些比较常用的小型 UI 类型。</p>
<h3 id="UITextView">UITextView</h3><p><strong><code>UITextView</code></strong> 提供了一个 multi-line、selectable、editable、scrollable 的编辑区，通过 <em><code>NSMutableAttributedString</code></em> 来设定它的文本内容和各种属性。</p>
<p>UITextView 有3个比较重要的 property，它们共同完成整个 UITextView 内容的显示。</p>
<ul>
<li><p><em><code>textStorage</code></em>：NSTextStorage 是 NSMutableAttributedString 的 subclass，也就是说，UITextView 的文本内容和文本属性是通过该 property 来决定的，对其赋值什么样的 NSMutableAttributedString，就会显示什么样的内容。</p>
</li>
<li><p><em><code>textContainer</code></em>：NSTextContainer 决定了 NSTextStorage 将会布局在整个 UITextView 的哪个区域中，即 where text can be。你甚至可以通过它来指定一个 <em><code>exclusion zones</code></em>（例如一个 image），这样 NSTextStorage 就会围绕这个 exclusion  zones 来布局，如同 Word 中的图片环绕效果，灰常 NB。</p>
</li>
<li><p><em><code>layoutManager</code></em>：前面2个 property，一个决定内容，一个决定样式，那么剩下的 NSLayoutManager 就是负责从 NSTextStorage 中获取到 text，然后将它们 lay down 到 NSTextContainer 设定的有效区域中。</p>
</li>
</ul>
<a id="more"></a>
<h3 id="UITextField">UITextField</h3><p><strong><code>UITextField</code></strong> 就像是 UILabel 的升级版，它是 editable 的。这里主要了解下 <em><code>UITextFieldDelegate</code></em> 以及 <em><code>Keyboard</code></em> 的使用。当然 UITextView 也有这些东西，这里就不赘述了。</p>
<ul>
<li><p>当 UITextField 成为 <em><code>first responder</code></em> 时，iOS 的 Keyboard 就会自动弹出。有2种方式可以实现：</p>
<ol>
<li><p>用户点击 UITextField，它自动就会变成 first responder。</p>
</li>
<li><p>通过代码主动调用 <em><code>becomeFirstResponder</code></em>。</p>
<p>反过来，想要让 Keyboard 收回，调用 <em><code>resignFirstResponder</code></em> 即可。</p>
</li>
</ol>
</li>
<li><p><em><code>UITextFieldDelegate</code></em>，举几个例子：</p>
<p>  <code>-(BOOL)textFieldShouldReturn:(UITextField *)textField</code>：当用户按下 Return 键后，该 delegate 就会触发。在这里，除了返回 BOOL，通常你还会调用 [textField resignFirstResponder] 来收回 Keyboard。</p>
<p>  <code>-(void)textFieldDidEndEditing:(UITextField *)textField</code>：当 UITextField resign first responder 后，该 delegate 就会触发。在这里，你可以利用新的 UITextField 来 update UI。</p>
</li>
<li><p>UITextField 还有几个相关的 <em><code>Notifications</code></em>，用于实时反馈 UITextField 当前的状态。例如<br>UITextFieldTextDidChangeNotification。</p>
</li>
<li><p><em><code>target-action</code></em>：UITextField 也是个 UIControl，所以你可以对其设定 target-action。UITextField 有许多 UIControlEvents 供设定，具体参见在 Xcode 中右击 UITextField 显示的菜单。</p>
</li>
<li><p><em><code>Keyboard</code></em></p>
<p>  一般来说，我们提到 Keyboard 时，总是指通过某个 UITextField 或者 UITextView 而弹出来的那个 Keyboard，两者是相关的，对该 Keyboard 的设置通常就是通过与其相关的那个 UITextField 或者 UITextView 来设定的。</p>
<p>  如何控制 Keyboard 的外观：通过 <em><code>UITextInputTraits</code></em> 这个 protocol。UITextField 和 UITextView 已经实现了。该 protocol 中有若干 property 用于自定义你的 Keyboard。</p>
<p>  你可以给 Keyboard 添加一个 accessory view 来实现自定义的 toolbar，通过设置 UITextField 的 property <em><code>inputAccessoryView</code></em> 来完成。此外，UITextField 还有些其它的 accessory view，例如 left view、right view、clear button 等等。</p>
<p>  <strong>注意</strong>，Keyboard 出现时，总是会 cover 其它 view，所以，你需要自己来处理 Keyboard 弹出后的 UI 布局。例如移动位置等等。你可以通过 <em><code>UIKeyboardXXXNotification</code></em> 来获取 Keyboard 的状态，从而做出响应。例如，如果 UITableView 中有个 UITextField，那么 UITableViewController 就需要监听 UIKeyboardDidShowNotification，这样当用户编辑某行的 UITextField 导致 Keyboard 弹出时，table 可以进行 scroll，从而保证该行不会被 Keyboard 覆盖。</p>
</li>
</ul>
<h3 id="UIActionSheet">UIActionSheet</h3><p><strong><code>UIActionSheet</code></strong> 用于呈现一个选择列表。通常是从屏幕下方弹出，让用户做出选择。</p>
<ul>
<li><p><em><code>init</code></em>：<code>initWithTitle:delegate:cancelButtonTitle:destructiveButtonTitle:otherButtonTitles:</code>，其中，destructiveButton 会显示为红色，用于警示用户该操作的严重性。其它 button 为普通颜色。</p>
</li>
<li><p><em><code>button</code></em>：init 之后，你还可以通过 <code>addButtonWithTitle:</code> 继续给 action sheet 添加其它普通 button。之后想要获取 action sheet 中的这些 button 时，可以通过 action sheet 的这些 property 来完成：<em><code>cancelButtonIndex</code></em>、<em><code>destructiveButtonIndex</code></em>、<em><code>numberOfButtons</code></em>、<em><code>buttonTitleAtIndex:</code></em> 等等。</p>
</li>
<li><p><em><code>display</code></em>：</p>
<ul>
<li><p><code>[actionSheet showInView:]</code></p>
</li>
<li><p><code>[actionSheet showFromBarButtonItem:animated:]</code>，<strong>这里需要注意一点</strong>，对于这种 display 方式（通常是在 iPad 中），action sheet 是显示在一个 popover 中的，是不会显示 cancel button 的，显然这是合理的，因为点击屏幕其它地方后 popover 就可以自己消失。但是别忘了，popover 有个 passthroughViews，点击这里面的 view 不会让 popover 消失，而 bar button item 是在 passthroughViews 中的，所以，如果你不停地点击它，就会不停地叠加 action sheet。所以这里需要你手动处理下，保证只弹出一个 action sheet。</p>
</li>
<li><p><code>[actionSheet showFromRect:inView:animated:]</code></p>
</li>
</ul>
</li>
<li><p><em><code>delegate</code></em>：通过 delegate，你可以知道用户点击的是哪个 button，即 <code>actionSheet:didDismissWithButtonIndex:</code>。</p>
<p>  此外，你可以通过 code 手动触发点击某个 button 这种行为，即 <code>dismissWithClickedButtonIndex:animated:</code>。</p>
</li>
</ul>
<h3 id="UIAlertView">UIAlertView</h3><p><strong><code>UIAlertView</code></strong> 与 UIActionSheet 很相似，具有相似的 init 方式、添加新 button 的函数等。这里只了解几点不同的地方。</p>
<ul>
<li><p><em><code>display</code></em>：只有一种方式，即 <code>[alert show]</code>，alert 就会显示在屏幕中间。</p>
</li>
<li><p><em><code>add UITextField</code></em>：你可以在 UIAlertView 中添加 UITextField，让用户在其中输入，例如登录框。方法是设置 UIAlertView 的 property <em><code>alertViewStyle</code></em>。</p>
</li>
</ul>
<h3 id="UIImagePickerController">UIImagePickerController</h3><p><strong><code>UIImagePickerController</code></strong> 用于呈现一个 Modal view，让用户选择一张照片（photo library 中已有的照片，或者用 camera 新拍一张照片），然后将该照片返回供 app 使用。</p>
<p><strong>注意</strong>，既然是个 Modal view，那就意味着需要这么呈现：通过 <code>Modal Segue</code>，或者调用 <code>presentViewContainer:animated:completion:</code>。参见 <a href="../../../../2015/01/10/Study_iOS_Segue/">Segue</a>。</p>
<p>UIImagePickerController 的使用流程如下：</p>
<ol>
<li><p><em><code>init &amp; delegate</code></em>：delegate 一般设置为 UIImagePickerController 的 presenter。</p>
</li>
<li><p><em><code>configuration</code></em></p>
<p> 主要是设置 UIImagePickerController 的 source type、media type 等等。设置之前，通常需要先进行检查，看看该 device 是否支持要设置的值。</p>
<ul>
<li><p><em><code>source type</code></em>：有的 device 有 camera，有的则没有 camera，只有 photo library。因此你需要检查该 device 是否支持 UIImagePickerController 的某种 source type。通过调用 <code>isSourceTypeAvailable:</code> 即可。</p>
<p>  有3种 source type：UIImagePickerControllerSourceTypePhotoLibrary、UIImagePickerControllerSourceTypeCamera、UIImagePickerControllerSourceTypeSavedPhotosAlbum。</p>
</li>
<li><p><em><code>media type</code></em>：每种 source type 支持的 media type 也不同，有的支持 video，有的只支持 picture。因此 media type 也需要进行检查。通过调用 <code>+(NSArray *)availableMediaTypesForSourceType:</code>即可。</p>
<p>  有2种 media type：kUTTypeImage 和 看UTTypeMovie。</p>
<p>  还有其它一些检查函数，例如检查 front/rear camera 等等，参见文档。</p>
</li>
<li><p><em><code>editability</code></em>：是否允许用户对选取的图片进行编辑。如果允许，UIImagePickerController 会把原始图片和编辑后的图片都返给 app。</p>
</li>
<li><p>其他 configuration，参见文档。</p>
</li>
</ul>
</li>
<li><p><em><code>present</code></em>：前面已经提到了，要采用 Modal view 的呈现方式。</p>
</li>
<li><p><em><code>respond to delegate</code></em></p>
<p> 当用户完成选取照片后：<code>imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary *)info</code>，其中，info 中提供了要返给 app 的图片数据，参见文档。通过 <em><code>ALAssetsLibrary</code></em>，你可以将该图片保存到用户的 photo library。</p>
<p> 当用户取消选取照片后：<code>imagePickerControllerDidCancel:(UIImagePickerController *)picker</code>。</p>
<p> 在用户完成/取消选取照片后，你都需要关闭当前的这个 Modal view，即调用 <code>[self dismissViewControllerAnimated:completion:]</code>。</p>
</li>
</ol>
<h3 id="Settings">Settings</h3><p><strong><code>Settings</code></strong> 指的是 iOS 中的 Settings app，你可以在里面添加自己 app 的设置选项。这个机制利用的是 <em><code>NSUserDefaults</code></em>。</p>
<p>直接上图</p>
<p><img src="/img/Study_iOS_Misc_UI/18.10.Settings.png" alt="Settings"></p>
<p><img src="/img/Study_iOS_Misc_UI/18.11.Settings.png" alt="Settings"></p>
<p><img src="/img/Study_iOS_Misc_UI/18.12.Settings.png" alt="Settings"></p>
<p><img src="/img/Study_iOS_Misc_UI/18.13.Settings.png" alt="Settings"></p>
<p><strong>注意</strong>：code 通常需要监听 NSUserDefaults 的变化，来及时获取 Settings 中新的值。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：Misc_UI">Developing Applications for iOS 观后感系列：Misc UI</h3><p><em>相关视频章节：all</em></p>
<hr>
<p>之前的文章已经学习了几种 iOS 中比较大而重要的 UIView，例如 UIScrollView、UITableView 等，本篇主要了解一下其它一些比较常用的小型 UI 类型。</p>
<h3 id="UITextView">UITextView</h3><p><strong><code>UITextView</code></strong> 提供了一个 multi-line、selectable、editable、scrollable 的编辑区，通过 <em><code>NSMutableAttributedString</code></em> 来设定它的文本内容和各种属性。</p>
<p>UITextView 有3个比较重要的 property，它们共同完成整个 UITextView 内容的显示。</p>
<ul>
<li><p><em><code>textStorage</code></em>：NSTextStorage 是 NSMutableAttributedString 的 subclass，也就是说，UITextView 的文本内容和文本属性是通过该 property 来决定的，对其赋值什么样的 NSMutableAttributedString，就会显示什么样的内容。</p>
</li>
<li><p><em><code>textContainer</code></em>：NSTextContainer 决定了 NSTextStorage 将会布局在整个 UITextView 的哪个区域中，即 where text can be。你甚至可以通过它来指定一个 <em><code>exclusion zones</code></em>（例如一个 image），这样 NSTextStorage 就会围绕这个 exclusion  zones 来布局，如同 Word 中的图片环绕效果，灰常 NB。</p>
</li>
<li><p><em><code>layoutManager</code></em>：前面2个 property，一个决定内容，一个决定样式，那么剩下的 NSLayoutManager 就是负责从 NSTextStorage 中获取到 text，然后将它们 lay down 到 NSTextContainer 设定的有效区域中。</p>
</li>
</ul>]]>
    
    </summary>
    
      <category term="UI" scheme="http://hi.zongquan.wang/tags/UI/"/>
    
      <category term="iOS" scheme="http://hi.zongquan.wang/tags/iOS/"/>
    
      <category term="开发" scheme="http://hi.zongquan.wang/categories/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Study iOS - CoreData]]></title>
    <link href="http://hi.zongquan.wang/2015/01/11/Study_iOS_CoreData/"/>
    <id>http://hi.zongquan.wang/2015/01/11/Study_iOS_CoreData/</id>
    <published>2015-01-11T08:51:58.000Z</published>
    <updated>2015-11-10T02:03:41.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：CoreData">Developing Applications for iOS 观后感系列：CoreData</h3><p><em>相关视频章节：12，13</em></p>
<hr>
<p><strong><code>CoreData</code></strong> 是 iOS 提供的一套用于管理 app 的 Model 的 framework，它就像是个 object database，支持对 object 的各种操作：add、delete、query、undo、redo、autosave 等，灰常 NB。但它并不是 database 的某种实现，你可以基于持久化文件（如 sqlite 等）来使用 CoreData，也可以完全基于内存来使用。</p>
<p>使用 CoreData 会涉及 Xcode 和 code 两方面。</p>
<p>首先看一下在 Xcode 中需要做什么。</p>
<h3 id="创建_Data_Model">创建 Data Model</h3><ul>
<li><p>类似于 .storyboard 文件，这里你需要创建一个 <em><code>.xcdatamodeld</code></em> 文件，它存储了 app 的 Data Model。.xcdatamodeld 文件内容如下：</p>
<p>  <img src="/img/Study_iOS_CoreData/12.0.CoreData.png" alt="CoreData"></p>
<p>  就像设计数据库的 ER 图，在这里，你需要设计好 object 对应的 <em><code>Entity</code></em>。这里的 Entity 会对应到 code 中的 <em><code>NSManagedObject（或其 subclass）</code></em>。</p>
<p>  <img src="/img/Study_iOS_CoreData/12.1.CoreData.png" alt="CoreData"></p>
<p>  <img src="/img/Study_iOS_CoreData/12.2.CoreData.png" alt="CoreData"></p>
</li>
<li><p>Model 构建好了之后，下面就需要创建出与这些 Entity 对应的 NSManagedObject，供 code 中使用。</p>
<p>  <img src="/img/Study_iOS_CoreData/12.12.CoreData.Add.png" alt="CoreData"></p>
<p>  <img src="/img/Study_iOS_CoreData/12.13.CoreData.Add.png" alt="CoreData"></p>
<p>  这样我们就可以直接使用这些 NSManagedObject subclass 了，而且也可以方便地访问它们的 properties，而不用去调用繁琐的 valueForKey 和 setValue:forKey。</p>
<p>  <strong>注意</strong>，以后当我们修改了 Model 的 Entity 后，需要重新执行一遍这一步，来更新这些 NSManagedObject subclass。这也意味着，这些 .h 和 .m 会被重新生成。所以这里常常使用的一个技巧是，为这些 NSManagedObject subclass 添加 <em><code>category</code></em>，在 category 中创建一些额外的函数供 NSManagedObject subclass 使用，这样以后更新 NSManagedObject subclass 时，只有最原本的 .h 和 .m 文件被重新生成，而不会影响到我们的 category。</p>
</li>
</ul>
<p>Xcode 这边基本就完成了，下面开始进入 code。</p>
<a id="more"></a>
<h3 id="NSManagedObjectContext">NSManagedObjectContext</h3><p>CoreData 的基本要素就是 NSManagedObject。那么如何获取我们的 NSManagedObject 呢？答案就是从 <em><code>NSManagedObjectContext</code></em> 中获取。</p>
<p>有2种方式来获取这个 NSManagedObjectContext：</p>
<ol>
<li><p>创建一个 <em><code>UIManagedDocument</code></em>，它里面有个 property：managedObjectContext。Bingo！</p>
</li>
<li><p>当创建 project 时，下面有个选项：<em><code>&quot;Use Core Data&quot;</code></em>，如果选中这个选项，那么 Xcode 会在 <em><code>AppDelegate</code></em> 中给你提供一个 property：managedObjectContext。以后 code 中访问它就行了。</p>
</li>
</ol>
<p>本篇主要涉及第1种方式，下面就理解一下 UIManagedDocument。</p>
<h3 id="UIManagedDocument">UIManagedDocument</h3><p>UIManagedDocument 是 <em><code>UIDocument</code></em> 的 subclass，提供了管理存储内容的机制。它也支持 iCloud，可以把它理解成 CoreData Model 的一个容器。</p>
<ul>
<li><p><strong>创建 UIManagedDocument</strong>：</p>
<pre><code><span class="built_in">NSURL</span> *documentsDir = [[[<span class="built_in">NSFileManager</span> defaultManager] URLsForDirectory:<span class="built_in">NSDocumentDirectory</span>
                                                              inDomains:<span class="built_in">NSUserDomainMask</span>] firstObject];
<span class="built_in">NSString</span> *managedDocumentName = <span class="string">@"XXX"</span>;
<span class="built_in">NSURL</span> *managedDocumentURL = [documentsDir URLByAppendingPathComponent:managedDocumentName];
<span class="built_in">UIManagedDocument</span> *managedDocument = [[<span class="built_in">UIManagedDocument</span> alloc] initWithFileURL:managedDocumentURL];
</code></pre><p>  上面只是在内存中创建了一个 UIManagedDocument instance，想要从中获取 NSManagedObjectContext，你还需要下面操作。</p>
</li>
<li><p><strong>通过 open / create UIManagedDocument 来获取 NSManagedObjectContext</strong></p>
<pre><code><span class="keyword">if</span> ([[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:[managedDocumentURL path]]) {
    [managedDocument openWithCompletionHandler:^(<span class="built_in">BOOL</span> success) {
        <span class="keyword">if</span> (success) {
            [<span class="keyword">self</span> documentIsReady];
        }
    }];
} <span class="keyword">else</span> {
    [managedDocument saveToURL:managedDocumentURL
              forSaveOperation:<span class="built_in">UIDocumentSaveForCreating</span>
             completionHandler:^(<span class="built_in">BOOL</span> success) {
                 <span class="keyword">if</span> (success) {
                    [<span class="keyword">self</span> documentIsReady];
                }
             }];
}

-(<span class="keyword">void</span>)documentIsReady
{
    <span class="keyword">if</span> (managedDocument<span class="variable">.documentState</span> == <span class="built_in">UIDocumentStateNormal</span>) {
        <span class="built_in">NSManagedObjectContext</span> *context = managedDocument<span class="variable">.managedObjectContext</span>;
        <span class="comment">// use the context to do Core Data stuff</span>
    }
}
</code></pre><p>  上面示例中注意2点：</p>
<p>  为什么需要 <em><code>completionHandler</code></em>？因为 open/save 操作是 <em><code>asynchronous</code></em>（想想看，iCloud 必须要 asynchronous）。</p>
<p>  关于 check <em><code>documentState</code></em>，还有其它一些取值，参见文档。</p>
</li>
<li><p><strong>保存和关闭</strong></p>
<p>  <img src="/img/Study_iOS_CoreData/12.7.UIManagedDocument.png" alt="CoreData"></p>
<p>  虽然 NSManagedObjectContext 是 autosave 的，但你是可以观察到这一动作的：</p>
<p>  <img src="/img/Study_iOS_CoreData/12.8.UIManagedDocument.png" alt="CoreData"></p>
</li>
</ul>
<p>好了，UIManagedDocument 有了，NSManagedObjectContext 也有了，现在轮到 NSManagedObject 了。</p>
<h3 id="NSManagedObject_的_Add">NSManagedObject 的 Add</h3><p><img src="/img/Study_iOS_CoreData/12.14.CoreData.Add.png" alt="CoreData"></p>
<h3 id="NSManagedObject_的_Delete">NSManagedObject 的 Delete</h3><p><img src="/img/Study_iOS_CoreData/12.17.CoreData.Delete.png" alt="CoreData"></p>
<p><strong>注意</strong>，不管是 Add 还是 Delete，这些 change 都是发生在内存中的，直到你手动 save 或由 UIManagedDocument 自己来 autosave。</p>
<h3 id="NSManagedObject_的_Query">NSManagedObject 的 Query</h3><p>query 操作是由 <em><code>NSFetchRequest</code></em> 来完成的。创建 NSFetchRequest 需要一下4点：</p>
<ul>
<li>指定要 fetch 的 Entity。</li>
<li>指定 fetch 结果集的大小，默认是所有。</li>
<li>指定 NSSortDescriptor 对结果集进行排序。</li>
<li>指定 NSPredicate 对结果集进行过滤，默认是所有。</li>
</ul>
<p>(关于 <em><code>NSSortDescriptor</code></em> 和 <em><code>NSPredicate</code></em>，参见文档。)</p>
<p>创建好 NSFetchRequest 后，就可以调用 <code>NSArray *results = [context executeFetchRequest:request error:&amp;error]</code> 来获取结果了。</p>
<p><strong>注意</strong>，出于内存优化，CoreData 在 execute NSFetchRequest 时采用了 <em><code>lazy load</code></em> 的机制，它不会一次性地把 results 中的所有 NSManagedObject 都加载到内存中，而是等到你真正地访问其中的某个 NSManagedObject 时，才会进行加载。</p>
<h3 id="CoreData_的_Thread_Safety">CoreData 的 Thread Safety</h3><p><strong>NSManagedObjectContext 不是线程安全的</strong>，不过 CoreData 一般非常高效，所以没必要去多线程操作（例如查询）。</p>
<p><strong>这里需要注意</strong>，NSManagedObjectContext 在哪个 queue 上创建，你就只能在那个 queue 上访问 NSManagedObjectContext 以及它的 NSManagedObject。很可能就是在 main Q 上。</p>
<p>鉴于上面这个问题，NSManagedObjectContext 提供了一个线程安全的 API：</p>
<pre><code>[context <span class="symbol">performBlock:</span>^{
    <span class="regexp">//</span> <span class="keyword">do</span> stuff <span class="keyword">with</span> <span class="constant">NSManagedObjectContext</span> &amp; <span class="constant">NSManagedObject</span>
}]
</code></pre><p><strong>context 会在自己的 safe queue（即被创建的 queue）上来执行 block。</strong> :)</p>
<p>CoreData 本身就先提这些，下面还有个比较重要的话题。</p>
<h3 id="CoreData_&amp;_UITableView">CoreData &amp; UITableView</h3><p>CoreData 中的数据通常会显示到 UITableView 上，因此 iOS 为我们提供了 <em><code>NSFetchedResultsController</code></em>，用于把 NSFetchRequest hook 到 UITableView 上，实现 CoreData 到 UITableView 上的自动映射。</p>
<ul>
<li><p><strong>NSFetchedResultsController 提供 UITableViewDataSource</strong></p>
<pre><code>-(<span class="built_in">NSUInteger</span>)numberOfSectionsInTableView:(<span class="built_in">UITableView</span> *)sender
{
    <span class="keyword">return</span> [[<span class="keyword">self</span><span class="variable">.fetchedResultsController</span> sections] count];
}

-(<span class="built_in">NSUInteger</span>)tableView:(<span class="built_in">UITableView</span> *)sender numberOfRowsInSection:(<span class="built_in">NSUInteger</span>)section
{
    <span class="keyword">return</span> [[[<span class="keyword">self</span><span class="variable">.fetchedResultsController</span> sections] objectAtIndex:section] numberOfObjects];
}

-(<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)sender
        cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath
{
    <span class="built_in">UITableViewCell</span> *cell = XXX;
    <span class="built_in">NSManagedObject</span> *managedObject = [<span class="keyword">self</span><span class="variable">.fetchedResultsController</span> objectAtIndexPath:indexPath];
    <span class="comment">// setup</span>
    <span class="keyword">return</span> cell;
}
</code></pre><p>  上面需要注意的就是 NSFetchedResultsController 的一个 API：</p>
<p>  <code>-(NSManagedObject *)objectAtIndexPath:(NSIndexPath *)indexPath</code></p>
<p>  也就是说，NSFetchedResultsController 以某种方式将结果集的结构封装的跟 UITableView 的 DataSource 一样，也有个 NSIndexPath。</p>
<p>  那么 NSFetchedResultsController 该如何创建呢？</p>
</li>
<li><p><strong>创建 NSFetchedResultsController</strong></p>
<p>  <img src="/img/Study_iOS_CoreData/13.2.NSFetchedResultsController.png" alt="CoreData"></p>
<p>  <strong>需要注意的是</strong>：NSFetchRequest 中的 sortDescriptor 一定要与 NSFetchedResultsController init 函数中的 sectionNameKeyPath 匹配，这样 NSFetchedResultsController 才能正确地构造出前面提到的 NSIndexPath。<strong>此外</strong>，调用 init 函数后，你就不能再去修改 NSFetchedResultsController 的 fetchRequest 的属性了（例如修改 sortDescriptor 和 predicate）。</p>
</li>
<li><p><strong>通过 NSFetchedResultsController 执行 query</strong></p>
<p>  调用 NSFetchedResultsController 的函数 <code>-(BOOL)performFetch:(NSError **)error</code>，即可实现手动 fetch，这之后，通常伴随着 UITableView 的 reload。</p>
<p>  除了手动 fetch，NSFetchedResultsController 更重要的功能是自动捕获 CoreData 的变化，并以此更新 UITableView。想要实现这一点，需要下面的东西。</p>
</li>
<li><p><strong>NSFetchedResultsControllerDelegate</strong></p>
<p>  当给 NSFetchedResultsController 指定 delegate 后，它就会 keep tracking 自己的 NSFetchRequest，并将更新报告给它的 delegate。显然，在这里，它的 delegate 应该指定为 UITableViewController。如果不指定 delegate，它就不会实现这种机制。</p>
<p>  主要有这些 delegate 函数：</p>
<ul>
<li><p><code>controller:didChangeObject:atIndexPath:forChangeType:newIndexPath:</code>：track 单个 object 的更新（add、remove、move、update）</p>
</li>
<li><p><code>controller:didChangeSection:atIndex:forChangeType:</code>：track 某个 section 的 add 或 remove</p>
</li>
<li><p><code>-controllerDidChangeContent:</code>：track 整个 NSFetchRequest</p>
</li>
</ul>
</li>
</ul>
<p>参见文档 sample code。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：CoreData">Developing Applications for iOS 观后感系列：CoreData</h3><p><em>相关视频章节：12，13</em></p>
<hr>
<p><strong><code>CoreData</code></strong> 是 iOS 提供的一套用于管理 app 的 Model 的 framework，它就像是个 object database，支持对 object 的各种操作：add、delete、query、undo、redo、autosave 等，灰常 NB。但它并不是 database 的某种实现，你可以基于持久化文件（如 sqlite 等）来使用 CoreData，也可以完全基于内存来使用。</p>
<p>使用 CoreData 会涉及 Xcode 和 code 两方面。</p>
<p>首先看一下在 Xcode 中需要做什么。</p>
<h3 id="创建_Data_Model">创建 Data Model</h3><ul>
<li><p>类似于 .storyboard 文件，这里你需要创建一个 <em><code>.xcdatamodeld</code></em> 文件，它存储了 app 的 Data Model。.xcdatamodeld 文件内容如下：</p>
<p>  <img src="/img/Study_iOS_CoreData/12.0.CoreData.png" alt="CoreData"></p>
<p>  就像设计数据库的 ER 图，在这里，你需要设计好 object 对应的 <em><code>Entity</code></em>。这里的 Entity 会对应到 code 中的 <em><code>NSManagedObject（或其 subclass）</code></em>。</p>
<p>  <img src="/img/Study_iOS_CoreData/12.1.CoreData.png" alt="CoreData"></p>
<p>  <img src="/img/Study_iOS_CoreData/12.2.CoreData.png" alt="CoreData"></p>
</li>
<li><p>Model 构建好了之后，下面就需要创建出与这些 Entity 对应的 NSManagedObject，供 code 中使用。</p>
<p>  <img src="/img/Study_iOS_CoreData/12.12.CoreData.Add.png" alt="CoreData"></p>
<p>  <img src="/img/Study_iOS_CoreData/12.13.CoreData.Add.png" alt="CoreData"></p>
<p>  这样我们就可以直接使用这些 NSManagedObject subclass 了，而且也可以方便地访问它们的 properties，而不用去调用繁琐的 valueForKey 和 setValue:forKey。</p>
<p>  <strong>注意</strong>，以后当我们修改了 Model 的 Entity 后，需要重新执行一遍这一步，来更新这些 NSManagedObject subclass。这也意味着，这些 .h 和 .m 会被重新生成。所以这里常常使用的一个技巧是，为这些 NSManagedObject subclass 添加 <em><code>category</code></em>，在 category 中创建一些额外的函数供 NSManagedObject subclass 使用，这样以后更新 NSManagedObject subclass 时，只有最原本的 .h 和 .m 文件被重新生成，而不会影响到我们的 category。</p>
</li>
</ul>
<p>Xcode 这边基本就完成了，下面开始进入 code。</p>]]>
    
    </summary>
    
      <category term="CoreData" scheme="http://hi.zongquan.wang/tags/CoreData/"/>
    
      <category term="iOS" scheme="http://hi.zongquan.wang/tags/iOS/"/>
    
      <category term="开发" scheme="http://hi.zongquan.wang/categories/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Study iOS - UITableView]]></title>
    <link href="http://hi.zongquan.wang/2015/01/11/Study_iOS_UITableView/"/>
    <id>http://hi.zongquan.wang/2015/01/11/Study_iOS_UITableView/</id>
    <published>2015-01-11T06:42:21.000Z</published>
    <updated>2015-11-10T02:03:41.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：UITableView">Developing Applications for iOS 观后感系列：UITableView</h3><p><em>相关视频章节：11</em></p>
<hr>
<h4 id="UITableView_分类">UITableView 分类</h4><p>按内容分：</p>
<ul>
<li><p><em><code>dynamic</code></em>：在 storyboard 中设定 prototype，在代码中 load 内容。<em>（本篇主要涉及 dynamic NSTableView）</em></p>
</li>
<li><p><em><code>static</code></em>：完全在 storyboard 中设定。</p>
</li>
</ul>
<p>按样式分：</p>
<p><em><code>ungrouped</code></em> / <em><code>grouped</code></em></p>
<p>示例：</p>
<p><img src="/img/Study_iOS_UITableView/11.0.UITableView.png" alt="UITableView"></p>
<h4 id="UITableView_的构成">UITableView 的构成</h4><p>与 Mac 上的NSTableView 不同，iOS 中的 UITableView 都是一维的，只有一列。</p>
<p><img src="/img/Study_iOS_UITableView/11.1.UITableView.png" alt="UITableView"> <img src="/img/Study_iOS_UITableView/11.2.UITableView.png" alt="UITableView"></p>
<a id="more"></a>
<h4 id="UITableView_的使用">UITableView 的使用</h4><ol>
<li><p><strong>设定 cell 的 <code>prototype</code></strong></p>
<p> <img src="/img/Study_iOS_UITableView/11.3.UITableView.png" alt="UITableView"></p>
<p> <img src="/img/Study_iOS_UITableView/11.4.UITableView.png" alt="UITableView"></p>
</li>
<li><p><strong>实现 <code>UITableViewDataSource</code></strong></p>
<p> <strong>UITableViewDataSource</strong> 用于控制 what UITableView displays。主要有这些 API：</p>
<ul>
<li><p>基于 prototype，每个 cell 该如何显示在 table 中：</p>
<p>  <img src="/img/Study_iOS_UITableView/11.5.UITableView.png" alt="UITableView"></p>
</li>
<li><p>table 有多少 section，多少 row：</p>
<p>  <img src="/img/Study_iOS_UITableView/11.6.UITableView.png" alt="UITableView"></p>
</li>
</ul>
</li>
<li><p><strong>实现 <code>UITableViewDelegate</code></strong></p>
<p><strong>UITableDelegate</strong> 用于控制 how UITableView displays，以及 observe what UITableView is doing（排序、选择、滚动、插入、删除、更新等等），参见文档。这里简单提几个：</p>
<ul>
<li><p>用户选中某行时，会调用 <em><code>-(void)tableView:didSelectRowAtIndexPath:</code></em></p>
</li>
<li><p>用户点击某行中的 <em><code>accessory button</code></em>，会调用 <em><code>-(void)tableView:accessoryButtonTappedForRowWithIndexPath:</code></em></p>
<p>  <img src="/img/Study_iOS_UITableView/11.9.UITableView.png" alt="UITableView"></p>
</li>
<li><p>当然，你可以不使用这些 delegate，而是借助 Segue：</p>
<p>  <img src="/img/Study_iOS_UITableView/11.10.UITableView.png" alt="UITableView"></p>
<p>  然后 prepareForSegue：</p>
<pre><code>-(<span class="keyword">void</span>)prepareForSegue:(<span class="built_in">UIStoryboardSegue</span> *)segue sender:(<span class="keyword">id</span>)sender
{
    <span class="built_in">NSIndexPath</span> *indexPath = [<span class="keyword">self</span><span class="variable">.tableView</span> indexPathForCell:sender];
    <span class="comment">// indexPath.row in indexPath.section</span>
    <span class="comment">// prepare segue.destinationController</span>
}
</code></pre></li>
</ul>
</li>
<li><p><strong>reload</strong></p>
<p> 当 table 的 Model 发生变化后，你需要去 reload 来更新 table。</p>
<p> <code>-(void)reloadData</code>：更新整个 table，重新调用一遍 UITableViewDataSource，比较 heavyweight。</p>
<p> <code>-(void)reloadRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animationStyle</code>：只更新指定的行，比较 lightweight。</p>
</li>
<li><p><strong>Spinner</strong></p>
<p> UITableView 有个内置的 activity indicator Spinner：<code>@property (strong) UIRefreshControl *refreshControl;</code></p>
<p> <img src="/img/Study_iOS_UITableView/11.12.UITableView.png" alt="UITableView"></p>
<p> <code>[self.refreshControl beginRefreshing]</code>：table 下伸，Spinner 出现并开始 spinning。</p>
<p> <code>[self.refreshControl endRefreshing]</code>：table 上收，Spinner 停止 spinning 并消失。</p>
<p> 有了这个 Spinner，你就可以在 reload 的时候给用户提示适当的状态了。</p>
<p> 这个 Spinner 是可以 <em><code>Control</code></em> + <em><code>Drag</code></em> 出 target-action 的。如果用户 pull down table，那么这个 action 就会触发！这样，你就可以在 action 中让 Spinner start spinning，然后去更新 table。</p>
<p> <img src="/img/Study_iOS_UITableView/11.13.UITableView.png" alt="UITableView"></p>
<p> <img src="/img/Study_iOS_UITableView/11.14.UITableView.png" alt="UITableView"></p>
<p> <strong>注意</strong>，用户 pull down 触发的是 Spinner 的 target-action，而不是触发 beginRefreshing。你需要在 action 中调用 beginRefreshing。</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：UITableView">Developing Applications for iOS 观后感系列：UITableView</h3><p><em>相关视频章节：11</em></p>
<hr>
<h4 id="UITableView_分类">UITableView 分类</h4><p>按内容分：</p>
<ul>
<li><p><em><code>dynamic</code></em>：在 storyboard 中设定 prototype，在代码中 load 内容。<em>（本篇主要涉及 dynamic NSTableView）</em></p>
</li>
<li><p><em><code>static</code></em>：完全在 storyboard 中设定。</p>
</li>
</ul>
<p>按样式分：</p>
<p><em><code>ungrouped</code></em> / <em><code>grouped</code></em></p>
<p>示例：</p>
<p><img src="/img/Study_iOS_UITableView/11.0.UITableView.png" alt="UITableView"></p>
<h4 id="UITableView_的构成">UITableView 的构成</h4><p>与 Mac 上的NSTableView 不同，iOS 中的 UITableView 都是一维的，只有一列。</p>
<p><img src="/img/Study_iOS_UITableView/11.1.UITableView.png" alt="UITableView"> <img src="/img/Study_iOS_UITableView/11.2.UITableView.png" alt="UITableView"></p>]]>
    
    </summary>
    
      <category term="UI" scheme="http://hi.zongquan.wang/tags/UI/"/>
    
      <category term="iOS" scheme="http://hi.zongquan.wang/tags/iOS/"/>
    
      <category term="开发" scheme="http://hi.zongquan.wang/categories/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Study iOS - UIScrollView]]></title>
    <link href="http://hi.zongquan.wang/2015/01/11/Study_iOS_UIScrollView/"/>
    <id>http://hi.zongquan.wang/2015/01/11/Study_iOS_UIScrollView/</id>
    <published>2015-01-11T05:46:10.000Z</published>
    <updated>2015-11-10T02:03:41.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：UIScrollView">Developing Applications for iOS 观后感系列：UIScrollView</h3><p><em>相关视频章节：10</em></p>
<hr>
<p><strong><code>UIScrollView</code></strong> 是 iOS 中很基础很重要的一种 UIView，用于呈现远大于 app window 大小的 content area，用户通过 <em><code>swiping</code></em> 手势可以在 content area 中进行 scroll，通过 <em><code>pinching</code></em> 手势可以进行 content 的 zoom。就像是拿着一个放大镜在四处移动着观察一副很大的地图。</p>
<p>UIScrollView 也是很多其它重要 UIView 的 super class，例如 <a href="../../../../2015/01/11/Study_iOS_UITableView/"><em><code>UITableView</code></em></a>、<em><code>UICollectionView</code></em>、<a href="../../../../2015/01/11/Study_iOS_Common_UI/"><em><code>UITextView</code></em></a> 等等。</p>
<h4 id="创建_UIScrollView">创建 UIScrollView</h4><p>通过 Storyboard 或者代码中通过 alloc initWithFrame。</p>
<a id="more"></a>
<h4 id="使用_UIScrollView">使用 UIScrollView</h4><ul>
<li>向 UIScrollView 的 content area 中添加一个 subview1：</li>
</ul>
<p><img src="/img/Study_iOS_UIScrollView/10.3.UIScrollView.png" alt="UIScrollView"></p>
<ul>
<li><p>再向 UIScrollView 的 content area 中添加一个很大的 subview2：</p>
<p>  <img src="/img/Study_iOS_UIScrollView/10.4.UIScrollView.png" alt="UIScrollView"></p>
<p>  <strong>注意</strong>，千万不要忘记设置 UIScrollView 的 <em><code>contentSize</code></em> property！它指定了 UIScrollView 的 content area 的大小，也就是 UIScrollView 可以游走的范围。所有添加到 UIScrollView 中的 subviews 的 frame 都是位于 UIScrollView 的 content area 坐标系中，即：原点为 (0,0)，size 为 contentSize。</p>
<p>  通常，contentSize 的设定需要考虑 content area 里面容纳的 subviews 的大小。</p>
</li>
<li><p><strong>当前 visible area</strong></p>
<p>  <img src="/img/Study_iOS_UIScrollView/10.6.UIScrollView.png" alt="UIScrollView"></p>
</li>
<li><p><strong>当前 visible area 在 content area 坐标系中的位置</strong></p>
<p>  <img src="/img/Study_iOS_UIScrollView/10.5.UIScrollView.png" alt="UIScrollView"></p>
</li>
<li><p><strong>当前 visible area 在原 subview 坐标系中的大小</strong></p>
<p>  <img src="/img/Study_iOS_UIScrollView/10.7.UIScrollView.png" alt="UIScrollView"></p>
</li>
<li><p><strong>Zoom</strong></p>
<p>  所有 UIView 都有一个 property：<em><code>CGAffineTransform transform</code></em>，包含 <em><code>translate</code></em>，<em><code>scale</code></em>，<em><code>rotate</code></em>。而 UIScrollView 实现 Zoom 的原理就是改变 subview 的 transform 的值。</p>
<p>  <strong>注意</strong>，Zoom 时也会影响 <em><code>contentSize</code></em> 和 <em><code>contentOffset</code></em> 的值。</p>
<p>  <strong>想要支持 Zoom 效果，必须做到下面2点</strong>：</p>
<ol>
<li><p>设定 UIScrollView 的 <em><code>minimumZoomScale</code></em> 和 <em><code>maximumZoomScale</code></em>。不设定的话，默认都是 1.0，即不缩放。</p>
</li>
<li><p>实现 delegate 函数：<code>-(UIView *)viewForZoomingInScrollView:(UIScrollView *)sender;</code>，该函数用于指定你要缩放的是 UIScrollView 中的哪个 subview。</p>
<p>通常缩放都是伴随着 pinching 手势的发生而触发的，但你也可以在代码中手动触发缩放。主要是借助这2个 API：<code>-(void)setZoomScale: animated:</code> 和 <code>-(void)zoomToRect: animated:</code>。</p>
</li>
</ol>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：UIScrollView">Developing Applications for iOS 观后感系列：UIScrollView</h3><p><em>相关视频章节：10</em></p>
<hr>
<p><strong><code>UIScrollView</code></strong> 是 iOS 中很基础很重要的一种 UIView，用于呈现远大于 app window 大小的 content area，用户通过 <em><code>swiping</code></em> 手势可以在 content area 中进行 scroll，通过 <em><code>pinching</code></em> 手势可以进行 content 的 zoom。就像是拿着一个放大镜在四处移动着观察一副很大的地图。</p>
<p>UIScrollView 也是很多其它重要 UIView 的 super class，例如 <a href="../../../../2015/01/11/Study_iOS_UITableView/"><em><code>UITableView</code></em></a>、<em><code>UICollectionView</code></em>、<a href="../../../../2015/01/11/Study_iOS_Common_UI/"><em><code>UITextView</code></em></a> 等等。</p>
<h4 id="创建_UIScrollView">创建 UIScrollView</h4><p>通过 Storyboard 或者代码中通过 alloc initWithFrame。</p>]]>
    
    </summary>
    
      <category term="UI" scheme="http://hi.zongquan.wang/tags/UI/"/>
    
      <category term="iOS" scheme="http://hi.zongquan.wang/tags/iOS/"/>
    
      <category term="开发" scheme="http://hi.zongquan.wang/categories/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Study iOS - Segue]]></title>
    <link href="http://hi.zongquan.wang/2015/01/10/Study_iOS_Segue/"/>
    <id>http://hi.zongquan.wang/2015/01/10/Study_iOS_Segue/</id>
    <published>2015-01-10T15:01:35.000Z</published>
    <updated>2015-11-10T02:03:41.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：Segue">Developing Applications for iOS 观后感系列：Segue</h3><p><em>相关视频章节：6，15，16</em></p>
<hr>
<p><em><code>Segue</code></em>，中文为“继续”的意思，在 iOS 开发中，其 class 为 <em><code>UIStoryboardSegue</code></em>，用于 storyboard 中不同 UIViewController 之间的转场，即从一个 UIViewController scene 转场到另一个 UIViewController scene。你可以从一个 UIControl、UIBarItem、UIView、UIViewController 等等，向另一个 UIViewController 建立 Segue。</p>
<h3 id="如何创建_Segue">如何创建 Segue</h3><p>起点（UIControl、UIBarItem、UIView、UIViewController 等等）</p>
<p>⇩</p>
<p><em><code>Control</code></em> + <em><code>Drag</code></em></p>
<p>⇩</p>
<p>终点（UIViewController）</p>
<p>⇩</p>
<p>设置 Segue 的 Identifier</p>
<h3 id="Segue_如何执行">Segue 如何执行</h3><ol>
<li><p><strong>触发 Segue</strong>：假如你从 UIButton 建立了一个 Segue，那么 button 点击时，就会触发 Segue。但有时你也需要从代码中手动触发 Segue，此时就需要调用 UIViewController 的 API：<code>-(void)performSegueWithIdentifier:(NSString *)segueID sender:(id)sender</code>。</p>
</li>
<li><p><strong>询问 Segue 是否允许执行</strong>：实现这个 delegate：<code>-(BOOL)shouldPerformSegueWithIdentifier:(NSString *)identifier sender:(id)sender</code>，如果不实现，默认就是允许所有 Segue。</p>
</li>
<li><p><strong>准备 Segue</strong>：真正呈现 <em><code>destination UIViewController</code></em> 之前，你需要为该 Segue 作 preparation。也就是说，Segue 会给 <em><code>source UIViewController</code></em> 机会去准备好将要呈现的 destination UIViewController。可以理解成 destination UIViewController 的 init。这一 preparation 过程是通过实现如下 delegate 来完成的：</p>
<pre><code>-(<span class="typename">void</span>)<span class="string">prepareForSegue:</span>(UIStoryboardSegue *)segue <span class="string">sender:</span>(id)sender
{
    <span class="keyword">if</span> ([segue.identifier <span class="string">isEqualToString:</span>@<span class="string">"XXX"</span>]) {
        <span class="keyword">if</span> ([segue.destinationViewController <span class="string">isKindOfClass:</span>[XXXViewController <span class="class"><span class="keyword">class</span>]]) {</span>
            XXXViewController *xxxVC = (XXXViewController *)segue.destinationViewController;
            xxxVC.xxxProperty = XXX; <span class="comment">// setup xxxVC</span>
        }
    }
}
</code></pre><p> <strong>注意</strong>，要记住之前 <a href="../../../../2015/01/05/Study_iOS_MVC/">MVCs</a> 中提到的原则，这个 destination UIViewController 在 source UIViewController 的 MVC 中扮演着 View 的角色，不允许 destination UIViewController 向 source UIViewController 的直接通信，而是要使用 blind 的方式，如 delegate。</p>
<p> <strong>还要注意</strong>，几乎所有类型的 Segue 都是 init 一个 <strong>new</strong> destination UIViewController 给你，所以当你第二次 prepareForSegue 时，第一次 prepareForSegue 拿到的那个 destination UIViewController 已经不复存在了，你需要重新 setup。<strong>这里只有一个例外</strong>，就是后面要提到的 <em><code>Unwind Segue</code></em>，它返给你的 destination UIViewController 就是之前已经存在的 UIViewController，这显然是合理的。举个例子，aVC 通过普通 Segue 转场到 bVC（bVC 会被重新 init），bVC 又通过 Unwind Segue 转回到 aVC，此时，Unwind Segue 的 destination UIViewController 显然必须是之前已经存在的那个 aVC，而不应该去重新 init 一个。</p>
<p> <strong>更要注意</strong>，prepareForSegue 在执行的时候，destination UIViewController 中的 outlet 尚未 set，因为 prepareForSegue 做的事等价于帮助 destination UIViewController 去 init。而 outlet set 是在 init 之后，viewDidLoad 之前做的。参见 <a href="../../../../2015/01/05/Study_iOS_Life_Cycle/">Life Cycle</a>。</p>
</li>
<li><p><strong>系统为你呈现 destination UIViewController</strong></p>
</li>
</ol>
<a id="more"></a>
<h3 id="Segue_分类">Segue 分类</h3><ul>
<li><p><strong>Push Segue</strong>：一般用于 <em><code>UINavigationController</code></em> 中。感受一下 <em><code>UINavigationController</code></em>。</p>
<p>  <img src="/img/Study_iOS_Segue/6.0.UINavigationController.png" alt="UINavigationController"></p>
<p>  你可以从一个 Embedded MVC 向另一个 Embedded MVC 创建 Push Segue。</p>
<p>  每一个 Embedded MVC 都可以设定自己的 navigationItem.rightBarButtonItems 和 toolbarItems。</p>
<p>  每一个 Embedded MVC 中的 <em><code>Back Button</code></em> 都是 UINavigationController 自动添加的，显示的是上一个 Embedded MVC 的 Title，如果上一个没有设定 Title，就显示 “Back” 字样。</p>
<p>  <img src="/img/Study_iOS_Segue/6.1.UINavigationController.png" alt="UINavigationController"></p>
<p>  <strong>另外</strong>，一般都是通过 Segue 来呈现 destination UIViewController 的。但极少数情况下，你可能需要通过代码手动呈现，此时，你可以利用 UINavigationController 的 API <code>pushViewController:animated:</code>，那么要 push 的那个 UIViewController 如何获取呢？利用 UIStoryBoard 的 API <code>instantiateViewControllerWithIdentifier:</code>，传入参数是你在 Storyboard 中为该 UIViewController 设定的 Identifier。两者结合起来就是：</p>
<pre><code>-(<span class="keyword">IBAction</span>)pushViewControllerByMyself
{
    XXXViewController *xxxVC = [<span class="keyword">self</span><span class="variable">.storyboard</span> instantiateViewControllerWithIdentifier:<span class="string">@"XXX"</span>];
    xxxVC<span class="variable">.xxxProperty</span> = XXX;
    [<span class="keyword">self</span><span class="variable">.navigationController</span> pushViewController:xxxVC animated:<span class="literal">YES</span>];
}
</code></pre></li>
<li><p><strong>Relationship Segue</strong>：一般用于 <em><code>UITabBarController</code></em> 中。感受一下 <em><code>UITabBarController</code></em> 。</p>
<p>  <img src="/img/Study_iOS_Segue/6.6.UITabBarController.png" alt="UITabBarController"></p>
<p>  <img src="/img/Study_iOS_Segue/6.7.UITabBarController.png" alt="UITabBarController"></p>
<p>  <img src="/img/Study_iOS_Segue/6.8.UITabBarController.png" alt="UITabBarController"></p>
</li>
<li><p><strong>Embedded Segue</strong>：一般用于 <em><code>Container View</code></em> 中。Container View 的作用是，将一个 VC 的 self.view show 到另一个 VC 的 view 中。感受一下 <em><code>Container View</code></em> 。</p>
<p>  <img src="/img/Study_iOS_Segue/15.0.EmbedSegue.png" alt="Container View"></p>
<p>  创建 Embedded Segue 的方式同 Push Segue 一样，通过 <em>Control</em> + <em>Drag</em> 的方式，从 Container View 拖向 destination UIViewController，此时只有一种 Segue 可以选择，那就是 Embedded Segue。</p>
<p>  <strong>注意</strong>，这个 Embedded Segue 是在外层 UIViewController 呈现的时候自动触发的（<em>触发的具体时间点有待进一步研究</em>），你同样是需要去 prepareForSegue，不要忘了，此时 destination UIViewController 的 outlet 尚未 set。</p>
</li>
<li><p><strong>Modal Segue</strong>：一般用于呈现 <em><code>Modal View Controller</code></em>。</p>
<p>  创建 Modal Segue 的方式同 Push Segue 一样，通过 <em>Control</em> + <em>Drag</em> 的方式，从某个 UIButton（举例来说）拖向 destination UIViewController，选择 Modal 即可。当 Segue 触发时，就会以 Modal 的形式呈现 destination UIViewController。同样，你需要去 prepareForSegue。通过设定 destination UIViewController 的属性 modalTransitionStyle，可以让它以不同的动画形式呈现出来。</p>
<p>  当然，你也可以通过代码手动地以 Modal 的形式呈现 destination UIViewController，调用 <code>presentViewContainer:animated:completion:</code> 即可，这里的 completion block 会在 destination UIViewController viewDidAppear 后被调用。</p>
</li>
<li><p><strong>Unwind Segue</strong>：一般用于从 <em><code>Modal View Controller</code></em> 返回到它的 presenter。通过 Unwind Segue，你也只能是返回到自己的 presenter。Unwind Segue 也可以用在 <em><code>UINavigationController</code></em> 机制中。</p>
<p>  正如之前提到的，使用 Unwind Segue 在 prepareForSegue 时，它返给你的 destination UIViewController 就是之前已经存在的 presenter UIViewController，不会去重新 init 一个 new UIViewController。</p>
<p>  <strong>那么创建 Unwind Segue 都需要做些什么呢？</strong></p>
<p>  举例来说，aVC 通过 Modal Segue 的形式呈现出 bVC，现在 bVC 要通过 Unwind Segue 的形式返回到 aVC。那么要创建这个 Unwind Segue 需要2步操作：</p>
<ol>
<li><p>在 aVC 的代码中，实现一个如下这样原型的函数：</p>
<pre><code>-(<span class="keyword">IBAction</span>)handleUnwindSegue:(<span class="built_in">UIStoryboardSegue</span> *)segue
{
    XXXViewController *bVC = (XXXViewController *)segue<span class="variable">.sourceViewController</span>; <span class="comment">// source, not destination. bVC Unwind Segue to aVC, so bVC is source.</span>
    <span class="comment">// get what you want from bVC</span>
}
</code></pre></li>
<li><p>在 bVC 的 scene 中，通过 <em>Control</em> + <em>Drag</em> 拖向下面这个 icon：</p>
<p> <img src="/img/Study_iOS_Segue/16.2.UnwindSegue.png" alt="Unwind Segue"></p>
<p> 然后 Xcode 就会列出 aVC 中所有你实现的那种原型的函数，选择其中匹配的那个 handleUnwindSegue:，并给该 Unwind Segue 设定 Identifier，这样就创建了 bVC 到 aVC 的一个 Unwind Segue。</p>
<p>handleUnwindSegue: 会在 aVC 呈现后被调用，此时，bVC 会自动 dismiss。别忘了在 bVC 的代码中还是需要去 prepareForSegue 的，为这个 Unwind Segue 做 preparation，通常就是准备好供 aVC 在 handleUnwindSegue: 中访问的东西。</p>
<p><strong>另外</strong>，这里再多提一些关于 Modal View 的东西。前面讲到了，在 aVC 通过 Unwind Segue 被呈现出来的时候，bVC 会自动 dismiss。那么如果不借助 Unwind Segue，如何在代码中手动让其 dismiss 呢。可以利用 <code>dismissViewControllerAnimated:completion:</code> 来完成。<strong>注意</strong>，这个消息不是发给 bVC 自己的，而是发给 aVC 的！查看文档就会明白，aVC 调用这个函数后，会 dismiss 掉它 present 出来的 Modal View Controller。所以，在 bVC 的代码中，你通常是这么使用该函数：</p>
<pre><code>[self.presentingViewController <span class="string">dismissViewControllerAnimated:</span>YES <span class="string">completion:</span>XXX];
</code></pre><p>在 bVC 中通过 self.presentingViewController 拿到 aVC。</p>
<p>手动 dismiss 一般是用于 bVC 什么也不做就返回到 aVC，这样就不需要通过 Unwind Segue 向 aVC 返回数据。</p>
</li>
</ol>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：Segue">Developing Applications for iOS 观后感系列：Segue</h3><p><em>相关视频章节：6，15，16</em></p>
<hr>
<p><em><code>Segue</code></em>，中文为“继续”的意思，在 iOS 开发中，其 class 为 <em><code>UIStoryboardSegue</code></em>，用于 storyboard 中不同 UIViewController 之间的转场，即从一个 UIViewController scene 转场到另一个 UIViewController scene。你可以从一个 UIControl、UIBarItem、UIView、UIViewController 等等，向另一个 UIViewController 建立 Segue。</p>
<h3 id="如何创建_Segue">如何创建 Segue</h3><p>起点（UIControl、UIBarItem、UIView、UIViewController 等等）</p>
<p>⇩</p>
<p><em><code>Control</code></em> + <em><code>Drag</code></em></p>
<p>⇩</p>
<p>终点（UIViewController）</p>
<p>⇩</p>
<p>设置 Segue 的 Identifier</p>
<h3 id="Segue_如何执行">Segue 如何执行</h3><ol>
<li><p><strong>触发 Segue</strong>：假如你从 UIButton 建立了一个 Segue，那么 button 点击时，就会触发 Segue。但有时你也需要从代码中手动触发 Segue，此时就需要调用 UIViewController 的 API：<code>-(void)performSegueWithIdentifier:(NSString *)segueID sender:(id)sender</code>。</p>
</li>
<li><p><strong>询问 Segue 是否允许执行</strong>：实现这个 delegate：<code>-(BOOL)shouldPerformSegueWithIdentifier:(NSString *)identifier sender:(id)sender</code>，如果不实现，默认就是允许所有 Segue。</p>
</li>
<li><p><strong>准备 Segue</strong>：真正呈现 <em><code>destination UIViewController</code></em> 之前，你需要为该 Segue 作 preparation。也就是说，Segue 会给 <em><code>source UIViewController</code></em> 机会去准备好将要呈现的 destination UIViewController。可以理解成 destination UIViewController 的 init。这一 preparation 过程是通过实现如下 delegate 来完成的：</p>
<pre><code>-(<span class="typename">void</span>)<span class="string">prepareForSegue:</span>(UIStoryboardSegue *)segue <span class="string">sender:</span>(id)sender
{
    <span class="keyword">if</span> ([segue.identifier <span class="string">isEqualToString:</span>@<span class="string">"XXX"</span>]) {
        <span class="keyword">if</span> ([segue.destinationViewController <span class="string">isKindOfClass:</span>[XXXViewController <span class="class"><span class="keyword">class</span>]]) {</span>
            XXXViewController *xxxVC = (XXXViewController *)segue.destinationViewController;
            xxxVC.xxxProperty = XXX; <span class="comment">// setup xxxVC</span>
        }
    }
}
</code></pre><p> <strong>注意</strong>，要记住之前 <a href="../../../../2015/01/05/Study_iOS_MVC/">MVCs</a> 中提到的原则，这个 destination UIViewController 在 source UIViewController 的 MVC 中扮演着 View 的角色，不允许 destination UIViewController 向 source UIViewController 的直接通信，而是要使用 blind 的方式，如 delegate。</p>
<p> <strong>还要注意</strong>，几乎所有类型的 Segue 都是 init 一个 <strong>new</strong> destination UIViewController 给你，所以当你第二次 prepareForSegue 时，第一次 prepareForSegue 拿到的那个 destination UIViewController 已经不复存在了，你需要重新 setup。<strong>这里只有一个例外</strong>，就是后面要提到的 <em><code>Unwind Segue</code></em>，它返给你的 destination UIViewController 就是之前已经存在的 UIViewController，这显然是合理的。举个例子，aVC 通过普通 Segue 转场到 bVC（bVC 会被重新 init），bVC 又通过 Unwind Segue 转回到 aVC，此时，Unwind Segue 的 destination UIViewController 显然必须是之前已经存在的那个 aVC，而不应该去重新 init 一个。</p>
<p> <strong>更要注意</strong>，prepareForSegue 在执行的时候，destination UIViewController 中的 outlet 尚未 set，因为 prepareForSegue 做的事等价于帮助 destination UIViewController 去 init。而 outlet set 是在 init 之后，viewDidLoad 之前做的。参见 <a href="../../../../2015/01/05/Study_iOS_Life_Cycle/">Life Cycle</a>。</p>
</li>
<li><p><strong>系统为你呈现 destination UIViewController</strong></p>
</li>
</ol>]]>
    
    </summary>
    
      <category term="UI" scheme="http://hi.zongquan.wang/tags/UI/"/>
    
      <category term="iOS" scheme="http://hi.zongquan.wang/tags/iOS/"/>
    
      <category term="开发" scheme="http://hi.zongquan.wang/categories/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Study iOS - Network]]></title>
    <link href="http://hi.zongquan.wang/2015/01/07/Study_iOS_Network/"/>
    <id>http://hi.zongquan.wang/2015/01/07/Study_iOS_Network/</id>
    <published>2015-01-07T02:15:27.000Z</published>
    <updated>2015-11-10T02:03:41.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：Network">Developing Applications for iOS 观后感系列：Network</h3><p><em>相关视频章节：10</em></p>
<hr>
<p>iOS 中处理 Network 的 API 主要是 <em><code>NSURLSession</code></em>，当然，基于此，<em>Mattt Thompson</em> 开发了一套更加强大易用的 <em>AFNetworking</em>。不管怎样，还是很有必要了解一下 iOS 自己的 <em>NSURLSession</em> 的。</p>
<h4 id="NSURLSession_的一般使用流程："><em>NSURLSession</em> 的一般使用流程：</h4><pre><code><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:XXX];
<span class="built_in">NSURLSessionConfiguration</span> *configuration = XXX;
<span class="built_in">NSURLSession</span> *session = XXX; <span class="comment">// use configuration</span>
<span class="built_in">NSURLSessionXXXTask</span> *task = [session XXXTaskWithRequest:request]; <span class="comment">// downloadTask, uploadTask, dataTask, ...</span>
[task resume];
</code></pre><p>基本上就是上面这几步。当然，如果使用 <em><code>NSURLSessionDelegate</code></em> 的话，还需要实现这些 delegate；如果不使用 delegate，也可以选择使用 <em><code>completionHandler</code></em> 这种 block 的方式。具体选择哪种，取决于 <em>NSURLSessionXXXTask</em> 是如何创建的，下面会详细提到。</p>
<p>下面分别理解一下这些具体步骤：</p>
<ol>
<li><p><strong><code>NSURLRequest</code></strong>：比较简单，不多说了。</p>
</li>
<li><p><strong><code>NSURLSessionConfiguration</code></strong>：这个 configuration 控制着后面创建的 session 的若干属性。通常比较关注这3个 API：</p>
<ul>
<li><p><code>+(NSURLSessionConfiguration *)defaultSessionConfiguration</code>：创建一个 default session，会使用 cache，cookie 机制。</p>
</li>
<li><p><code>+(NSURLSessionConfiguration *) ephemeralSessionConfiguration</code>：创建一个 ephemeral session，不使用 cache，cookie 机制，所有东西都在内存中，除了下载文件时才会真正地有写入 disk 的动作。</p>
</li>
<li><p><code>+(NSURLSessionConfiguration *) backgroundSessionConfigurationWithIdentifier:(NSString *)identifier</code>：创建一个 background session，可以让 session 在 app 处于 background 时能够继续 run。</p>
<p>  这种 session 会把控制权交给系统，正如之前一篇笔记（<a href="../../../../2015/01/05/Study_iOS_Life_Cycle/"><em><code>Life Cycle</code></em></a>）中讲到的那样，有个 <code>UIApplicationDelegate</code> 是专门配合这种 session 使用的，即 <code>(void)application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)())completionHandler</code>，系统首先通过这个 delegate 响应 network events 后，才会再把控制权交给你的 <em><code>NSURLSessionDelegate</code></em>。</p>
<p>  <strong>注意</strong>，这种 session 比前面2种多了一个 <code>identifier</code>，有了它，当 app 被系统 terminate 和 relaunch 后，系统会使用同一个 identifier 重建 background session，继续之前未完成的 network transfer。但是，这里仅限于 app 是被系统 terminate 和 relaunch，如果是用户手动退出 app，则不会去重建 session。</p>
</li>
</ul>
</li>
</ol>
<a id="more"></a>
<ol>
<li><p><strong><code>NSURLSession</code></strong>：有了 configuration，就可以创建 session 了。session 的 init 方式决定了 network events 的 handle 方式，以及 handle 操作的执行环境是哪里。主要有2种 init 方式：</p>
<ul>
<li><p><code>+(NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration delegate:(id&lt;NSURLSessionDelegate&gt;)delegate delegateQueue:(NSOperationQueue *)queue</code>：</p>
<p>  <strong>delegate</strong> 若不为 nil，就意味着你实现了自己的 <em><code>NSURLSessionDelegate</code></em> 来 handle network events。若为 nil，就意味着该 session 只接受 <em><code>completionHandler</code></em> 这种 handle 操作。</p>
<p>  <strong>queue</strong> 用于指定 handle 操作（不管是 NSURLSessionDelegate 还是 completionHandler）是在什么 NSOperationQueue 上执行的。可以传递 [NSOperationQueue mainQueue]；也可以传递 <strong>[[NSOperationQueue alloc] init]（根据文档，这样 init 出来的 NSOperationQueue 总是并行执行其中的 operation 的</strong>）；还可以传递 <strong>nil，此时，session 会自动创建一个串行 queue（非 mainQueue）</strong>来执行所有的 NSURLSessionDelegate 或者 completionHandler。</p>
</li>
<li><p><code>+(NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration</code>：前一种的简化版，只接受 <em><code>completionHandler</code></em> 这种 handle 操作，同时，<strong>session 会自动创建一个串行的 NSOperationQueue（非 mainQueue）来执行 completionHandler</strong>。</p>
<p><strong>注意</strong>，session 的 delegate 和 delegateQueue 属性是只读的，无法事后修改。</p>
</li>
</ul>
</li>
<li><p><strong><code>NSURLSessionXXXTask</code></strong>：这里不提具体的各种 task 是什么样的，只关注下 session 创建 task 的方式。主要有2类：</p>
<ul>
<li><p><code>XXXTaskWithRequest:completionHandler:</code>：指定 completionHandler 来 handle network events。你可以指定它为 NULL，但前提是在之前创建 session 时已经指定好了 NSURLSessionDelegate，这样就会通过 delegate 来 handle，否则，既没有 completionHandler 又没有 delegate，你就无法 handle 了。</p>
</li>
<li><p><code>XXXTaskWithRequest:</code>    ：只通过 NSURLSessionDelegate 来 handle。</p>
<p><strong>注意</strong>，XXXTask 本身执行时并不在 mainQueue 上，所以不必担心，你所关注的只是 NSURLSessionDelegate 或者 completionHandler 是在哪个 queue 上执行。</p>
</li>
</ul>
</li>
<li><p><strong>不要忘了 <code>[task resume];</code></strong></p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：Network">Developing Applications for iOS 观后感系列：Network</h3><p><em>相关视频章节：10</em></p>
<hr>
<p>iOS 中处理 Network 的 API 主要是 <em><code>NSURLSession</code></em>，当然，基于此，<em>Mattt Thompson</em> 开发了一套更加强大易用的 <em>AFNetworking</em>。不管怎样，还是很有必要了解一下 iOS 自己的 <em>NSURLSession</em> 的。</p>
<h4 id="NSURLSession_的一般使用流程："><em>NSURLSession</em> 的一般使用流程：</h4><pre><code><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:XXX];
<span class="built_in">NSURLSessionConfiguration</span> *configuration = XXX;
<span class="built_in">NSURLSession</span> *session = XXX; <span class="comment">// use configuration</span>
<span class="built_in">NSURLSessionXXXTask</span> *task = [session XXXTaskWithRequest:request]; <span class="comment">// downloadTask, uploadTask, dataTask, ...</span>
[task resume];
</code></pre><p>基本上就是上面这几步。当然，如果使用 <em><code>NSURLSessionDelegate</code></em> 的话，还需要实现这些 delegate；如果不使用 delegate，也可以选择使用 <em><code>completionHandler</code></em> 这种 block 的方式。具体选择哪种，取决于 <em>NSURLSessionXXXTask</em> 是如何创建的，下面会详细提到。</p>
<p>下面分别理解一下这些具体步骤：</p>
<ol>
<li><p><strong><code>NSURLRequest</code></strong>：比较简单，不多说了。</p>
</li>
<li><p><strong><code>NSURLSessionConfiguration</code></strong>：这个 configuration 控制着后面创建的 session 的若干属性。通常比较关注这3个 API：</p>
<ul>
<li><p><code>+(NSURLSessionConfiguration *)defaultSessionConfiguration</code>：创建一个 default session，会使用 cache，cookie 机制。</p>
</li>
<li><p><code>+(NSURLSessionConfiguration *) ephemeralSessionConfiguration</code>：创建一个 ephemeral session，不使用 cache，cookie 机制，所有东西都在内存中，除了下载文件时才会真正地有写入 disk 的动作。</p>
</li>
<li><p><code>+(NSURLSessionConfiguration *) backgroundSessionConfigurationWithIdentifier:(NSString *)identifier</code>：创建一个 background session，可以让 session 在 app 处于 background 时能够继续 run。</p>
<p>  这种 session 会把控制权交给系统，正如之前一篇笔记（<a href="../../../../2015/01/05/Study_iOS_Life_Cycle/"><em><code>Life Cycle</code></em></a>）中讲到的那样，有个 <code>UIApplicationDelegate</code> 是专门配合这种 session 使用的，即 <code>(void)application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)())completionHandler</code>，系统首先通过这个 delegate 响应 network events 后，才会再把控制权交给你的 <em><code>NSURLSessionDelegate</code></em>。</p>
<p>  <strong>注意</strong>，这种 session 比前面2种多了一个 <code>identifier</code>，有了它，当 app 被系统 terminate 和 relaunch 后，系统会使用同一个 identifier 重建 background session，继续之前未完成的 network transfer。但是，这里仅限于 app 是被系统 terminate 和 relaunch，如果是用户手动退出 app，则不会去重建 session。</p>
</li>
</ul>
</li>
</ol>]]>
    
    </summary>
    
      <category term="Network" scheme="http://hi.zongquan.wang/tags/Network/"/>
    
      <category term="iOS" scheme="http://hi.zongquan.wang/tags/iOS/"/>
    
      <category term="开发" scheme="http://hi.zongquan.wang/categories/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Study iOS - UIView Animation]]></title>
    <link href="http://hi.zongquan.wang/2015/01/06/Study_iOS_Animation/"/>
    <id>http://hi.zongquan.wang/2015/01/06/Study_iOS_Animation/</id>
    <published>2015-01-06T14:29:21.000Z</published>
    <updated>2015-11-10T02:03:41.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：UIView_Animation">Developing Applications for iOS 观后感系列：UIView Animation</h3><p><em>相关视频章节：8</em></p>
<hr>
<p>本篇提到的 Animation 主要是基于 UIView 的，并没有涉及到基于 Layer 机制的 Animation。</p>
<p>基于 UIView 的 Animation 有以下3种：</p>
<h3 id="Animation_of_UIView_Property">Animation of UIView Property</h3><p><strong>首先一定要明确一点</strong>：animation 虽然是经历一定时间 show 在屏幕上的，但对 property 的值的修改却是早就已经立即生效了。</p>
<p>UIView 的某些 property 的改变是可以施加 animation 的，例如：</p>
<pre><code>frame
transform（translation，rotation，<span class="built_in">scale</span>）
<span class="built_in">alpha</span>（opacity）
</code></pre><p>实现这一类 animation 的 API 是 UIView 的 <code>class method</code>：</p>
<pre><code>+(<span class="keyword">void</span>)animateWithDuration:(<span class="built_in">NSTimeInterval</span>)duration
                     delay:(<span class="built_in">NSTimeInterval</span>)delay
                   options:(<span class="built_in">NSViewAnimationOptions</span>)options
                animations:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))animationsBlock
                completion:(<span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> finished))completionBlock
</code></pre><p><code>animationsBlock</code> 里面执行你对 UIView property 所做的修改。</p>
<p><code>completionBlock</code> 表示 animation 呈现结束后要做的事，如果 animation 成功地呈现完毕，finished 为 YES，否则，若中断了，则返回 NO。</p>
<p><strong>注意</strong>：animation 是在该 API 返回后开始的，而该 API 返回的时刻是 <code>animationsBlock</code> 执行完毕的时刻。<strong>也就是说</strong>，调用该 API 后，会立刻执行其 <code>animationsBlock</code>，执行完后就立刻返回，然后 animation 开始呈现。所以对 UIView property 的修改在 <code>animationsBlock</code> 执行完后就立即生效了，只不过 property 的变化要经过 duration 才呈现完毕。</p>
<p><strong>另外</strong>：finished 何时为 NO？如果在该 animation 开始后，又调用了该 API 对相同的 property 开始了另一个 animation，这样前一个 animation 没做完就得中断去做另一个 animation 了，这种情况下，前一个 animation 的 completionBlock 的 finished 就为 NO 了。</p>
<a id="more"></a>
<h3 id="Animation_of_Entire_UIView">Animation of Entire UIView</h3><p>例如整个 UIView 的 flipping、dissolving、curling 等效果，在呈现这些效果的同时，你可以对整个 UIView 进行任意修改，改变其 appearance。</p>
<p>实现这一类 animation 的 API 是 UIView 的 <code>class method</code>：</p>
<pre><code>+(<span class="keyword">void</span>)transitionWithView:(<span class="built_in">UIView</span> *)viewToModify
                 duration:(<span class="built_in">NSTimeInterval</span>)duration
                  options:(<span class="built_in">NSViewAnimationOptions</span>)options
               animations:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))animationsBlock
               completion:(<span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> finished))completionBlock
</code></pre><p><code>animationsBlock</code> 和 <code>completionBlock</code> 的机制同前面一种 animation 一样，只不过你不再是只单单地修改 UIView 的某个 property，你可以对整个 UIView 做任意的修改（例如重新绘制整个 UIView 等）。</p>
<p><code>options</code> 可以指定 animation 采用的效果：flipping、dissolving、curling 等。</p>
<p>如果不是想对同一个 UIView 进行 animation 修改，而是要转为呈现另一个 UIView，则需要使用这个 API：</p>
<pre><code>+(<span class="keyword">void</span>)transitionFromView:(<span class="built_in">UIView</span> *)fromView
                   toView:(<span class="built_in">UIView</span> *)toView
                 duration:(<span class="built_in">NSTimeInterval</span>)duration
                  options:(<span class="built_in">NSViewAnimationOptions</span>)options
               completion:(<span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> finished))completionBlock
</code></pre><p>此时已经不再需要 <code>animationsBlock</code> 了，因为要呈现的 animation 就是从 fromView 变为 toView。</p>
<p><code>optioins</code> 可以指定：你是想 hide fromView 而呈现 toView，还是想 remove fromView 而重新 add toView。</p>
<h3 id="Dynamic_Animator">Dynamic Animator</h3><p>这一类 animation 是指 <em><code>animatable objects</code></em>（通常就是 UIView）的 <em><code>physics animation</code></em>。将某些 physics 效果施加到 animatable objects 上，这些 objects 就会受到 physics 的影响自行开始动画效果，直到在 physics 的作用下 resolve to stasis（相对静止状态）。</p>
<p>Steps：</p>
<ol>
<li><p>创建 <code>UIDynamicAnimator</code>，并指定其 <code>delegate</code>。</p>
<pre><code>UIDynamicAnimator *animator = [[UIDynamicAnimator alloc] initWithReferenceView:aView]<span class="comment">;</span>
animator.delegate = aDelegate<span class="comment">;</span>
</code></pre><p> 设定 delegate 是为了响应 UIDynamicAnimatorDelegate 的2个函数：</p>
<p> <code>-(void)dynamicAnimatorDidPause:(UIDynamicAnimator *)animator</code>：resolve to stasis 导致动画暂停</p>
<p> <code>-(void)dynamicAnimatorWillResume:(UIDynamicAnimator *)animator</code>：动画重新开始</p>
</li>
<li><p>向 UIDynamicAnimator 中添加各种 physics 效果，即 <code>UIDynamicBehavior</code>（gravity，collisions 等等）。</p>
<p> UIDynamicBehavior 有很多子类，例如创建一个 gravity 作用效果：</p>
<pre><code>UIGravityBehavior *gravity = <span class="comment">[<span class="comment">[UIGravityBehavior alloc]</span> init]</span>;
<span class="comment">[animator addBehavior:gravity]</span>;
</code></pre><ul>
<li><p>有一个比较特殊的 UIDynamicBehavior，即 <code>UIDynamicItemBehavior</code>，它的各个 property 用于指定 objects 的一些固有 physic 属性，例如：allowsRotation，friction，elasticity，density 等。这些属性会间接影响到其他 UIDynamicBehavior 的作用效果。</p>
</li>
<li><p>你也可以 subclass UIDynamicBehavior，进行自定义。可以利用它的函数 <code>addChildBehavior:(UIDynamicBehavior *)behavior</code> 将若干个 UIDynamicBehavior 组合成一种新的 UIDynamicBehavior。通常你还需要 override 它的 <code>init</code>，<code>addItem</code>，<code>removeItem</code>。</p>
</li>
<li><p>UIDynamicBehavior 有一个 property 用于访问自己所在的 UIDynamicAnimator：<code>dynamicAnimator</code>。</p>
</li>
<li><p>UIDynamicBehavior 还有一个重要的 property：<code>@property (copy) void (^action)(void)</code>，每当 UIDynamicBehavior 在 objects 上生效时，该 block 都会被调用。所以，这里的操作最好不要太费时，因为它会被频繁地调用。</p>
</li>
</ul>
</li>
<li><p>将 <code>UIDynamicItem</code>（animatable objects，通常就是 UIView）添加到某些 UIDynamicBehavior 下。</p>
<p> UIDynamicItem 是一个 protocol，指定3个 property：bounds，center，transform。而 UIView 实现了该 protocol。</p>
<pre><code><span class="keyword">id</span> &lt;<span class="built_in">UIDynamicItem</span>&gt; item = XXX <span class="comment">// 例如某个 UIView</span>
[gravity addItem:item];
</code></pre></li>
<li><p>一旦完成 step 3，UIDynamicItem 就会自动在 UIDynamicBehavior 的作用下开始运动。</p>
<p> <strong>注意</strong>，如果你在 UIDynamicAnimator 的作用下，手动修改了 UIDynamicItem 的属性，那么必须调用 UIDynamicAnimator 的函数 <code>updateItemUsingCurrentState:item</code> 来让 UIDynamicAnimator 重新获取其属性，这样作用在 item 上的 UIDynamicBehavior 才能根据当前的最新状态继续产生作用力。</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：UIView_Animation">Developing Applications for iOS 观后感系列：UIView Animation</h3><p><em>相关视频章节：8</em></p>
<hr>
<p>本篇提到的 Animation 主要是基于 UIView 的，并没有涉及到基于 Layer 机制的 Animation。</p>
<p>基于 UIView 的 Animation 有以下3种：</p>
<h3 id="Animation_of_UIView_Property">Animation of UIView Property</h3><p><strong>首先一定要明确一点</strong>：animation 虽然是经历一定时间 show 在屏幕上的，但对 property 的值的修改却是早就已经立即生效了。</p>
<p>UIView 的某些 property 的改变是可以施加 animation 的，例如：</p>
<pre><code>frame
transform（translation，rotation，<span class="built_in">scale</span>）
<span class="built_in">alpha</span>（opacity）
</code></pre><p>实现这一类 animation 的 API 是 UIView 的 <code>class method</code>：</p>
<pre><code>+(<span class="keyword">void</span>)animateWithDuration:(<span class="built_in">NSTimeInterval</span>)duration
                     delay:(<span class="built_in">NSTimeInterval</span>)delay
                   options:(<span class="built_in">NSViewAnimationOptions</span>)options
                animations:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))animationsBlock
                completion:(<span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> finished))completionBlock
</code></pre><p><code>animationsBlock</code> 里面执行你对 UIView property 所做的修改。</p>
<p><code>completionBlock</code> 表示 animation 呈现结束后要做的事，如果 animation 成功地呈现完毕，finished 为 YES，否则，若中断了，则返回 NO。</p>
<p><strong>注意</strong>：animation 是在该 API 返回后开始的，而该 API 返回的时刻是 <code>animationsBlock</code> 执行完毕的时刻。<strong>也就是说</strong>，调用该 API 后，会立刻执行其 <code>animationsBlock</code>，执行完后就立刻返回，然后 animation 开始呈现。所以对 UIView property 的修改在 <code>animationsBlock</code> 执行完后就立即生效了，只不过 property 的变化要经过 duration 才呈现完毕。</p>
<p><strong>另外</strong>：finished 何时为 NO？如果在该 animation 开始后，又调用了该 API 对相同的 property 开始了另一个 animation，这样前一个 animation 没做完就得中断去做另一个 animation 了，这种情况下，前一个 animation 的 completionBlock 的 finished 就为 NO 了。</p>]]>
    
    </summary>
    
      <category term="Animation" scheme="http://hi.zongquan.wang/tags/Animation/"/>
    
      <category term="iOS" scheme="http://hi.zongquan.wang/tags/iOS/"/>
    
      <category term="开发" scheme="http://hi.zongquan.wang/categories/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Study iOS - UIView]]></title>
    <link href="http://hi.zongquan.wang/2015/01/06/Study_iOS_UIView/"/>
    <id>http://hi.zongquan.wang/2015/01/06/Study_iOS_UIView/</id>
    <published>2015-01-06T13:23:11.000Z</published>
    <updated>2015-11-10T02:03:41.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：UIView">Developing Applications for iOS 观后感系列：UIView</h3><p><em>相关视频章节：7</em></p>
<hr>
<h3 id="UIView_的_init">UIView 的 init</h3><p>与 UIViewController 的 init 类似，UIView 的 init 也有2种形式：一种是从 storyboard 中释放出来，另一种是在代码中直接调用相关的 init 函数。两种只会选择一种来完成 init。</p>
<ol>
<li><p><strong>来自 storyboard：</strong> <em><code>awakeFromNib</code></em></p>
<p> awakeFromNib 是 NSObject 的函数，颤抖吧。</p>
</li>
<li><p><strong>来自 code：</strong> <em><code>initWithFrame:(CGRect)rect</code></em></p>
</li>
</ol>
<p>因为有这2种 init 方式，所以，如果希望在 init 阶段做一些 setup，那么这2个地方都要执行 setup。因为从 storyboard 释放出来的 init 方式只会调用 awakeFromNib，不会调用 initWithFrame:；同样，code 中调用 initWithFrame: 进行的 init 方式也不会再调用 awakeFromNib。</p>
<h3 id="Coordinate">Coordinate</h3><p><img src="/img/Study_iOS_UIView/7.1.Coordinate.png" alt="Coordinate"></p>
<p><img src="/img/Study_iOS_UIView/7.2.Coordinate.png" alt="Coordinate"></p>
<a id="more"></a>
<h3 id="Draw">Draw</h3><p>基于 CPU 进行绘制时，靠的是 <em><code>drawRect:</code></em> 这个函数。如何实现自己的 <em><code>drawRect:</code></em> 呢？两种方式：</p>
<ul>
<li><p><strong>Core Graphics （C API）</strong></p>
<ol>
<li><p>获取 draw 操作所在的 <em><code>context</code></em>。<strong>注意</strong>，每次调用 <em><code>drawRect:</code></em> 时，iOS 都会重新给你提供一个新的 context，只有这个最新的对本次 <em><code>drawRect:</code></em> 才是有效的，因此不要去 cache 之前的某个 context 来复用，因为它对本次的 <em><code>drawRect:</code></em> 是无效的。</p>
<p> context 决定了 <em><code>drawRect:</code></em> 操作发生在哪里（Screen，Offscreen，PDF，Printer 等）。通过在 <em><code>drawRect:</code></em> 中调用 <em><code>UIGraphicsGetCurrentContext()</code></em> 来获取当前 CGContextRef。</p>
</li>
<li><p>创建 path</p>
</li>
<li><p>设置 color、font、width 等等属性</p>
</li>
<li><p>调用 stroke 或者 fill 进行绘制</p>
</li>
</ol>
</li>
<li><p><strong>UIBezierPath（Cocoa API）</strong></p>
<p>  利用 UIBezierPath 会得到一个 object，然后直接通过该 object 来 stroke 或者 fill。UIBezierPath 是不需要设置 context 的，它会自动地在当前 context 下进行绘制。</p>
<p>  可以利用 UIBezierPath 来 clip 你的后续绘制操作：</p>
<pre><code>UIBezierPath *roundedRect = [UIBezierPath bezierPathWithRoundedRec<span class="variable">t:rect</span> cornerRadiu<span class="variable">s:radius</span>];
[roundedRect addClip]; // this would clip <span class="keyword">all</span> drawing <span class="keyword">to</span> <span class="keyword">be</span> inside the roundedRect
</code></pre></li>
</ul>
<p>基于 GPU 的 draw 用的是另一套机制：Layer。本篇未涉及。</p>
<h3 id="Redraw">Redraw</h3><p><img src="/img/Study_iOS_UIView/7.6.Redraw.png" alt="Redraw"></p>
<h3 id="UIGestureRecognizer">UIGestureRecognizer</h3><p>两种添加方式：</p>
<ol>
<li><p><code>code 中添加</code></p>
<p> <img src="/img/Study_iOS_UIView/7.7.UIGestureRecognizer.png" alt="UIGestureRecognizer"></p>
<p> <img src="/img/Study_iOS_UIView/7.8.UIGestureRecognizer.png" alt="UIGestureRecognizer"></p>
<p> <img src="/img/Study_iOS_UIView/7.9.UIGestureRecognizer.png" alt="UIGestureRecognizer"></p>
</li>
<li><p><code>storyboard 中拖放 UIGestureRecognizer 控件，并设置 target-action。</code></p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：UIView">Developing Applications for iOS 观后感系列：UIView</h3><p><em>相关视频章节：7</em></p>
<hr>
<h3 id="UIView_的_init">UIView 的 init</h3><p>与 UIViewController 的 init 类似，UIView 的 init 也有2种形式：一种是从 storyboard 中释放出来，另一种是在代码中直接调用相关的 init 函数。两种只会选择一种来完成 init。</p>
<ol>
<li><p><strong>来自 storyboard：</strong> <em><code>awakeFromNib</code></em></p>
<p> awakeFromNib 是 NSObject 的函数，颤抖吧。</p>
</li>
<li><p><strong>来自 code：</strong> <em><code>initWithFrame:(CGRect)rect</code></em></p>
</li>
</ol>
<p>因为有这2种 init 方式，所以，如果希望在 init 阶段做一些 setup，那么这2个地方都要执行 setup。因为从 storyboard 释放出来的 init 方式只会调用 awakeFromNib，不会调用 initWithFrame:；同样，code 中调用 initWithFrame: 进行的 init 方式也不会再调用 awakeFromNib。</p>
<h3 id="Coordinate">Coordinate</h3><p><img src="/img/Study_iOS_UIView/7.1.Coordinate.png" alt="Coordinate"></p>
<p><img src="/img/Study_iOS_UIView/7.2.Coordinate.png" alt="Coordinate"></p>]]>
    
    </summary>
    
      <category term="UI" scheme="http://hi.zongquan.wang/tags/UI/"/>
    
      <category term="iOS" scheme="http://hi.zongquan.wang/tags/iOS/"/>
    
      <category term="开发" scheme="http://hi.zongquan.wang/categories/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Study iOS - Misc]]></title>
    <link href="http://hi.zongquan.wang/2015/01/05/Study_iOS_Misc/"/>
    <id>http://hi.zongquan.wang/2015/01/05/Study_iOS_Misc/</id>
    <published>2015-01-05T14:34:11.000Z</published>
    <updated>2015-11-10T02:03:41.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：Misc">Developing Applications for iOS 观后感系列：Misc</h3><p><em>相关视频章节：all</em></p>
<hr>
<h4 id="NSObject">NSObject</h4><ul>
<li><p><code>(NSString *)description</code>：当你自己实现一个 myClass 时，如果实现了 <code>(NSString *)description</code> 这个函数，那么你就可以利用 <code>NSLog(@&quot;%@&quot;, myClassInstance)</code> 来输出 description 的内容了，这里的 <em><code>%@</code></em> 会被替换成 <code>[myClassInstance description]</code>。</p>
</li>
<li><p><code>(id)copy</code>：得到 object 的 unmutable 版，不管 object 本身是不是 mutable 的。</p>
</li>
<li><p><code>(id)mutableCopy</code>：得到 object 的 mutable 版，不管 object 本身是不是 mutable 的。</p>
<p>  <strong>注意</strong>，并不是所有的 class 都实现了 copy 和 mutableCopy 机制，如果没有实现，而你调用了，就会抛出异常。另外，这2种 copy 操作效率很高，所以不要有所担心。</p>
</li>
</ul>
<h4 id="UIFont">UIFont</h4><ul>
<li><p>给文本内容（content）设定字体的最佳方式：<code>UIFont *font = [UIFont preferredFontForTextStyle:UIFontTextStyleXXX]</code></p>
</li>
<li><p>给控件（例如 button 的 title）设定字体的最佳方式：<code>UIFont *font = [UIFont systemFontOfSize:(CGFloat)pointSize]</code></p>
<p>  <strong>注意</strong>，preferredFontForTextStyle: 也可以用于设定控件字体，但反过来 systemFontOfSize: 却不能用于设定 content 字体。</p>
</li>
</ul>
<a id="more"></a>
<h4 id="NSNotification">NSNotification</h4><ul>
<li><p>对于向 NSNotificationCenter 注册过的 observer，如果不再需要 listen 某个 notification，必须要调用 <code>removeObserver:</code>，因为 NSNotificationCenter 对 observer 的引用方式是 <em><code>unsafe retained</code></em>，所以，如果 observer 变为 nil 了，NSNotificationCenter 会出现引用异常，造成 crash。</p>
<p>  常见的调用 removeObserver: 的地方是 <em><code>viewWillDisappear</code></em> 或者 <em><code>dealloc</code></em>。</p>
</li>
</ul>
<h4 id="Category">Category</h4><ul>
<li><p>添加 Category 无需事先得到 class 的 .m 文件，即无需知道 class 的原始实现。</p>
</li>
<li><p><code>Category 不能添加 instance 变量，只能添加 property 和 function。</code>而 property 本质上也是 function，既然不能添加 instance 变量，<em><code>那也意味着，@synthesize 也是不允许的。</code></em>总结起来就是，Category 中添加的 property 和 function 只能对原有的 instance 变量进行操作。Extension 可以添加 instance 变量。</p>
</li>
</ul>
<h4 id="Network_Activity_Indicator">Network Activity Indicator</h4><ul>
<li>UIApplication 有个属性：<em><code>BOOL networkActivityIndicatorVisible</code></em>，将其设为 YES，status bar 上就会出现表示网络活动的 spinner，设为 NO，spinner 就会消失。使用时需要注意，当多个线程操作该 networkActivityIndicatorVisible 时，需要给它加个<strong>计数的机制</strong>，防止错误地开关该属性。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：Misc">Developing Applications for iOS 观后感系列：Misc</h3><p><em>相关视频章节：all</em></p>
<hr>
<h4 id="NSObject">NSObject</h4><ul>
<li><p><code>(NSString *)description</code>：当你自己实现一个 myClass 时，如果实现了 <code>(NSString *)description</code> 这个函数，那么你就可以利用 <code>NSLog(@&quot;%@&quot;, myClassInstance)</code> 来输出 description 的内容了，这里的 <em><code>%@</code></em> 会被替换成 <code>[myClassInstance description]</code>。</p>
</li>
<li><p><code>(id)copy</code>：得到 object 的 unmutable 版，不管 object 本身是不是 mutable 的。</p>
</li>
<li><p><code>(id)mutableCopy</code>：得到 object 的 mutable 版，不管 object 本身是不是 mutable 的。</p>
<p>  <strong>注意</strong>，并不是所有的 class 都实现了 copy 和 mutableCopy 机制，如果没有实现，而你调用了，就会抛出异常。另外，这2种 copy 操作效率很高，所以不要有所担心。</p>
</li>
</ul>
<h4 id="UIFont">UIFont</h4><ul>
<li><p>给文本内容（content）设定字体的最佳方式：<code>UIFont *font = [UIFont preferredFontForTextStyle:UIFontTextStyleXXX]</code></p>
</li>
<li><p>给控件（例如 button 的 title）设定字体的最佳方式：<code>UIFont *font = [UIFont systemFontOfSize:(CGFloat)pointSize]</code></p>
<p>  <strong>注意</strong>，preferredFontForTextStyle: 也可以用于设定控件字体，但反过来 systemFontOfSize: 却不能用于设定 content 字体。</p>
</li>
</ul>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://hi.zongquan.wang/tags/iOS/"/>
    
      <category term="开发" scheme="http://hi.zongquan.wang/categories/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Study iOS - Life Cycle]]></title>
    <link href="http://hi.zongquan.wang/2015/01/05/Study_iOS_Life_Cycle/"/>
    <id>http://hi.zongquan.wang/2015/01/05/Study_iOS_Life_Cycle/</id>
    <published>2015-01-05T12:38:32.000Z</published>
    <updated>2015-11-10T02:03:41.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：Life_Cycle">Developing Applications for iOS 观后感系列：Life Cycle</h3><p><em>相关视频章节：5，17</em></p>
<hr>
<p>这里提到的 Life Cycle 主要包括2方面：</p>
<ul>
<li><p>Application 的 Life Cycle</p>
</li>
<li><p>UIViewController 的 Life Cycle</p>
</li>
</ul>
<h3 id="Application_的_Life_Cycle">Application 的 Life Cycle</h3><p>Application 的 Life Cycle 是靠一些 <em><code>UIApplicationDelegate</code></em> 函数来控制的。</p>
<p>新建一个 iOS 项目的时候，在 Xcode 生成的 AppDelegate.m 中，已经列出了常用的几个 delegate 函数：</p>
<ul>
<li><p><code>(BOOL)application:(UIApplication *)application willFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code>：app 即将完成启动。诸如响应 openURL 这样的事情，需要在这里做，在 app 彻底启动完毕之前，从 launchOptions 中拿到 URL。</p>
</li>
<li><p><code>(BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code>：app 彻底启动完毕。这里一般做 app 的初始化操作。</p>
</li>
<li><p><code>(void)applicationDidBecomeActive:(UIApplication *)application</code>：app 变得 active，也就是说，app 的 UI 可以接收 events 了。这通常是发生在 app 启动后出现 UI 的时候，或者从其它 app 切换而来的时候。伴随该 delegate 有一个 notification <em><code>UIApplicationDidBecomeActiveNotification</code></em>。</p>
</li>
<li><p><code>(void)applicationWillResignActive:(UIApplication *)application</code>：app 变得 not active，也就是说，app 的 UI 无法接收 events 了。这通常是发生在切换到其它 app 的时候，或者双击 Home 的时候，或者接听电话的时候。总之就是，该 app 的 UI 已经不再是 iOS 的 first responder UI 了。伴随该 delegate 有一个 notification <em><code>UIApplicationWillResignActiveNotification</code></em>。</p>
<p>  通常利用以上2个 delegate，来暂停并保存当前 UI 状态，然后在之后重新恢复 UI 状态。</p>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p><code>(void)applicationDidEnterBackground:(UIApplication *)application</code>：app 进入 background。<strong>注意</strong>，当发生 applicationWillResignActive 后，并不一定会发生 applicationDidEnterBackground，例如，运行该 app 时突然双击 Home 或者接听电话，此时，只会发生applicationWillResignActive。只有等到该 app 进入 background 后，例如已经切换到其它 app 后，才会发生 applicationDidEnterBackground。<strong>此外</strong>，iOS 留给该 delegate 的运行时间很短，如果想在这里做些费时的操作，可以借助 <em><code>beginBackgroundTaskWithExpirationHandler:</code></em>。伴随该 delegate 有一个 notification <em><code>UIApplicationDidEnterBackgroundNotification</code></em>。</p>
</li>
<li><p><code>(void)applicationWillEnterForeground:(UIApplication *)application</code>：app 即将重新回到 foreground。通常做些 undo applicationDidEnterBackground 的操作。applicationWillEnterForeground 发生之后，很快就会发生 applicationDidBecomeActive。<strong>但注意</strong>，app 启动的时候，并没有 applicationWillEnterForeground，而是直接 applicationDidBecomeActive。所以要理解前面提到的“重新”二字，app 启动时并不是重新，只有发生 applicationDidEnterBackground 后，才对应地有“重新”的意思。伴随该 delegate 有一个 notification <em><code>UIApplicationWillEnterForegroundNotification</code></em>。</p>
</li>
<li><p><code>(void)application:(UIApplication *)application performFetchWithCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler</code>：如果 app 开启了 fetch background mode，那么当 iOS 给你机会去做 fetch 时，就会调用该 delegate。在这里你可以做任何操作，并不限于 download fetch。但这里只有30s时间，30s内你必须处理完，然后调用 completionHandler。通常的做法是，首先开线程异步去做该做的操作，然后就立即调用 completionHandler。</p>
<p>  <strong>注意</strong>，如果 iOS 给你机会在这里做 network fetch，那么你应该在这里发起一个普通的 <em><code>ephemeral configuration 类型的 NSURLSession</code></em>，而不是发起 background configuration 类型的 NSURLSession。因为background configuration 类型的 NSURLSession 是 discretionary 的，当 app 已经处于 background 时，这种 NSURLSession 可能会被 iOS 拒绝执行，而这显然不是我们想要的，我们既然已经在 background 了，那么 iOS 给机会执行该函数时，我们想要的是发起一个有效的 NSURLSession，保证它会被执行。当在这里发起 ephemeral configuration 类型的 NSURLSession 后，我们就需要在 NSURLSession 的 completion delegate 中调用 <em><code>completionHandler:UIBackgroundFetchResultNewData</code></em> 来更新 app 的 UI snapshot。</p>
</li>
<li><p><code>(void)application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)())completionHandler</code>：如果之前发起了一个 background configuration 类型的 NSURLSession，那么当 NSURLSession task 完成后，就会调用该 delegate。<strong>注意</strong>，如果发起 background configuration 类型的 NSURLSession，那么必须要实现该 delegate，在其中尽早地调用 completionHandler，只有这样，app 才能调用你之前为 NSURLSession 设定的那些 NSURLSessionDelegate，诸如 didReceiveResponse 等等；否则，那些 NSURLSessionDelegate 不会被调用。</p>
</li>
<li><p><code>LocalNotification / RemoteNotification 系列</code>：处理诸如闹钟（local）、Apple Push Service（remote）这样的 Notification。</p>
</li>
<li><p><code>State Restoration 系列</code>：用于保存并恢复 app 的 UI，即使退出 app 后 再重启，也可以恢复到之前的状态。</p>
</li>
<li><p><code>Data Protection 系列</code>：锁屏后，将文件保护起来。</p>
</li>
</ul>
<p>最后图示一下：</p>
<p><img src="/img/Study_iOS_Life_Cycle/17.0.ApplicationLifeCycle.png" alt="ApplicationLifeCycle"></p>
<h3 id="UIViewController_的_Life_Cycle">UIViewController 的 Life Cycle</h3><p>UIViewController 的 Life Cycle 主要靠一些类似于 delegate 的函数来控制的。</p>
<p>按照执行时间顺序列举几个常用的函数：</p>
<ul>
<li><p><code>init</code>：UIViewController 的初始化有2种，一种是从 storyboard 中释放出来，另一种是在代码中直接调用相关的 init 函数。两种只会选择一种来完成 init。</p>
<ol>
<li><p><strong>来自 storyboard：</strong><code>awakeFromNib</code></p>
<p> 当 app 启动时，所有从 storyboard 释放出来的 object 都会调用该函数，包括其中的 UIViewController（通过在 storyboard 中设置其 class）！<strong>注意</strong>，该函数执行时，outlet 还尚未设置好，因此无法访问。</p>
</li>
<li><p><strong>来自 code：</strong><code>initWithNibName:(NSString *)name bundle:(NSBundle *)bundle</code></p>
<p>因为有这2种 init 方式，所以，如果希望在 init 阶段做一些 setup，那么这2个地方都要执行 setup。因为从 storyboard 释放出来的 init 方式只会调用 awakeFromNib，不会调用 initWithNibName；同样，code 中调用 initWithNibName: 进行的 init 方式也不会再调用 awakeFromNib。</p>
<p>通常在该 init 阶段能做的事很有限，因为 outlet 尚未设置好。所有直接访问 outlet 的操作都无法进行。</p>
</li>
</ol>
</li>
<li><p><code>iOS 设置 outlet</code></p>
</li>
<li><p><code>viewDidLoad</code>：app 运行到这里时，outlet 已经设置好，所以是进行 setup 操作的绝佳之地！但要<strong>注意</strong>：</p>
<ol>
<li>这里总是需要调用一下 <em><code>[super viewDidLoad]</code></em>。</li>
<li>此时 view 的 geometry 尚未设置好，也就是说像 <em><code>bounds 和 frame</code></em> 这些属性是还没有确定的，不能在这里访问，所以不要做些与 geometry 相关的操作。</li>
<li>viewDidLoad 只会调用一次，即在释放之前，view 只会 load 一次。</li>
</ol>
</li>
<li><p><code>iOS 确定 geometry</code></p>
</li>
<li><p><code>viewWillLayoutSubviews: / viewDidLayoutSubviews:</code>：geometry 确定好后，就可以进行 view 的布局了。这通常都是由 AutoLayout 自动完成的，准确的说，<strong>AutoLayout 动作就是发生在 will 与 did 之间</strong>。每当 view 的 frame 发生改变时，就会调用这组函数，这样该 view 的 subviews 就能够重新进行布局了。例如屏幕发生 autorotation 时，就会调用它们。你可以在这里重新设置 subviews 的 frame 或其它 geometry 相关的属性，然后让 AutoLayout 来完成布局。当然，你也可以不管这组函数，只是让 AutoLayout 来做事就行了。</p>
<pre><code>顺便提一下，如果想让 ViewController 响应手机的 rotation，必须同时满足以下<span class="number">3</span>个条件：
    shouldAutorotate 要返回 YES
    supportedInterfaceOrientations 要返回相应的 orientation
    Info<span class="class">.plist</span> 中要设置允许相应的 orientation
</code></pre></li>
<li><p><code>viewWillAppear: / viewDidAppear:</code>：Layout 完成后，就可以让 view 现身了。不像 viewDidLoad，这组函数是可以随着 view 的 visible 状态改变而执行多次的，正如其函数名称表示的意思。</p>
</li>
<li><p><code>在 view visible 期间，每当 geometry 改变就会调用viewWill/DidLayoutSubviews:这组函数。</code></p>
</li>
<li><p><code>viewWillDisappear: / viewDidDisappear:</code>这组函数也会随着 view 的 visible 状态改变而执行多次。</p>
<p>  <strong>注意</strong>，在 viewWill/DidXXX 这4个函数里面总是需要调用 super 的对应函数。在 viewWillXXX 这2个函数里面不要做太费时的操作，因为时间有限，will 这个状态马上就会过去的。</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：Life_Cycle">Developing Applications for iOS 观后感系列：Life Cycle</h3><p><em>相关视频章节：5，17</em></p>
<hr>
<p>这里提到的 Life Cycle 主要包括2方面：</p>
<ul>
<li><p>Application 的 Life Cycle</p>
</li>
<li><p>UIViewController 的 Life Cycle</p>
</li>
</ul>
<h3 id="Application_的_Life_Cycle">Application 的 Life Cycle</h3><p>Application 的 Life Cycle 是靠一些 <em><code>UIApplicationDelegate</code></em> 函数来控制的。</p>
<p>新建一个 iOS 项目的时候，在 Xcode 生成的 AppDelegate.m 中，已经列出了常用的几个 delegate 函数：</p>
<ul>
<li><p><code>(BOOL)application:(UIApplication *)application willFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code>：app 即将完成启动。诸如响应 openURL 这样的事情，需要在这里做，在 app 彻底启动完毕之前，从 launchOptions 中拿到 URL。</p>
</li>
<li><p><code>(BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code>：app 彻底启动完毕。这里一般做 app 的初始化操作。</p>
</li>
<li><p><code>(void)applicationDidBecomeActive:(UIApplication *)application</code>：app 变得 active，也就是说，app 的 UI 可以接收 events 了。这通常是发生在 app 启动后出现 UI 的时候，或者从其它 app 切换而来的时候。伴随该 delegate 有一个 notification <em><code>UIApplicationDidBecomeActiveNotification</code></em>。</p>
</li>
<li><p><code>(void)applicationWillResignActive:(UIApplication *)application</code>：app 变得 not active，也就是说，app 的 UI 无法接收 events 了。这通常是发生在切换到其它 app 的时候，或者双击 Home 的时候，或者接听电话的时候。总之就是，该 app 的 UI 已经不再是 iOS 的 first responder UI 了。伴随该 delegate 有一个 notification <em><code>UIApplicationWillResignActiveNotification</code></em>。</p>
<p>  通常利用以上2个 delegate，来暂停并保存当前 UI 状态，然后在之后重新恢复 UI 状态。</p>
</li>
</ul>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://hi.zongquan.wang/tags/iOS/"/>
    
      <category term="开发" scheme="http://hi.zongquan.wang/categories/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Study iOS - MVC]]></title>
    <link href="http://hi.zongquan.wang/2015/01/05/Study_iOS_MVC/"/>
    <id>http://hi.zongquan.wang/2015/01/05/Study_iOS_MVC/</id>
    <published>2015-01-05T11:38:55.000Z</published>
    <updated>2015-11-10T02:03:41.000Z</updated>
    <content type="html"><![CDATA[<p>iOS学习起步阶段，抽空看完了 Stanford 老头的 Developing Applications for iOS 系列视频，挺不错的，浅显易懂。打算把“观后感”做成笔记，挑些重要的点，理一理，省得以后还要重新看整个教程的文档。</p>
<h3 id="Developing_Applications_for_iOS_观后感系列：MVC_设计模式">Developing Applications for iOS 观后感系列：MVC 设计模式</h3><p><em>相关视频章节：1</em></p>
<hr>
<p>先上图！</p>
<p><img src="/img/Study_iOS_MVC/1.0.MVC.png" alt="MVC"></p>
<p>这幅图描述的是单一的 <strong><code>MVC</code></strong> 模式。普通的 iOS 开发就靠这个 MVC 模式走遍天下了。（有牛人开创了个 <a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">ReactiveCocoa 模式</a>）</p>
<h4 id="理解一下_MVC_模式：">理解一下 MVC 模式：</h4><ol>
<li>V 和 M 永远也不能在一起，无法做直接通信。C -&gt; M 存在单向的直接通信。C -&gt; V 存在单向的直接通信。也就是说，C 永远是老大，它负责吩咐 V 和 M 办事，而且不受 V 和 M 的直接影响。</li>
<li>通过将 V 设置成 C 的 <em><code>outlet</code></em> <em>(Control Drag)</em>，可以实现 C 对 V 的直接通信，即 C -&gt; V。而 V –&gt; C 的间接通信方式包括2种：<em><code>target-action</code></em> 以及 <em><code>delegate（data source 也可以理解成 delegate）</code></em>。</li>
<li>C -&gt; M 是理所当然的。而 M –&gt; C 的间接通信是通过 <em><code>Notification &amp; KVO</code></em> 实现的。</li>
</ol>
<p>基于单个的 MVC，我们可以构建复杂的多 MVC。</p>
<p><img src="/img/Study_iOS_MVC/1.1.MVCs.png" alt="MVCs"></p>
<p><strong>但不管多复杂，总是坚持这个原则</strong>：一个 MVC 是作为另一个 MVC 的 V 部分而存在的，也就是说，父 MVC 中的 C 控制的是子 MVC 中的 C，而不是直接去干预子 MVC 中的 V。当然，多个 MVC 是可以共享同一个 M 的，毕竟 Notification 是广播性质的，可以有多个 Observer。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>iOS学习起步阶段，抽空看完了 Stanford 老头的 Developing Applications for iOS 系列视频，挺不错的，浅显易懂。打算把“观后感”做成笔记，挑些重要的点，理一理，省得以后还要重新看整个教程的文档。</p>
<h3 id="Develop]]>
    </summary>
    
      <category term="iOS" scheme="http://hi.zongquan.wang/tags/iOS/"/>
    
      <category term="开发" scheme="http://hi.zongquan.wang/categories/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Just a little tips about Objective-C Block]]></title>
    <link href="http://hi.zongquan.wang/2014/12/03/Just_a_little_tips_about_Block/"/>
    <id>http://hi.zongquan.wang/2014/12/03/Just_a_little_tips_about_Block/</id>
    <published>2014-12-03T09:35:36.000Z</published>
    <updated>2015-11-10T02:03:41.000Z</updated>
    <content type="html"><![CDATA[<p>大爱 <em><code>Block</code></em>，方便易用，但是，有些坑还是需要认真对待的~~</p>
<p>其实问题主要是关于内存管理的。</p>
<h4 id="1-_捕获闭包的状态">1. 捕获闭包的状态</h4><p>一切问题的起源：<em><code>Block</code></em> 除了包含一段可执行代码，更重要的是，它还会捕获（<em><code>capture</code></em>）其闭包内的状态。</p>
<p>例（1）：</p>
<pre><code>- (<span class="keyword">void</span>)testMethod {
    <span class="keyword">int</span> a = <span class="number">1</span>;
    <span class="keyword">void</span> (^testBlock)(<span class="keyword">void</span>) = ^{
        NSLog(@<span class="string">"Integer is: %i"</span>, a);
    };
    a = <span class="number">2</span>;
    testBlock(); <span class="comment">// output is still 1.</span>
}
</code></pre><p>在定义 testBlock 时，它会捕获 a 的<strong>类型、值以及修饰符</strong>。但是，捕获只意味着对 a 做了一次<strong>快照</strong>，而并不是真正地拥有 a。也就是说，在定义 testBlock 的时候，外界 a 的值是多少，它捕获进来的值就是多少。外界对 a 值的修改不会影响到 testBlock，同样 testBlock 内部对 a 值的修改也不会影响到外界。</p>
<p><strong>注意</strong>：</p>
<ul>
<li><p>捕获闭包的状态是发生在 <em><code>Block</code></em> 定义的时候！而不是 <em><code>Block</code></em> 真正 run 的时候！</p>
</li>
<li><p>捕获的是<strong>类型 + 值 + 修饰符</strong>，而不单单是值！</p>
</li>
<li><p>对于标量来说，因为 <em><code>Block</code></em> 只是捕获了该变量的值，当然是无法对其进行有效地修改。而对于对象指针来说，捕获进来的是指针的值，无法修改指针的值表示不能让该指针指向另一个对象，但这不影响 <em><code>Block</code></em> 对该指针所指的对象进行操作。例如，如果例（1）中的 a 换成一个数组指针，在 <em><code>Block</code></em> 内部我们是可以做类似于 <code>[a addObject:]</code> 这种操作的，外界可以看到对指针所指对象的修改。前提是我们要在 <em><code>Block</code></em> 定义之前就要给 a 所指的对象分配好内存，即在外界 <code>NSMutableArray *a = [[NSMutableArray alloc] init]</code>，之后在 <em><code>Block</code></em> 内部就可以任意修改该对象了，而不是修改该对象的指针。</p>
</li>
</ul>
<a id="more"></a>
<h4 id="2-_如何让_Block_跟外界共享捕获的内容">2. 如何让 Block 跟外界共享捕获的内容</h4><p>前面提到，通常 <em><code>Block</code></em> 只是对变量做了一个快照，那么如何让 block 与外界共享该变量，从而能够修改其捕获的值呢？</p>
<p>全靠 <em><code>__block</code></em> 这个修饰符了！</p>
<p>如果一个变量在声明的时候指定了 <em><code>__block</code></em> 这个修饰符，那就意味着，所有在该变量的作用域内定义的 block，都能够共享该变量。</p>
<p>例（2）：</p>
<pre><code>- (<span class="keyword">void</span>)testMethod {
    __block <span class="keyword">int</span> a = <span class="number">1</span>;
    <span class="keyword">void</span> (^testBlock)(<span class="keyword">void</span>) = ^{
        NSLog(@<span class="string">"Integer is: %i"</span>, a);
    };
    a = <span class="number">2</span>;
    testBlock(); <span class="comment">// output is 2 now.</span>
}
</code></pre><p>虽然在 testBlock 定义的时候捕获到的值是1，但 a 是 <code>__block</code> 修饰的，在 testBlock run 之前，值被改成了2，所以 testBlock run 时能够共享到这一改变。同样，如果 testBlock 内部修改了 a 的值，外界也是会共享到的。</p>
<h4 id="3-_当_Block_被_copy_时会发生什么">3. 当 Block 被 copy 时会发生什么</h4><p>首先要明白2点，<em><code>Block</code></em> 什么时候会被 copy，被 copy 到哪里？</p>
<p>一般情况下，<em><code>Block</code></em> 是存储在 stack 中的，当其从 stack 弹出后就消失了。例如例（1），testBlock 是在 testMethod 的 stack 中创建的，自己 run 结束后就被销毁了。这种情况下，<em><code>Block</code></em> 不会对其捕获的变量的内存管理或者生命周期有影响。</p>
<p>但如果 <em><code>Block</code></em> 需要被保存下来，使其在定义结束后的其它作用域下 run，那么这种情况下，它可以被 copy 到 <em><code>heap</code></em> 中进行存储。这个时候，block 被当成了 object 来看待。</p>
<p>比较常见的一种情景，例（3）：</p>
<pre><code>- (<span class="literal">void</span>)configureBlock {
    <span class="built_in">self</span><span class="built_in">.</span>block = ^{
        <span class="preprocessor">[</span><span class="built_in">self</span> doSomething<span class="preprocessor">]</span><span class="markup">;
    };
}</span>
</code></pre><p>block 被存储到 self.block 中供以后调用，显然是被 copy 到了 heap 中。</p>
<p><strong>一旦 block 被 copy，那么问题就来了！</strong></p>
<p><em><code>Block</code></em> 会对捕获的 self 进行 <em><code>strong reference</code></em>，这极易造成 <em><code>strong reference cycle</code></em>。因为如果该 block 不释放，那么 self 就无法释放，而 block 的释放又需要 self 先被释放，deadlock！除非在 block 用完后，<code>self.block = nil</code>，先把 block 释放掉。</p>
<p>只要 block 被这样定义，不管它是否在 run，问题都会一直存在，因为捕获是发生在 block 定义的时候，那个时候它就被 copy 到 heap 中了！</p>
<h4 id="4-_weakSelf_和_strongSelf">4. weakSelf 和 strongSelf</h4><p>为了解决例（3）中可能的 strong reference cycle 问题，就引入了 <em><code>weakSelf</code></em>。</p>
<p>例（4）：</p>
<pre><code>__weak __typeof__<span class="list">(<span class="keyword">self</span>)</span> weakSelf = self<span class="comment">;</span>
dispatch_group_async<span class="list">(<span class="keyword">_operationsGroup</span>, _operationsQueue, ^ {
    [weakSelf doSomething]<span class="comment">;</span>
})</span><span class="comment">;</span>
</code></pre><p>weakSelf 发挥作用的关键在于，<em><code>Block</code></em> 捕获的是<strong>类型 + 值 + 修饰符</strong>，也就是说，它会捕获到 <code>__weak</code> 这个修饰符！这样 block 就不会对 self 进行 strong reference。</p>
<p>采用了 <code>__weak</code> 后，block 在定义的时候不会强引用 self，当 block 在真正 run 的时候，weakSelf 要么是 self，要么是 nil。之所以会为 nil，是因为此时 self 可能已经被释放了。</p>
<p>进一步，考虑例（5）：</p>
<pre><code>__weak __typeof__<span class="list">(<span class="keyword">self</span>)</span> weakSelf = self<span class="comment">;</span>
dispatch_group_async<span class="list">(<span class="keyword">_operationsGroup</span>, _operationsQueue, ^ {
    __typeof__<span class="list">(<span class="keyword">weakSelf</span>)</span> strongSelf = weakSelf<span class="comment">;</span>
    [strongSelf doSomething]<span class="comment">;</span>
    [strongSelf doSomethingElse]<span class="comment">;</span>
})</span><span class="comment">;</span>
</code></pre><p>又来了个 <em><code>strongSelf</code></em>！有什么用处？</p>
<p>是这样的，如果执行 doSomething 时，self 还在，而执行 doSomethingElse 时，self被释放了，这是不是有点不妥~~</p>
<p>所以 block 在 run 时，通过内部的 strongSelf 对 self 进行 strong reference，这样可以保证，如果 weakSelf 在 block 刚 run 时是 self，那么在整个 run 的期间也一直是 self，不会让 self 被释放而变成 nil。</p>
<p><strong>注意</strong>：这个 strongSelf 不会导致 strong reference cycle，因为它不是在 block 定义的时候被捕获进来的，它只是局部变量，只存在于 block run 的期间，当 block run 结束后，对 self 的 strong reference 就消失了。只有 weakSelf 才是在定义的时候被捕获进来的，而它又是 <code>__weak</code> 的。</p>
<p>关于 weakSelf 和 strongSelf，有2篇文章可以帮助理解：<a href="http://www.fantageek.com/1090/understanding-weak-self-and-strong-self/" target="_blank" rel="external">【1】</a> <a href="http://dhoerl.wordpress.com/2013/04/23/i-finally-figured-out-weakself-and-strongself/" target="_blank" rel="external">【2】</a></p>
<h4 id="5-_补充">5. 补充</h4><ul>
<li><p>dispatch_async 对 block 的处理：会将 block copy 到 heap 中，因为它是需要异步处理的，所以需要将 block 存储下来。</p>
</li>
<li><p>dispatch_sync 对 block 的处理：由于是同步处理的，所以 block 只存在于当前的 stack 中，run 完就释放了，不会被存储在 heap 中。</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>大爱 <em><code>Block</code></em>，方便易用，但是，有些坑还是需要认真对待的~~</p>
<p>其实问题主要是关于内存管理的。</p>
<h4 id="1-_捕获闭包的状态">1. 捕获闭包的状态</h4><p>一切问题的起源：<em><code>Block</code></em> 除了包含一段可执行代码，更重要的是，它还会捕获（<em><code>capture</code></em>）其闭包内的状态。</p>
<p>例（1）：</p>
<pre><code>- (<span class="keyword">void</span>)testMethod {
    <span class="keyword">int</span> a = <span class="number">1</span>;
    <span class="keyword">void</span> (^testBlock)(<span class="keyword">void</span>) = ^{
        NSLog(@<span class="string">"Integer is: %i"</span>, a);
    };
    a = <span class="number">2</span>;
    testBlock(); <span class="comment">// output is still 1.</span>
}
</code></pre><p>在定义 testBlock 时，它会捕获 a 的<strong>类型、值以及修饰符</strong>。但是，捕获只意味着对 a 做了一次<strong>快照</strong>，而并不是真正地拥有 a。也就是说，在定义 testBlock 的时候，外界 a 的值是多少，它捕获进来的值就是多少。外界对 a 值的修改不会影响到 testBlock，同样 testBlock 内部对 a 值的修改也不会影响到外界。</p>
<p><strong>注意</strong>：</p>
<ul>
<li><p>捕获闭包的状态是发生在 <em><code>Block</code></em> 定义的时候！而不是 <em><code>Block</code></em> 真正 run 的时候！</p>
</li>
<li><p>捕获的是<strong>类型 + 值 + 修饰符</strong>，而不单单是值！</p>
</li>
<li><p>对于标量来说，因为 <em><code>Block</code></em> 只是捕获了该变量的值，当然是无法对其进行有效地修改。而对于对象指针来说，捕获进来的是指针的值，无法修改指针的值表示不能让该指针指向另一个对象，但这不影响 <em><code>Block</code></em> 对该指针所指的对象进行操作。例如，如果例（1）中的 a 换成一个数组指针，在 <em><code>Block</code></em> 内部我们是可以做类似于 <code>[a addObject:]</code> 这种操作的，外界可以看到对指针所指对象的修改。前提是我们要在 <em><code>Block</code></em> 定义之前就要给 a 所指的对象分配好内存，即在外界 <code>NSMutableArray *a = [[NSMutableArray alloc] init]</code>，之后在 <em><code>Block</code></em> 内部就可以任意修改该对象了，而不是修改该对象的指针。</p>
</li>
</ul>]]>
    
    </summary>
    
      <category term="Block" scheme="http://hi.zongquan.wang/tags/Block/"/>
    
      <category term="Mac" scheme="http://hi.zongquan.wang/tags/Mac/"/>
    
      <category term="开发" scheme="http://hi.zongquan.wang/categories/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[XPC mechanism of Mac]]></title>
    <link href="http://hi.zongquan.wang/2014/11/28/XPC_mechanism_of_Mac/"/>
    <id>http://hi.zongquan.wang/2014/11/28/XPC_mechanism_of_Mac/</id>
    <published>2014-11-27T16:44:50.000Z</published>
    <updated>2015-11-10T02:03:41.000Z</updated>
    <content type="html"><![CDATA[<p>在 Mac 中，进程间的通信机制，除了 <em><code>NSDistributedNotification</code></em>、<em><code>Distributed Objects</code></em>，还有 XPC。XPC 可以在同一个 app 的不同 bundle 间使用，也可以在不同的 app 间使用。</p>
<p>XPC 机制是通过 <em><code>NSXPCConnection</code></em> 作为 channel 来通信的，每个 <em><code>NSXPCConnection</code></em> 有 <em>Client</em> 和 <em>Listener</em> 两个 endpoint。</p>
<h3 id="1-_XPC_角色">1. XPC 角色</h3><h4 id="Listener">Listener</h4><p>通过 <em><code>NSXPCListener</code></em> API 来创建 Listener，并指定该 Listener 的 <em><code>NSXPCListenerDelegate</code></em>，该 delegate 需要实现的函数是 <em><code>(BOOL)listener:shouldAcceptNewConnection:</code></em>。该 delegate 函数用于决定是否响应新的 connection，并设置该 connection 的 <em><code>exportedInterface</code></em> 和 <em><code>exportedObject</code></em>。</p>
<ul>
<li><p><em><code>exportedObject</code></em>：Listener 的导出对象，提供接口供 Client 访问。</p>
</li>
<li><p><em><code>exportedInterface</code></em>：列举出 <em><code>exportedObject</code></em> 能够导出哪些可用的接口供 Client 调用，函数原型通常是：<em>`(void)doTaskWithInfo:(NSDictionary </em>)info callback:(void(^)(NSDictionary <em>dic))callback`</em>。</p>
</li>
</ul>
<h4 id="Client">Client</h4><p>Client 通过 <em><code>NSXPCConnection</code></em> API 来创建一个新的 connection，并指定该 connection 的 <em><code>remoteObjectInterface</code></em>，它代表 Listener 端的 <em><code>exportedInterface</code></em>。然后就可以通过 <em><code>remoteObjectProxyWithErrorHandler:</code></em> 来获取 Listener 端的 <em><code>exportedObject</code></em>，调用其导出的接口。Listener 在执行自己的导出函数时，可以通过调用传递进来的 callback 向 Client 端 send back 数据。</p>
<h4 id="NSXPCConnection">NSXPCConnection</h4><p><em><code>NSXPCConnection</code></em> 的发起是单向的，只能由 Client 端到 Listener 端，因为每一个发起的 connection 必须要由 Listener 端通过 <em><code>NSXPCListenerDelegate</code></em> 函数来决定是否要进行响应。但 Client 和 Listener 都可以有自己的 <em><code>exportedObject</code></em> 和 <em><code>remoteObjectProxy</code></em>，在 connect 之后可以相互访问对方，一方的 <em><code>exportedObject</code></em> 对应另一方的 <em><code>remoteObjectProxy</code></em>。参见 Apple 文档中的图示。</p>
<p><strong>注意</strong>：不管是 Client 还是 Listener，设置自己的 <em><code>exportedObject</code></em> 和 <em><code>remoteObjectProxy</code></em> 必须要先于调用 <em><code>resume</code></em>。</p>
<a id="more"></a>
<h3 id="2-_XPC_搭建">2. XPC 搭建</h3><ul>
<li><p>同一个 app 中使用的 XPC 称为 XPC Service，在 Xcode 中可以创建 <em>XPC Service</em> 这种 target，生成的 bundle 是 .xpc。在主 app 中需要将 .xpc bundle deploy 到自己的 <em><code>Contents/XPCServices</code></em> 目录下，Mac 会在该目录中寻找相应的 .xpc bundle 去 load。</p>
<p>  <strong>Listener</strong>：在 <em>XPC Service</em> bundle 的代码中，需要使用 <em><code>[NSXPCListener serviceListener]</code></em> 来创建 Listener。执行 <em><code>resume</code></em> 之后永远不会 return。</p>
<p>  <strong>Client</strong>：在 Client 端，也就是主 app 中，需要使用 <em><code>[[NSXPCConnection alloc]
   initWithServiceName:]</code></em> 来创建 connection，为其传递 <em>XPC Service</em> 的 Bundle ID。</p>
<p>   <strong>注意</strong>：<em>XPC Service</em> 的启动或者退出完全由 OS 自己决定，你要做的就是启动主 app，并在代码中需要的地方请求 XPC connection。举个例子，.xpc bundle 可能是在主 app 发起 XPC 请求时才被 load 和启动 XPC Service，而不是早在之前就去启动。此外，<em><code>Contents/XPCServices</code></em> 目录下的 .xpc bundle 只能由所属的主 app 调用，其它 app 无法调用。</p>
<p>   <strong>e.g.</strong></p>
<pre><code>Apple Demo <span class="keyword">*</span><span class="string">"SandboxingAndNSXPCConnection"</span><span class="keyword">*</span>

Apple Demo <span class="keyword">*</span><span class="string">"AppSandboxLoginItemXPCDemo"</span><span class="keyword">*</span>
</code></pre></li>
<li><p>不同 app 间的 XPC 不是通过创建 .xpc bundle 来实现的，因为前面这种方式创建的 .xpc bundle 只能被自己所属的 app 调用。而是通过创建普通的 target 来充当 XPC 的Listener。</p>
<p>  <strong>Listener</strong>：在 Listener app 中，需要使用 <em><code>[[NSXPCListener alloc] initWithMachServiceName:]</code></em> 来创建 Listener，为其传递自行设定的 XPC service name。执行 <em><code>resume</code></em> 之后会立即 return，所以需要自行启动 Runloop。</p>
<p>  <strong>Client</strong>：在 Client app 中，需要使用 <em><code>[[NSXPCConnection alloc] initWithMachServiceName:options:]</code></em> 来创建 connection，为其传递 Listener 中指定的 XPC service name。option 用于说明你的 XPC service 是否是在 admin 权限下。</p>
<p>  <strong>e.g.</strong> <a href="https://github.com/wzqcongcong/SMJobBlessXPC" target="_blank" rel="external">SMJobBlessXPC</a> | <a href="https://github.com/wzqcongcong/MyDiskCleaner" target="_blank" rel="external">MyDiskCleaner</a> | <a href="https://github.com/wzqcongcong/AppleTunerUpdater" target="_blank" rel="external">AppleTunerUpdater</a></p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>在 Mac 中，进程间的通信机制，除了 <em><code>NSDistributedNotification</code></em>、<em><code>Distributed Objects</code></em>，还有 XPC。XPC 可以在同一个 app 的不同 bundle 间使用，也可以在不同的 app 间使用。</p>
<p>XPC 机制是通过 <em><code>NSXPCConnection</code></em> 作为 channel 来通信的，每个 <em><code>NSXPCConnection</code></em> 有 <em>Client</em> 和 <em>Listener</em> 两个 endpoint。</p>
<h3 id="1-_XPC_角色">1. XPC 角色</h3><h4 id="Listener">Listener</h4><p>通过 <em><code>NSXPCListener</code></em> API 来创建 Listener，并指定该 Listener 的 <em><code>NSXPCListenerDelegate</code></em>，该 delegate 需要实现的函数是 <em><code>(BOOL)listener:shouldAcceptNewConnection:</code></em>。该 delegate 函数用于决定是否响应新的 connection，并设置该 connection 的 <em><code>exportedInterface</code></em> 和 <em><code>exportedObject</code></em>。</p>
<ul>
<li><p><em><code>exportedObject</code></em>：Listener 的导出对象，提供接口供 Client 访问。</p>
</li>
<li><p><em><code>exportedInterface</code></em>：列举出 <em><code>exportedObject</code></em> 能够导出哪些可用的接口供 Client 调用，函数原型通常是：<em>`(void)doTaskWithInfo:(NSDictionary </em>)info callback:(void(^)(NSDictionary <em>dic))callback`</em>。</p>
</li>
</ul>
<h4 id="Client">Client</h4><p>Client 通过 <em><code>NSXPCConnection</code></em> API 来创建一个新的 connection，并指定该 connection 的 <em><code>remoteObjectInterface</code></em>，它代表 Listener 端的 <em><code>exportedInterface</code></em>。然后就可以通过 <em><code>remoteObjectProxyWithErrorHandler:</code></em> 来获取 Listener 端的 <em><code>exportedObject</code></em>，调用其导出的接口。Listener 在执行自己的导出函数时，可以通过调用传递进来的 callback 向 Client 端 send back 数据。</p>
<h4 id="NSXPCConnection">NSXPCConnection</h4><p><em><code>NSXPCConnection</code></em> 的发起是单向的，只能由 Client 端到 Listener 端，因为每一个发起的 connection 必须要由 Listener 端通过 <em><code>NSXPCListenerDelegate</code></em> 函数来决定是否要进行响应。但 Client 和 Listener 都可以有自己的 <em><code>exportedObject</code></em> 和 <em><code>remoteObjectProxy</code></em>，在 connect 之后可以相互访问对方，一方的 <em><code>exportedObject</code></em> 对应另一方的 <em><code>remoteObjectProxy</code></em>。参见 Apple 文档中的图示。</p>
<p><strong>注意</strong>：不管是 Client 还是 Listener，设置自己的 <em><code>exportedObject</code></em> 和 <em><code>remoteObjectProxy</code></em> 必须要先于调用 <em><code>resume</code></em>。</p>]]>
    
    </summary>
    
      <category term="Mac" scheme="http://hi.zongquan.wang/tags/Mac/"/>
    
      <category term="XPC" scheme="http://hi.zongquan.wang/tags/XPC/"/>
    
      <category term="开发" scheme="http://hi.zongquan.wang/categories/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
