<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[闷骚的悟空]]></title>
  <subtitle><![CDATA[立一业谋生|择一城终老|携一人白首]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="https://hi.zongquan.wang/"/>
  <updated>2016-12-12T11:53:12.000Z</updated>
  <id>https://hi.zongquan.wang/</id>
  
  <author>
    <name><![CDATA[闷骚的悟空]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Fix Bug for Interface Inspector on macOS Serria]]></title>
    <link href="https://hi.zongquan.wang/2016/11/08/Fix_Bug_for_Interface_Inspector_on_macOS_Serria/"/>
    <id>https://hi.zongquan.wang/2016/11/08/Fix_Bug_for_Interface_Inspector_on_macOS_Serria/</id>
    <published>2016-11-08T08:32:57.000Z</published>
    <updated>2016-12-12T11:53:12.000Z</updated>
    <content type="html"><![CDATA[<p>之前介绍过<a href="../../../../2016/04/21/Hack_Interface_Inspector/">如何破解 Interface Inspector</a>，近来把系统升级到最新的 macOS Serria 之后，发现 Interface Inspector 不 work 了。启动倒是正常，但每次 attach app 时，总是提示无法 attach，查看 system log，发现有这么一个 error：</p>
<p><img src="/img/Fix_Bug_for_Interface_Inspector_on_macOS_Serria/log.png" alt="log"></p>
<p>从 log 中看出，root cause 是 <em>mach_inject_bundle_stub</em> 去 load <code>___pthread_set_self</code> 时失败了，而这个函数本来应该是在 <em>libSystem.B.dylb</em> 这个系统库里面的。也就是说，macOS Serria 的 <em>libSystem.B.dylb</em> 已经不再有 <code>___pthread_set_self</code> 这个函数了。于是开始 google，最后在<a href="https://twitter.com/snielsen42/status/778405531383836674" target="_blank" rel="external">一条 Twitter</a> 上发现了咋回事，是的，<code>___pthread_set_self</code> 已经被替换成了 <code>_pthread_set_self</code>。</p>
<p>明白了咋回事，开始考虑怎么解决。</p>
<a id="more"></a>
<h2 id="方法_1：">方法 1：</h2><p>修改 <em>mach_inject_bundle_stub</em> 的 load 指令，从旧版系统中 copy 一份老的 <em>libSystem.B.dylb</em>，然后让 <em>mach_inject_bundle_stub</em> 去 load 这个老的库。</p>
<h2 id="方法_2：">方法 2：</h2><p>还是修改 <em>mach_inject_bundle_stub</em>，把所有调用 <code>___pthread_set_self</code> 的地方改成调用 <code>_pthread_set_self</code>。</p>
<p>理论上这两种方法应该都可以的吧，但是考虑到自己逆向功力不够，所以就采用了如下的正向方法 XD。</p>
<h1 id="方法_3：">方法 3：</h1><p>我搜索了一下 <em>mach_inject_bundle_stub</em> 这个东西，发现原来是个 GitHub 上的<a href="https://github.com/wzqcongcong/mach_inject" target="_blank" rel="external">开源库</a>，Interface Inspector 就是用的这个库。app 会在 <code>/Library/Frameworks/mach_inject_bundle.framework</code> 这里安装这个库，而 <em>mach_inject_bundle_stub</em> 就是这个库里面的一个子 bundle。有了 source code 就好办了，只需要修改 code，然后重新编译替换掉 <em>mach_inject_bundle_stub</em> 这个 bundle 就好了。</p>
<p>步骤：</p>
<h3 id="1-_fork_it">1. fork it</h3><h3 id="2-_修改_code">2. 修改 code</h3><p><img src="/img/Fix_Bug_for_Interface_Inspector_on_macOS_Serria/github.png" alt="github"></p>
<h3 id="3-_编译签名">3. 编译签名</h3><p>注意，这里有个小细节，app 在 load <em>mach_inject_bundle_stub</em> 这个 bundle 时，是按照 bundle id <code>com.rentzsch.mach-inject-bundle-stub</code> 来找的，所以需要把工程文件里的 bundle id 改成跟原来的 bundle id 一样。</p>
<h3 id="4-_替换到_mach_inject_bundle-framework_里面">4. 替换到 <em>mach_inject_bundle.framework</em> 里面</h3><h3 id="5-_顺便提一个_pull_request，老代码已经年久失修了_XD">5. 顺便提一个 pull request，老代码已经年久失修了 XD</h3><p>完成之后，重新启动 app，可以正常 work 了！</p>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前介绍过<a href="../../../../2016/04/21/Hack_Interface_Inspector/">如何破解 Interface Inspector</a>，近来把系统升级到最新的 macOS Serria 之后，发现 Interface Inspector 不 work 了。启动倒是正常，但每次 attach app 时，总是提示无法 attach，查看 system log，发现有这么一个 error：</p>
<p><img src="/img/Fix_Bug_for_Interface_Inspector_on_macOS_Serria/log.png" alt="log"></p>
<p>从 log 中看出，root cause 是 <em>mach_inject_bundle_stub</em> 去 load <code>___pthread_set_self</code> 时失败了，而这个函数本来应该是在 <em>libSystem.B.dylb</em> 这个系统库里面的。也就是说，macOS Serria 的 <em>libSystem.B.dylb</em> 已经不再有 <code>___pthread_set_self</code> 这个函数了。于是开始 google，最后在<a href="https://twitter.com/snielsen42/status/778405531383836674">一条 Twitter</a> 上发现了咋回事，是的，<code>___pthread_set_self</code> 已经被替换成了 <code>_pthread_set_self</code>。</p>
<p>明白了咋回事，开始考虑怎么解决。</p>]]>
    
    </summary>
    
      <category term="Mac" scheme="https://hi.zongquan.wang/tags/Mac/"/>
    
      <category term="Development" scheme="https://hi.zongquan.wang/categories/Development/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift and Objective-C (Mix and Match)]]></title>
    <link href="https://hi.zongquan.wang/2016/07/25/Swift_and_ObjectiveC_Mix_and_Match/"/>
    <id>https://hi.zongquan.wang/2016/07/25/Swift_and_ObjectiveC_Mix_and_Match/</id>
    <published>2016-07-25T09:32:53.000Z</published>
    <updated>2016-12-12T11:53:12.000Z</updated>
    <content type="html"><![CDATA[<p>Swift 与 Objective-C 混编 （to be continued）</p>
<h3 id="Code_直接混编_+_Framework_间接混编">Code 直接混编 + Framework 间接混编</h3><hr>
<h2 id="&lt;_Code_直接混编_&gt;">&lt; Code 直接混编 &gt;</h2><ul>
<li><h4 id="在_Objective-C_code_中使用_Swift_code">在 Objective-C code 中使用 Swift code</h4><p>  Objective-C project: <code>Project_C</code><br>  PRODUCT_MODULE_NAME: <code>Project_C_Product</code></p>
<ol>
<li>in Project_C’s build settings, set up <code>&quot;Embedded Content Contains Swift Code&quot;</code> to <code>&quot;YES&quot;</code>.</li>
<li>in Project_C’s build settings, set up <code>&quot;Objective-C Generated Interface Header Name&quot;</code> to <code>&quot;Project_C_Product-Swift.h&quot;</code>.</li>
<li>Swift code should use <code>@objc</code> to mark what you want to expose to Objective-C code.</li>
<li>in Objective-C code, <code>#import &quot;Project_C_Product-Swift.h&quot;</code>.</li>
</ol>
</li>
</ul>
<a id="more"></a>
<ul>
<li><h4 id="在_Swift_code_中使用_Objective-C_code">在 Swift code 中使用 Objective-C code</h4><p>  Swift project: <code>Project_S</code><br>  PRODUCT_MODULE_NAME: <code>Project_S_Product</code></p>
<ol>
<li>in Project_S’s build settings, set up <code>&quot;Objective-C Bridging Header&quot;</code> to <code>&quot;Project_S_Product-Bridging-Header.h&quot;</code>.</li>
<li>in <code>&quot;Project_S_Product-Bridging-Header.h&quot;</code>, <code>#import</code> every Objective-C header you want to expose to Swift code.</li>
<li>in Swift code, <em>NO</em> need to <code>#import &quot;Project_C_Product-Bridging-Header.h&quot;</code>.</li>
</ol>
</li>
</ul>
<h2 id="&lt;_Framework_间接混编_&gt;">&lt; Framework 间接混编 &gt;</h2><ul>
<li><h4 id="创建_Swift_framework_给_Objective-C_code_使用">创建 Swift framework 给 Objective-C code 使用</h4><p>framework product: <code>Framework_S</code></p>
<p><strong>framework’s side:</strong></p>
<ol>
<li>in Framework_S’s build settings, set up <code>&quot;Objective-C Generated Interface Header Name&quot;</code> to <code>&quot;Framework_S-Swift.h&quot;</code>.</li>
<li>use <code>@objc</code> to mark what you want to expose to Objective-C code.</li>
<li>after Framework_S is producted, its umbrella will include the <code>&quot;Framework_S-Swift.h&quot;</code> file.</li>
</ol>
<p><strong>consumer’s side:</strong></p>
<ol>
<li>in build settings, set up <code>&quot;Embedded Content Contains Swift Code&quot;</code> to <code>&quot;YES&quot;</code>.</li>
<li><code>@import Framework_S</code>.</li>
</ol>
</li>
<li><h4 id="创建_Objective-C_framework_给_Swift_code_使用">创建 Objective-C framework 给 Swift code 使用</h4><p>framework product: <code>Framework_C</code></p>
<p><strong>framework’s side:</strong> nothing</p>
<p><strong>consumer’s side:</strong> <code>import Framework_C</code></p>
</li>
</ul>
<hr>
<h4 id="Apple_官方文档"><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html" target="_blank" rel="external">Apple 官方文档</a></h4><hr>
]]></content>
    <summary type="html">
    <![CDATA[<p>Swift 与 Objective-C 混编 （to be continued）</p>
<h3 id="Code_直接混编_+_Framework_间接混编">Code 直接混编 + Framework 间接混编</h3><hr>
<h2 id="&lt;_Code_直接混编_&gt;">&lt; Code 直接混编 &gt;</h2><ul>
<li><h4 id="在_Objective-C_code_中使用_Swift_code">在 Objective-C code 中使用 Swift code</h4><p>  Objective-C project: <code>Project_C</code><br>  PRODUCT_MODULE_NAME: <code>Project_C_Product</code></p>
<ol>
<li>in Project_C’s build settings, set up <code>&quot;Embedded Content Contains Swift Code&quot;</code> to <code>&quot;YES&quot;</code>.</li>
<li>in Project_C’s build settings, set up <code>&quot;Objective-C Generated Interface Header Name&quot;</code> to <code>&quot;Project_C_Product-Swift.h&quot;</code>.</li>
<li>Swift code should use <code>@objc</code> to mark what you want to expose to Objective-C code.</li>
<li>in Objective-C code, <code>#import &quot;Project_C_Product-Swift.h&quot;</code>.</li>
</ol>
</li>
</ul>]]>
    
    </summary>
    
      <category term="Swift" scheme="https://hi.zongquan.wang/tags/Swift/"/>
    
      <category term="Development" scheme="https://hi.zongquan.wang/categories/Development/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hack Interface Inspector]]></title>
    <link href="https://hi.zongquan.wang/2016/04/21/Hack_Interface_Inspector/"/>
    <id>https://hi.zongquan.wang/2016/04/21/Hack_Interface_Inspector/</id>
    <published>2016-04-21T12:38:11.000Z</published>
    <updated>2016-12-12T11:53:12.000Z</updated>
    <content type="html"><![CDATA[<p>之前在 iOSRE 上看到<a href="http://bbs.iosre.com/t/mac/3373" target="_blank" rel="external">一篇文章</a>，里面有讲到一个逆向 Mac app UI 的工具 <a href="http://www.interface-inspector.com/" target="_blank" rel="external">Interface Inspector</a>，扫了一眼，尼玛神器啊，简直就是 Reveal 的 Mac 版。上个图感受一下它的淫威吧：</p>
<p><img src="/img/Hack_Interface_Inspector/ii.png" alt="Interface Inspector"></p>
<p>这么好的工具，这么贵的价格，心痒了。好吧，凭借着<a href="../../../../2016/01/12/Hack_XtraFinder/">之前的破解经验</a>，再来搞一次吧。</p>
<a id="more"></a>
<h3 id="0-_开始">0. 开始</h3><p>首先从官网下载试用版，打开 app，直接弹出一个提示框：</p>
<p><img src="/img/Hack_Interface_Inspector/alert.png" alt="Alert"></p>
<p>啊哈哈，最喜欢这么直接的打招呼了。</p>
<p>用 Hopper 加载完 <em>Interface Inspector</em> 后，可以直接奔着两个函数去了：</p>
<p><img src="/img/Hack_Interface_Inspector/launching.png" alt="Launching"></p>
<h3 id="1-_绕过签名校验">1. 绕过签名校验</h3><p>首先看一下 <code>[SMAppDelegate applicationWillFinishLaunching:]</code>，里面有这么一段：</p>
<p><img src="/img/Hack_Interface_Inspector/will.png" alt="applicationWillFinishLaunching"></p>
<p>也就是说，app 启动完成之前，会调用 <code>[[NSBundle mainBundle] codeSignState]</code> 来检查 bundle 的签名是否合法（具体如何检查后面详谈）。如果不合法，会弹出一个提示框说 “Signature of the Interface Inspector is broken”，然后 app 就直接退出了。所以我们首先要绕过这个检查。</p>
<p>显然，<code>codeSignState</code> 这个函数并非官方 api，应该是作者自己添加的 <em>NSBundle category</em>。搜索了一下该函数名，没有找到。于是就去 app 的 <code>Frameworks</code> 目录下看看是不是由第三方库引入的。在这里有 3 个 framework：<em>DFeedback.framework</em>、<em>SMFoundation.framework</em>、<em>Sparkle.framework</em>，很明显，第一个肯定是收集用户 feedback 用的，第三个大家都知道是 update 模块，那就剩下第二个了。用 Hopper 加载 <em>SMFoundation</em>，果然搜索到了 <code>codeSignState</code> 这个函数。</p>
<p>在这个函数里，作者是用 <code>SecStaticCodeCheckValidityWithErrors</code> 这个官方 api 来检查签名的合法性的。具体用法可以查阅文档，这里只提一下比较重要的 2 个参数<code>staticCode</code> 和 <code>requirement</code>：<code>staticCode</code> 是待校验的 <em>code object</em>，<code>requirement</code> 则表示 <code>staticCode</code> 需要满足的校验条件。作者使用的校验条件是：<code>certificate leaf = H&quot;0E1D40082148472951C6FB2DDCD8800D82629792&quot;</code>。看到这里一开始我也蒙了，这是什么鬼。后来查阅了一下文档才明白这个用法。其实就是校验一下签名证书的叶子节点是不是 <code>H&quot;0E1D40082148472951C6FB2DDCD8800D82629792&quot;</code> 这个值，而这一串字符是签名证书的 <em>SHA1 FingerPrints</em>，由 40 个 HEX 字符组成，可以在自己的开发者证书里查到：</p>
<p><img src="/img/Hack_Interface_Inspector/cert.png" alt="Cert"></p>
<p>也就是说，如果用别人的证书重新签名该 app，而又没有同时修改这个校验条件的话，那么最终的签名就是不合法的，app 就会闪退了。所以我们需要先把这个校验条件改掉。简单，直接把这个字符串的值改成自己开发者证书里面的 <em>SHA1 FingerPrints</em> 就好了。</p>
<p>OK，签名校验已经绕过去了，下面就可以随意地修改 app 然后重新签名了。</p>
<h3 id="2-_破解_License_机制">2. 破解 License 机制</h3><p><code>[SMAppDelegate applicationWillFinishLaunching:]</code> 已经没什么好看的了，接着看 <code>[SMAppDelegate applicationDidFinishLaunching:]</code>，里面有这么一段：</p>
<p><img src="/img/Hack_Interface_Inspector/did.png" alt="applicationDidFinishLaunching"></p>
<p>太明显了，没有 license 的话就提示用户输入序列号进行激活。顺藤摸瓜，最终找到了这么个函数 <code>[SMLicenseManager verifyLicenseWithName:code:]</code>，它就是用来验证 license 是否合法的！只要我们对它进行破解，这样随便输入任意序列号就可以激活了，啊哈哈。</p>
<p>简单得不能再简单了，直接用 Hopper 的 <em>Modify</em> 功能修改成 <code>mov eax, 0x1</code> <code>ret</code> 即可，也就是直接返回 <code>YES</code> 通过验证。</p>
<p>修改完成，重新签名，运行 app，啊哦，闪退了！</p>
<h3 id="3-_作者的鬼点子">3. 作者的鬼点子</h3><p>看来还是有什么地方没改好。重新回去检查整个 <code>SMLicenseManager</code> 类，一个函数一个函数地检查，最终发现了这么个函数 <code>[SMLicenseManager load]</code>。作者在这里耍了一个小花招：</p>
<p><img src="/img/Hack_Interface_Inspector/tricky.png" alt="Tricky"></p>
<p>是的，我们把 <code>[SMLicenseManager verifyLicenseWithName:code:]</code> 改成了总是返回 <code>YES</code>，但是代码走到这里撞墙了，<em>Test User</em> 验证之后也返回 <code>YES</code> 了，然后 app 直接 <code>terminate:</code> 了。也就是说，作者在这里放了一个本来就是非法的 license，正常验证的话肯定是返回 <code>NO</code> 的，就不会导致直接退出了。所以我们还需要把这里的判断条件改成 <code>XXX == NO</code>，这样就没有问题了。真是淘气的作者，藏得这么深。</p>
<p>好了，改好，重新签名，运行 app，随便输入 license 信息，啊哈哈，注册成功！</p>
<p><img src="/img/Hack_Interface_Inspector/done.png" alt="Done"></p>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前在 iOSRE 上看到<a href="http://bbs.iosre.com/t/mac/3373">一篇文章</a>，里面有讲到一个逆向 Mac app UI 的工具 <a href="http://www.interface-inspector.com/">Interface Inspector</a>，扫了一眼，尼玛神器啊，简直就是 Reveal 的 Mac 版。上个图感受一下它的淫威吧：</p>
<p><img src="/img/Hack_Interface_Inspector/ii.png" alt="Interface Inspector"></p>
<p>这么好的工具，这么贵的价格，心痒了。好吧，凭借着<a href="../../../../2016/01/12/Hack_XtraFinder/">之前的破解经验</a>，再来搞一次吧。</p>]]>
    
    </summary>
    
      <category term="Mac" scheme="https://hi.zongquan.wang/tags/Mac/"/>
    
      <category term="Development" scheme="https://hi.zongquan.wang/categories/Development/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[How to install iOSOpenDev manually]]></title>
    <link href="https://hi.zongquan.wang/2016/03/29/How_to_install_iOSOpenDev_manually/"/>
    <id>https://hi.zongquan.wang/2016/03/29/How_to_install_iOSOpenDev_manually/</id>
    <published>2016-03-29T15:30:35.000Z</published>
    <updated>2016-12-12T11:53:12.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/wzqcongcong/iOSOpenDev" target="_blank" rel="external">https://github.com/wzqcongcong/iOSOpenDev</a></p>
<a id="more"></a>
<hr>
<h3 id="OS_X_10-10+_&amp;_Xcode_7+">OS X 10.10+ &amp; Xcode 7+</h3><ol>
<li><p><strong>Dependency</strong></p>
<p><code>brew install ldid dpkg</code></p>
</li>
<li><p><strong>Theos</strong></p>
<p><a href="https://github.com/theos/theos/wiki" target="_blank" rel="external">Wiki</a></p>
<p><a href="http://iphonedevwiki.net/index.php/Theos/Setup" target="_blank" rel="external">Setup</a></p>
</li>
<li><p><strong>iOSOpenDev</strong></p>
<p><a href="https://github.com/kokoabim/iOSOpenDev/wiki" target="_blank" rel="external">Wiki</a></p>
<p>3.1. update <strong>.zshrc</strong></p>
<p><code>export iOSOpenDevPath=path/to/iOSOpenDev</code></p>
<p><code>export iOSOpenDevDevice=</code></p>
<p><code>export PATH=$iOSOpenDevPath:$PATH</code></p>
<p>3.2. get <strong>iOSOpenDev</strong></p>
<ul>
<li><p><code>git clone --recursive https://github.com/kokoabim/iOSOpenDev.git $iOSOpenDevPath</code></p>
</li>
<li><p>copy the folder <a href="https://github.com/wzqcongcong/iOSOpenDev" target="_blank" rel="external"><strong>templates</strong></a> into <em>$iOSOpenDevPath</em></p>
</li>
</ul>
<p>this version of <strong>templates</strong> is refined by the <a href="https://github.com/kokoabim/iOSOpenDev-Xcode-Templates" target="_blank" rel="external">original one</a>: the <em>ShellScript</em> of <em>BuildPhases</em> in <strong>TemplateInfo.plist</strong> is changed to <code>$iOSOpenDevPath/bin/iosod --xcbp</code>. and the <em>[$iOSOpenDevPath]</em> here is not that in <em>.zshrc</em>, it is a user defined key in <strong>Base.xctemplate</strong> and <strong>Empty Project.xctemplate</strong>.</p>
<p>3.3. setup <strong>Xcode</strong></p>
<ul>
<li><p>copy the <a href="https://github.com/wzqcongcong/iOSOpenDev" target="_blank" rel="external"><strong>.xcspec</strong></a> files into <em>/Applications/Xcode/Content/Developer/Platforms/[PLATFORM_PATH]/Developer/Library/Xcode/Specifications</em> (mkdir if not existed)</p>
</li>
<li><p><code>mkdir -p /Applications/Xcode/Content/Developer/Platforms/[PLATFORM_PATH]/Developer/usr/bin</code></p>
</li>
<li><p><code>ln -fhs $iOSOpenDevPath/bin/iosod /Applications/Xcode/Content/Developer/Platforms/[PLATFORM_PATH]/Developer/usr/bin</code></p>
</li>
<li><p><code>ln -fhs $iOSOpenDevPath/bin/ldid /Applications/Xcode/Content/Developer/Platforms/[PLATFORM_PATH]/Developer/usr/bin</code></p>
</li>
</ul>
<p>3.4. setup <strong>SDK</strong></p>
<ul>
<li><p>modify the following key/value in <strong>[SDK_PATH]/SDKSettings.plist</strong>:</p>
<pre><code>DefaultProperties<span class="class">.CODE_SIGNING_REQUIRED</span> =&gt; NO
DefaultProperties<span class="class">.ENTITLEMENTS_REQUIRED</span> =&gt; NO
DefaultProperties<span class="class">.AD_HOC_CODE_SIGNING_ALLOWED</span> =&gt; YES
</code></pre></li>
<li><p>in Xcode 7.3, the private framework has been removed from iOS 9.3 SDK, so maybe you want to use iOS 9.2 SDK. once you copy iOS 9.2 SDK into <em>[PLATFORM_PATH]/Developer/SDKs</em>, you should also modify <strong>[PLATFORM_PATH]/Info.plist</strong> as following, or else Xcode 7.3 can not recognize iOS 9.2 SDK in project build settings:</p>
<pre><code>MinimumSDKVersion =&gt; <span class="number">9.2</span>
</code></pre></li>
</ul>
<p>3.5. setup <strong>templates</strong></p>
<ul>
<li><code>ln -fhs $iOSOpenDevPath/templates ~/Library/Developer/Xcode/Templates/iOSOpenDev</code></li>
<li>open <strong>TemplateInfo.plist</strong> in <strong>Base.xctemplate</strong> and <strong>Empty Project.xctemplate</strong> with Xcode, then set the value of the user defined key <em>[iOSOpenDevPath]</em> to <em>path/to/iOSOpenDev</em>.</li>
</ul>
</li>
</ol>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/wzqcongcong/iOSOpenDev">https://github.com/wzqcongcong/iOSOpenDev</a></p>]]>
    
    </summary>
    
      <category term="Xcode" scheme="https://hi.zongquan.wang/tags/Xcode/"/>
    
      <category term="Development" scheme="https://hi.zongquan.wang/categories/Development/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hack XtraFinder]]></title>
    <link href="https://hi.zongquan.wang/2016/01/12/Hack_XtraFinder/"/>
    <id>https://hi.zongquan.wang/2016/01/12/Hack_XtraFinder/</id>
    <published>2016-01-12T15:38:55.000Z</published>
    <updated>2016-12-12T11:53:12.000Z</updated>
    <content type="html"><![CDATA[<p>事情是这样的，我的系统是 OS X 10.11，就是那个有 SIP 的 10.11 😂。然后我装了一个 Finder 的插件：XtraFinder，这个插件有些功能在 10.11 下是不 work 的，所以插件作者出于好心，在检测到你的系统是 10.11 且 SIP 没有关闭的情况下，会弹出一个 alert 窗口作为提醒。</p>
<a id="more"></a>
<p><img src="/img/Hack_XtraFinder/alert.png" alt="Alert"></p>
<p>那么问题来了，作者检测 SIP 是否关闭的方法有个 bug，导致我明明是完全关闭了 SIP，但插件却认为 SIP 还在启用。第二个问题，这个 alert 每次重启插件（包括每次重启系统）时都会弹出来啊，出来啊，来啊，啊，搞得你每次都要去点一下确认才能将其关闭，烦的很 😒。我曾经给作者发邮件，希望他能 update 一下，只弹一次 alert 就好。当然了，作者没有鸟我。</p>
<p>作为偶尔会用 Hopper Disassembler 偷窥一下别人代码的我，就开始意淫能不能 hack 一下这个插件，改掉这个恶心的行为。</p>
<h3 id="工具">工具</h3><ul>
<li>Hopper Disassembler</li>
<li>Hex Fiend</li>
<li>Developer ID Application 证书</li>
</ul>
<h3 id="步骤">步骤</h3><ol>
<li><p>用 Hopper Disassembler 定位 hack point</p>
<p> 这个 alert 是插件一启动的时候就弹出的，所以很容易想到先去 check 一下 <code>[AppDelegate applicationDidFinishLaunching:]</code> 这个方法。Load Mach-O 文件后，直奔那个函数的伪代码：</p>
<p> <img src="/img/Hack_XtraFinder/hopper1.png" alt="Hopper Disassembler"></p>
<p> 从图中可以看到，插件作者通过 <code>csrutil status</code> 的返回结果来判断 SIP 的状态，只有返回结果中匹配到了字符串 <code>&quot;Debugging Restrictions: disabled&quot;</code> 才认为 SIP 关闭。但是，我是完全关闭 SIP 的，运行 <code>csrutil status</code> 的结果是 <code>System Integrity Protection status: disabled.</code>，显然无法匹配那个字符串，所以就被误认为是 SIP 尚未关闭。</p>
<p> 注意，上图中蓝色框中的内容是我修改之后的，原内容是 <code>if (rax != rcx) goto loc_100001df7;</code>，也就是当 <code>[rax rangeOfString:rdx] != NSNotFound</code> 的时候，字符串匹配成功，就跳过不弹 alert。看到这里你已经知道了，只要把条件反转就大功告成了。</p>
<p> 当然，除了反转判断条件之外，还可以修改那个用于匹配的字符串，比如修改成 <code>&quot;disabled&quot;</code> 就好了，都能够匹配成功。</p>
<p> 好了，伪代码是看明白了，下面就得看如何让这个判断条件反转了。</p>
<p> <img src="/img/Hack_XtraFinder/hopper2.png" alt="Hopper Disassembler"></p>
<p> 上图中红色框中的汇编代码对应前面分析的那块伪代码，而蓝色框中的十六进制 <code>0F 84 E1 01 00 00</code> 代表伪代码块中的最后那条命令 <code>0x0000000100001c10         je         0x100001df7</code>。<code>je</code> 这个指令表示 <em><code>如果等于则跳转到</code></em>，它的反指令是 <code>jne</code>，所以我们要做的就是把最后这条命令改为 <code>jne         0x100001df7</code>。参考一下<a href="http://neuzxy.blog.51cto.com/10270223/1716326" target="_blank" rel="external">这篇文章</a>，其实就是把 <code>0F 84 E1 01 00 00</code> 改为 <code>0F 85 E1 01 00 00</code>，把 4 改成 5。</p>
</li>
<li><p>用 Hex Fiend 修改 Mach-O 文件</p>
<p> 明白了改什么，下面就是开始操作了。用 Hex Fiend 打开 Mach-O 文件，直接查找替换即可。</p>
<p> <img src="/img/Hack_XtraFinder/hex1.png" alt="Hex Fiend"></p>
<p> 只有一点需要注意：如果直接查找 <code>0F 84 E1 01 00 00</code> 的话，可能有多处，所以为了准确定位，我们可以连同下一条命令一起来查找，如上图，我们查找 <code>0F 84 E1 01 00 00 48 8B 3D 6B 14 01 00</code>，这样就会只找到唯一的一处。</p>
<p> 替换完成后保存即可。</p>
</li>
<li><p>重新签名</p>
<p> 修改后的 Mach-O 文件是无法运行的，因为签名不对了。所以需要我们用自己的开发者证书重签一下：<code>codesign -f -s &quot;XXX 证书的 Common Name&quot; /Applications/XtraFinder.app/Contents/MacOS/XtraFinder</code>。</p>
<p> 大功告成，覆盖重启插件后，再也没有弹出 alert，XtraFinder 照常 work 😆。</p>
</li>
</ol>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p>事情是这样的，我的系统是 OS X 10.11，就是那个有 SIP 的 10.11 😂。然后我装了一个 Finder 的插件：XtraFinder，这个插件有些功能在 10.11 下是不 work 的，所以插件作者出于好心，在检测到你的系统是 10.11 且 SIP 没有关闭的情况下，会弹出一个 alert 窗口作为提醒。</p>]]>
    
    </summary>
    
      <category term="Mac" scheme="https://hi.zongquan.wang/tags/Mac/"/>
    
      <category term="Development" scheme="https://hi.zongquan.wang/categories/Development/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Xcode Build Settings - Products Path]]></title>
    <link href="https://hi.zongquan.wang/2015/11/16/Xcode_Build_Settings_Products_Path/"/>
    <id>https://hi.zongquan.wang/2015/11/16/Xcode_Build_Settings_Products_Path/</id>
    <published>2015-11-16T12:21:54.000Z</published>
    <updated>2016-12-12T11:53:12.000Z</updated>
    <content type="html"><![CDATA[<p>假设一个 Project 的路径是 <code>XXX/ProjectX</code>。</p>
<p>当 build 完成后，我们会关注 2 个与 <strong>Product Files</strong> 有关的 settings ：</p>
<a id="more"></a>
<p><strong><code>$BUILT_PRODUCTS_DIR</code></strong> 和 <strong><code>$TARGET_BUILD_DIR</code></strong></p>
<p>这 2 个 settings 决定了我们 build 出来的 Products 被放置到了哪里。</p>
<h4 id="官方解释">官方解释</h4><ul>
<li><p><strong><code>$BUILT_PRODUCTS_DIR</code></strong>：Directory path. Identifies the directory under which all the product’s files can be found. This directory contains either product files or symbolic links to them.</p>
</li>
<li><p><strong><code>$TARGET_BUILD_DIR</code></strong>：Directory path. Identifies the root of the directory hierarchy that contains the product’s files (no intermediate build files).</p>
</li>
</ul>
<p>乍一看好像都是用来存放 <strong>Product Files</strong> 的目录，但是它们的作用是不一样的：</p>
<p>刚编译完的时候，Xcode 会先把 <strong>Product Files</strong> 生成到 <strong><code>$BUILT_PRODUCTS_DIR</code></strong> 中，然后再根据具体的 configuration 来决定要不要对生成的 <strong>Product Files</strong> 进行 deploy，如果不需要 deploy，那么 <strong>Product Files</strong> 最后还是留在 <strong><code>$BUILT_PRODUCTS_DIR</code></strong> 中，如果需要 deploy，那么 <strong>Product Files</strong> 会被 move 到 <strong><code>$TARGET_BUILD_DIR</code></strong> 中，而原来的 <strong><code>$BUILT_PRODUCTS_DIR</code></strong> 中就只有 symbolic links 了。</p>
<h4 id="举个例子">举个例子</h4><p>普通的 app 在 build 完之后，一般放置在 <code>$BUILT_PRODUCTS_DIR</code> 中即可，而对于 Xcode Plugin 来说，在 build 完之后一般会直接将其 deploy 到 Xcode 的 <strong>Plug-ins</strong> 目录中，此时 <code>$TARGET_BUILD_DIR</code> 就是 <strong>Plug-ins</strong> 目录，而 <code>$BUILT_PRODUCTS_DIR</code> 中只有 Plugin 的 symbolic links。</p>
<p><em>可以 clone 一下我之前写的一个<a href="https://github.com/wzqcongcong/AtAutoCompletion" target="_blank" rel="external">小插件</a>，build 一下看结果。</em></p>
<hr>
<h4 id="下面就看一下这_2_个路径是如何设置的">下面就看一下这 2 个路径是如何设置的</h4><p><strong>首先解释一些相关的 settings：</strong></p>
<p><strong>settingName (settingDisplayNameInXcodeBuildSettings)</strong></p>
<ul>
<li><p><strong><code>$SRCROOT</code></strong>：<code>XXX/ProjectX</code></p>
</li>
<li><p><strong><code>$SYMROOT (Build Products Path)</code></strong>：Directory path. Identifies the root of the directory hierarchy that contains product files and intermediate build files. Product and build files are placed in subdirectories of this directory. 看完官方解释，我再说一下它具体如何设置。</p>
<ol>
<li><p>默认值是 <code>$SRCROOT/build</code></p>
</li>
<li><p>可以在 Xcode 的 Preferences 里面设置 <code>Build Location</code>，如下图<br><img src="/img/Xcode_Build_Settings_Products_Path/location.png" alt="Build Location"></p>
</li>
<li><p>直接在 Target 的 <code>Build Settings</code> 里面设置 <code>Build Products Path</code>，如下图<br><img src="/img/Xcode_Build_Settings_Products_Path/build_products_path.png" alt="Build Products Path"></p>
</li>
</ol>
<p>这 3 种设置的优先级依次递增，也就是说，如果你同时设置了 2 和 3，那么最后 build 是按照 3 的值来处理的。</p>
</li>
<li><p><strong><code>$CONFIGURATION</code></strong>：Debug、Release、自定义的等等。</p>
</li>
<li><p><strong><code>$CONFIGURATION_BUILD_DIR (Per-Configuration Build Products Path)</code></strong>：= <code>$SYMROOT/$CONFIGURATION</code>，例如 <code>XXX/ProjectX/build/Debug</code>。</p>
</li>
<li><p><strong><code>$DEPLOYMENT_LOCATION (Deployment Location)</code></strong>：Boolean value. Specifies whether product files are placed in the installation or the build directory. 它决定了要不要对 <strong>Product Files</strong> 进行 deploy。</p>
</li>
<li><p><strong><code>$SKIP_INSTALL (Skip Install)</code></strong>：Boolean value. Specifies whether to place the product at the location indicated by <em><code>$DSTROOT</code></em> or the uninstalled products directory inside the directory indicated by <em><code>$TARGET_TEMP_DIR</code></em>. 它决定了具体要把 <strong>Product Files</strong> deploy 到哪里。</p>
</li>
</ul>
<p><strong>下面就轮到 2 个主角了。</strong></p>
<ul>
<li><p><strong><code>$BUILT_PRODUCTS_DIR</code></strong>：= <code>$CONFIGURATION_BUILD_DIR</code> = <code>$SYMROOT/$CONFIGURATION</code> <em>（其实除了这个值，还有一种取值，不过基本不用，所以这里为了便于理解把它忽略了。详情可查阅<a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Reference/XcodeBuildSettingRef/0-Introduction/introduction.html" target="_blank" rel="external">官方文档</a>）</em></p>
</li>
<li><p><strong><code>$TARGET_BUILD_DIR</code></strong>：</p>
<ol>
<li><p>如果 <code>$DEPLOYMENT_LOCATION</code> = <code>NO</code>，即不需要 deploy，那么 <code>$TARGET_BUILD_DIR</code> 就直接等同于 <code>$BUILT_PRODUCTS_DIR</code>。</p>
</li>
<li><p>如果 <code>$DEPLOYMENT_LOCATION</code> = <code>YES</code>，即需要 deploy，那么：</p>
</li>
</ol>
<p>2.1. 如果 <code>$SKIP_INSTALL</code> = <code>NO</code>，那么 <code>$TARGET_BUILD_DIR</code> = <code>$INSTALL_DIR</code> = <code>$DSTROOT/$INSTALL_PATH</code>。其中，<code>$DSTROOT</code> 的 display name 是 <code>Installation Build Products Location</code>，<code>$INSTALL_PATH</code> 的 display name 是 <code>Installation Directory</code>。另外需要注意，为了拼接出一个有效的 <code>$INSTALL_DIR</code>，<code>$INSTALL_PATH</code> 必须以 <code>/</code> 开头。</p>
<p>2.2. 如果 <code>$SKIP_INSTALL</code> = <code>YES</code>，那么 <code>$TARGET_BUILD_DIR</code> = <code>$TARGET_TEMP_DIR/UninstalledProducts</code>。</p>
<p>一般需要 deploy 的时候，都是设置 <code>$SKIP_INSTALL</code> 为 <code>NO</code>，然后设置具体的 <code>$DSTROOT</code> 和 <code>$INSTALL_PATH</code>，所以这里忽略对 <code>$TARGET_TEMP_DIR</code> 理解。</p>
</li>
</ul>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p>假设一个 Project 的路径是 <code>XXX/ProjectX</code>。</p>
<p>当 build 完成后，我们会关注 2 个与 <strong>Product Files</strong> 有关的 settings ：</p>]]>
    
    </summary>
    
      <category term="Xcode" scheme="https://hi.zongquan.wang/tags/Xcode/"/>
    
      <category term="Development" scheme="https://hi.zongquan.wang/categories/Development/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[How to get File Attributes in Mac]]></title>
    <link href="https://hi.zongquan.wang/2015/01/22/How_to_get_File_Attributes_in_Mac/"/>
    <id>https://hi.zongquan.wang/2015/01/22/How_to_get_File_Attributes_in_Mac/</id>
    <published>2015-01-22T07:16:18.000Z</published>
    <updated>2016-12-12T11:53:12.000Z</updated>
    <content type="html"><![CDATA[<h4 id="Mac_File_Attributes">Mac File Attributes</h4><p>在 Mac 开发中，想要获取 file 或者 dir 的属性，有这么4种方式：</p>
<a id="more"></a>
<ul>
<li><p><strong>Linux C api</strong></p>
<p>  <code>int lstat(const char *restrict path, struct stat *restrict buf)</code></p>
<p>  获取到的 stat 有如下属性：</p>
<pre><code><span class="keyword">struct</span> stat { <span class="comment">/* when _DARWIN_FEATURE_64_BIT_INODE is defined */</span>
    <span class="keyword">dev_t</span>           st_dev;           <span class="comment">/* ID of device containing file */</span>
    <span class="keyword">mode_t</span>          st_mode;          <span class="comment">/* Mode of file (see below) */</span>
    <span class="keyword">nlink_t</span>         st_nlink;         <span class="comment">/* Number of hard links */</span>
    <span class="keyword">ino_t</span>           st_ino;           <span class="comment">/* File serial number */</span>
    <span class="keyword">uid_t</span>           st_uid;           <span class="comment">/* User ID of the file */</span>
    <span class="keyword">gid_t</span>           st_gid;           <span class="comment">/* Group ID of the file */</span>
    <span class="keyword">dev_t</span>           st_rdev;          <span class="comment">/* Device ID */</span>
    <span class="keyword">struct</span> timespec st_atimespec;     <span class="comment">/* time of last access */</span>
    <span class="keyword">struct</span> timespec st_mtimespec;     <span class="comment">/* time of last data modification */</span>
    <span class="keyword">struct</span> timespec st_ctimespec;     <span class="comment">/* time of last status change */</span>
    <span class="keyword">struct</span> timespec st_birthtimespec; <span class="comment">/* time of file creation(birth) */</span>
    <span class="keyword">off_t</span>           st_size;          <span class="comment">/* file size, in bytes */</span>
    <span class="keyword">blkcnt_t</span>        st_blocks;        <span class="comment">/* blocks allocated for file */</span>
    <span class="keyword">blksize_t</span>       st_blksize;       <span class="comment">/* optimal blocksize for I/O */</span>
    <span class="keyword">uint32_t</span>        st_flags;         <span class="comment">/* user defined flags for file */</span>
    <span class="keyword">uint32_t</span>        st_gen;           <span class="comment">/* file generation number */</span>
};
</code></pre></li>
</ul>
<ul>
<li><p><strong>Metadata</strong></p>
<p>  这种方式是基于 Spotlight 的，优点是在访问大量文件时速度快，缺点是要依赖 Spotlight 功能的开启。当 Spotlight 获取到 item 的 metadata 后，就可以通过下面2种方法来获取这些 metadata：</p>
<ul>
<li><p><code>CFTypeRef MDItemCopyAttribute(MDItemRef item, CFStringRef name)</code>，metadata attribute key 格式为 kMDItemXXX，详见文档。</p>
</li>
<li><p><code>NSMetadataQuery</code>，通过执行 Spotlight 查询来获取 result，metadata attribute key 格式同上。</p>
<p><strong>注意</strong>，这种方式是基于 Spotlight 获取到了这些 metadata，否则拿到的值可能就是 NULL 了。</p>
<p><strong>另外</strong>，在 terminal 中，这种方式也有相应的命令 <code>mdls</code> 可以使用。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>NSFileManager</strong></p>
<p>  通过调用 NSFileManager 的 <code>attributesOfItemAtPath:error:</code> 也可以拿到 file 的 attribute，attribute key 格式为 <code>NSFileXXX</code>，详见文档。</p>
</li>
</ul>
<ul>
<li><p><strong>NSURL</strong></p>
<p>  通过调用 NSURL 的 <code>getResourceValue:forKey:error:</code> 也可以拿到 file 的 attribute，resource key 格式为 <code>NSURLXXX</code>，详见文档。对比采用 NSFileManager，这种方式以 URL 的形式来访问该 file，拿到的 attribute 比 NSFileManager 也多。<strong>推荐使用。</strong></p>
</li>
</ul>
<h4 id="这里顺便提一下关于_delete_file/dir_的一点注意事项">这里顺便提一下关于 delete file/dir 的一点注意事项</h4><p>首先，NSFileManager 有一个判断 file/dir 能否删除的 api：<code>isDeletableFileAtPath:</code>，其次，还有一个负责删除的 api：<code>removeItemAtPath:error:</code>。</p>
<p>那么问题来了，<code>isDeletableFileAtPath:</code> 和 <code>removeItemAtPath:error:</code> 的行为不太一致！</p>
<p><code>removeItemAtPath:error:</code> 总是能够做出正确的行为，即能删除的话就删除，不能删除的话就不会删除。但是，<code>isDeletableFileAtPath:</code> 有时候不能做出正确的判断。</p>
<ul>
<li><p>对于 file 来说，<code>isDeletableFileAtPath:</code> 总是可以做出正确的判断，这个没问题。</p>
<p>  也就是说，根据 Apple 文档，当 file 的 parent dir 具有可写权限时，file 就是 deletable 的，不管 file 本身的权限如何。否则，就是 undeletable 的。</p>
</li>
<li><p>对于 dir 来说，就会出现刚才说的问题。</p>
<p>  理论上，根据 Apple 文档，除了判断 parent dir 的可写权限之外，<code>isDeletableFileAtPath:</code> 还会递归地去判断 child item，只有所有的 child item 都是 deletable 时，才会返回 YES。</p>
<p>  但是，事实上，<code>isDeletableFileAtPath:</code> 貌似没有去递归地检查 child item。</p>
<p>  举例说明，有这么一个 path：<user_dir>/<root_dir>/<file_no_matter_root_or_user>，path 中的名称标明了对应的权限。现在用 <code>isDeletableFileAtPath:</code> 去检查 <root_dir>。</root_dir></file_no_matter_root_or_user></root_dir></user_dir></p>
<p>  理论上，<root_dir> 中有个 <file_no_matter_root_or_user>，而 <file_no_matter_root_or_user> 是 undeletable 的（因为它的 parent dir <root_dir> 是 root 的，普通用户没有可写权限），所以 <root_dir> 就是 undeletable 的，所以应该返回 NO。但是 <code>isDeletableFileAtPath:</code> 返回的却是 YES。此时如果调用 <code>removeItemAtPath:error:</code> 去删除 <root_dir> 时，就会出现 error，提示没有权限。也就是说，<code>removeItemAtPath:error:</code> 跟实际情况是一致的，但 <code>isDeletableFileAtPath:</code> 却做出了错误的判断。所以对于这种情况，你需要手动地去递归调用 <code>isDeletableFileAtPath:</code> 来检查 <root_dir>。</root_dir></root_dir></root_dir></root_dir></file_no_matter_root_or_user></file_no_matter_root_or_user></root_dir></p>
<p>  感觉好坑啊，难道打开的姿势不对~~</p>
</li>
</ul>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="Mac_File_Attributes">Mac File Attributes</h4><p>在 Mac 开发中，想要获取 file 或者 dir 的属性，有这么4种方式：</p>]]>
    
    </summary>
    
      <category term="Mac" scheme="https://hi.zongquan.wang/tags/Mac/"/>
    
      <category term="Development" scheme="https://hi.zongquan.wang/categories/Development/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Study iOS - Hardware]]></title>
    <link href="https://hi.zongquan.wang/2015/01/18/Study_iOS_Hardware/"/>
    <id>https://hi.zongquan.wang/2015/01/18/Study_iOS_Hardware/</id>
    <published>2015-01-18T07:42:25.000Z</published>
    <updated>2016-12-12T11:53:12.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：Hardware">Developing Applications for iOS 观后感系列：Hardware</h3><p><em>相关视频章节：14、17</em></p>
<a id="more"></a>
<hr>
<p>关于 iOS device 的 hardware，本篇主要了解2个方面：CoreLocation + CoreMotion</p>
<h3 id="CoreLocation">CoreLocation</h3><ul>
<li><p><strong><code>CLLocation</code></strong>：CoreLocation 中最基本的 class。</p>
<p>  CLLocation 的重要 property：</p>
<p>  <em><code>coordinate</code></em>：位置坐标，包含 latitude 和 longitude 两个元素。</p>
<p>  <em><code>altitude</code></em>：海拔。</p>
<p>  <em><code>horizontal/verticalAccuracy</code></em>：精度。Cellular &lt; WiFi &lt; GPS。</p>
</li>
<li><p><strong><code>CLLocationManager</code></strong>：用于获取 CLLocation。</p>
<p>  使用流程：</p>
<ol>
<li><p><em><code>check device</code></em></p>
<p> 主要是检查 device 是否支持以某种方式来获取某种 location，以及是否有权限来获取。</p>
<p> 关于权限，有3中状态：Authorized、Denied、Restricted。</p>
</li>
<li><p><em><code>init &amp; delegate</code></em>：通过 CLLocationManager 来获取 CLLocation 可以有2种方式，一种是主动 ask（poll），一种是 delegate。通常采用 delegate 的方式，delegate 触发后，你就可以访问 CLLocationManager 的 property <em><code>location</code></em> 来获取当前的 CLLocation 了。</p>
</li>
<li><p><em><code>configuration</code></em></p>
<p> 通过 property <em><code>desiredAccuracy</code></em> 来设定想要的精度。</p>
<p> 通过 property <em><code>distanceFilter</code></em> 告诉 CLLocationManager，只有当 location 的变化超过该范围时，才去触发 update delegate。</p>
</li>
<li><p><em><code>start monitor</code></em></p>
<p> 你可以进行如下几种形式的 monitor，每种 monitor 都有相应的 delegate 函数，参见文档。</p>
<ul>
<li><p><em><code>normal monitor</code></em>：standard monitor，通过设定精度，每当 update 触发时，就会通知 app。</p>
</li>
<li><p><em><code>significant change monitor</code></em>：仅当 location 发生明显变化时才通知 app，这里的 significant 并未定义具体是多少。</p>
</li>
<li><p><em><code>region monitor</code></em>：当 device 进入某个指定的 region 时，通知 app。</p>
</li>
<li><p><em><code>beacon monitor</code></em>：当 device 进入某个指定的 beacon 时，通知 app，这种 monitor 通常与 <em><code>Core Bluetooth</code></em> 相关。</p>
</li>
</ul>
<p><strong>注意</strong>，当你不再需要 monitor 时，不要忘了 stop monitor。</p>
<p><strong>注意</strong>，即使 app not running，这些 monitor 也还是能够 work 的。想要在 background 模式下继续 monitor，需要在 project 中设置一下，类似于 background fetch 的设置。当 delegate 触发后，app 就会被启动。这种情况下，<code>application:didFinishLaunchingWithOption:</code> 的 option dictionary 中就会包含一个 key <code>UIApplicationLaunchOptionsLocationKey</code>。</p>
</li>
</ol>
</li>
</ul>
<h3 id="CoreMotion">CoreMotion</h3><p>主要用于获取各种 motion sensor 的信息，如 accelerometer、gyro、magnetometer 等等。</p>
<p>iOS 中提供的 class 是 <em><code>CMMotionManager</code></em>，你可以通过 alloc/init 来获取。<strong>但是注意</strong>，处于性能考虑，每个 app 中只能有一个全局的 CMMotionManager instance，因此你需要创建一个单例模式来实现全局单例。</p>
<p>使用流程：</p>
<ol>
<li><p><em><code>check device</code></em>：检查 device 是否支持获取某种 motion data。</p>
<p> 这里需要提一下，除了 accelerometer、gyro、magnetometer 之外，iOS 还提供了一个 <em><code>CMDeviceMotion</code></em>，对前面3种 data 进行了综合封装，可以通过它一次性获取这3种 data。</p>
<p> <img src="/img/Study_iOS_Hardware/17.9.CoreMotion.png" alt="CoreMotion"></p>
<p> <img src="/img/Study_iOS_Hardware/17.10.CoreMotion.png" alt="CoreMotion"></p>
</li>
<li><p><em><code>start &amp; get motion data</code></em>：有两种获取 motion data 的方式：</p>
<ul>
<li><p>主动 ask（poll）：<em><code>start/stopXXXUpdates</code></em></p>
</li>
<li><p>通过设置 rate，注册 callback，被动接收。</p>
<p>  <img src="/img/Study_iOS_Hardware/17.11.CoreMotion.png" alt="CoreMotion"></p>
<p>  <img src="/img/Study_iOS_Hardware/17.12.CoreMotion.png" alt="CoreMotion"></p>
<p>  <img src="/img/Study_iOS_Hardware/17.13.CoreMotion.png" alt="CoreMotion"></p>
</li>
</ul>
</li>
</ol>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：Hardware">Developing Applications for iOS 观后感系列：Hardware</h3><p><em>相关视频章节：14、17</em></p>]]>
    
    </summary>
    
      <category term="iOS" scheme="https://hi.zongquan.wang/tags/iOS/"/>
    
      <category term="Development" scheme="https://hi.zongquan.wang/categories/Development/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Study iOS - L18N]]></title>
    <link href="https://hi.zongquan.wang/2015/01/18/Study_iOS_L18N/"/>
    <id>https://hi.zongquan.wang/2015/01/18/Study_iOS_L18N/</id>
    <published>2015-01-18T05:35:11.000Z</published>
    <updated>2016-12-12T11:53:12.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：L18N">Developing Applications for iOS 观后感系列：L18N</h3><p><em>相关视频章节：18</em></p>
<a id="more"></a>
<hr>
<p>L18N 主要涉及2方面：Xcode + code。</p>
<ul>
<li><p><strong>Xcode</strong></p>
<p>  首先需要在 Xcode 中设置 app 支持的语言：</p>
<p>  <img src="/img/Study_iOS_L18N/18.1.L18N.png" alt="L18N"></p>
<p>  然后你就可以对 storyboard 进行 L18N了，Xcode 会生成相应语言的 .strings 文件。</p>
</li>
<li><p><strong>code</strong></p>
<p>  对于不在 storyboard 中的 strings 如何 L18N 呢？那就得通过 code 来处理了。</p>
<p>  <img src="/img/Study_iOS_L18N/18.2.L18N.png" alt="L18N"></p>
<p>  在代码中调用上述 macros 之后，可以通过下面命令自动生成 .strings 文件：</p>
<p>  <img src="/img/Study_iOS_L18N/18.3.L18N.png" alt="L18N"></p>
<p>  <strong>注意</strong>，当你从 <em><code>Bundle</code></em> 中获取某个文件的 path 时，其搜索顺序是：先 bundle 的 top-level 层，后 .lproj 层。</p>
</li>
</ul>
<h3 id="Locale">Locale</h3><p>提到 L18N，就不得不提 Locale，因为它是整个 L18N 得以实现的基础。此外，Locale 也决定了 date 和 number 的格式。</p>
<p><strong>注意</strong>，Locale 和 language 不是等价的，language 一样的时候，Locale 不一定一样。</p>
<ul>
<li><p><strong><code>NSLocale</code></strong>：iOS 中主要靠该 class 来获取 Locale 相关的信息，该 class 知道如何设定不同格式的 date 和 number。也就是说，对 date 和 number 的设定主要就是给他们传递对应的 NSLocale 参数。</p>
</li>
<li><p><strong><code>NSNumberFormatter</code></strong></p>
<p>  <img src="/img/Study_iOS_L18N/18.6.L18N.NSNumberFormatter.png" alt="L18N"></p>
</li>
<li><p><strong><code>NSDateFormatter</code></strong></p>
<p>  <img src="/img/Study_iOS_L18N/18.7.L18N.NSDateFormatter.png" alt="L18N"></p>
</li>
<li><p><strong><code>NSString</code></strong></p>
<p>  <img src="/img/Study_iOS_L18N/18.8.L18N.NSString.png" alt="L18N"></p>
</li>
<li><p><strong><code>UIImage</code></strong></p>
<p>  当你调用 UIImage 的 <code>imageNamed:*</code> 时，它也是会去搜索相应的 .lproj 目录的。</p>
</li>
</ul>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：L18N">Developing Applications for iOS 观后感系列：L18N</h3><p><em>相关视频章节：18</em></p>]]>
    
    </summary>
    
      <category term="iOS" scheme="https://hi.zongquan.wang/tags/iOS/"/>
    
      <category term="Development" scheme="https://hi.zongquan.wang/categories/Development/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Study iOS - Misc UI]]></title>
    <link href="https://hi.zongquan.wang/2015/01/17/Study_iOS_Misc_UI/"/>
    <id>https://hi.zongquan.wang/2015/01/17/Study_iOS_Misc_UI/</id>
    <published>2015-01-17T07:30:03.000Z</published>
    <updated>2016-12-12T11:53:12.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：Misc_UI">Developing Applications for iOS 观后感系列：Misc UI</h3><p><em>相关视频章节：all</em></p>
<a id="more"></a>
<hr>
<p>之前的文章已经学习了几种 iOS 中比较大而重要的 UIView，例如 UIScrollView、UITableView 等，本篇主要了解一下其它一些比较常用的小型 UI 类型。</p>
<h3 id="UITextView">UITextView</h3><p><strong><code>UITextView</code></strong> 提供了一个 multi-line、selectable、editable、scrollable 的编辑区，通过 <em><code>NSMutableAttributedString</code></em> 来设定它的文本内容和各种属性。</p>
<p>UITextView 有3个比较重要的 property，它们共同完成整个 UITextView 内容的显示。</p>
<ul>
<li><p><em><code>textStorage</code></em>：NSTextStorage 是 NSMutableAttributedString 的 subclass，也就是说，UITextView 的文本内容和文本属性是通过该 property 来决定的，对其赋值什么样的 NSMutableAttributedString，就会显示什么样的内容。</p>
</li>
<li><p><em><code>textContainer</code></em>：NSTextContainer 决定了 NSTextStorage 将会布局在整个 UITextView 的哪个区域中，即 where text can be。你甚至可以通过它来指定一个 <em><code>exclusion zones</code></em>（例如一个 image），这样 NSTextStorage 就会围绕这个 exclusion  zones 来布局，如同 Word 中的图片环绕效果，灰常 NB。</p>
</li>
<li><p><em><code>layoutManager</code></em>：前面2个 property，一个决定内容，一个决定样式，那么剩下的 NSLayoutManager 就是负责从 NSTextStorage 中获取到 text，然后将它们 lay down 到 NSTextContainer 设定的有效区域中。</p>
</li>
</ul>
<h3 id="UITextField">UITextField</h3><p><strong><code>UITextField</code></strong> 就像是 UILabel 的升级版，它是 editable 的。这里主要了解下 <em><code>UITextFieldDelegate</code></em> 以及 <em><code>Keyboard</code></em> 的使用。当然 UITextView 也有这些东西，这里就不赘述了。</p>
<ul>
<li><p>当 UITextField 成为 <em><code>first responder</code></em> 时，iOS 的 Keyboard 就会自动弹出。有2种方式可以实现：</p>
<ol>
<li><p>用户点击 UITextField，它自动就会变成 first responder。</p>
</li>
<li><p>通过代码主动调用 <em><code>becomeFirstResponder</code></em>。</p>
<p>反过来，想要让 Keyboard 收回，调用 <em><code>resignFirstResponder</code></em> 即可。</p>
</li>
</ol>
</li>
<li><p><em><code>UITextFieldDelegate</code></em>，举几个例子：</p>
<p>  <code>-(BOOL)textFieldShouldReturn:(UITextField *)textField</code>：当用户按下 Return 键后，该 delegate 就会触发。在这里，除了返回 BOOL，通常你还会调用 [textField resignFirstResponder] 来收回 Keyboard。</p>
<p>  <code>-(void)textFieldDidEndEditing:(UITextField *)textField</code>：当 UITextField resign first responder 后，该 delegate 就会触发。在这里，你可以利用新的 UITextField 来 update UI。</p>
</li>
<li><p>UITextField 还有几个相关的 <em><code>Notifications</code></em>，用于实时反馈 UITextField 当前的状态。例如<br>UITextFieldTextDidChangeNotification。</p>
</li>
<li><p><em><code>target-action</code></em>：UITextField 也是个 UIControl，所以你可以对其设定 target-action。UITextField 有许多 UIControlEvents 供设定，具体参见在 Xcode 中右击 UITextField 显示的菜单。</p>
</li>
<li><p><em><code>Keyboard</code></em></p>
<p>  一般来说，我们提到 Keyboard 时，总是指通过某个 UITextField 或者 UITextView 而弹出来的那个 Keyboard，两者是相关的，对该 Keyboard 的设置通常就是通过与其相关的那个 UITextField 或者 UITextView 来设定的。</p>
<p>  如何控制 Keyboard 的外观：通过 <em><code>UITextInputTraits</code></em> 这个 protocol。UITextField 和 UITextView 已经实现了。该 protocol 中有若干 property 用于自定义你的 Keyboard。</p>
<p>  你可以给 Keyboard 添加一个 accessory view 来实现自定义的 toolbar，通过设置 UITextField 的 property <em><code>inputAccessoryView</code></em> 来完成。此外，UITextField 还有些其它的 accessory view，例如 left view、right view、clear button 等等。</p>
<p>  <strong>注意</strong>，Keyboard 出现时，总是会 cover 其它 view，所以，你需要自己来处理 Keyboard 弹出后的 UI 布局。例如移动位置等等。你可以通过 <em><code>UIKeyboardXXXNotification</code></em> 来获取 Keyboard 的状态，从而做出响应。例如，如果 UITableView 中有个 UITextField，那么 UITableViewController 就需要监听 UIKeyboardDidShowNotification，这样当用户编辑某行的 UITextField 导致 Keyboard 弹出时，table 可以进行 scroll，从而保证该行不会被 Keyboard 覆盖。</p>
</li>
</ul>
<h3 id="UIActionSheet">UIActionSheet</h3><p><strong><code>UIActionSheet</code></strong> 用于呈现一个选择列表。通常是从屏幕下方弹出，让用户做出选择。</p>
<ul>
<li><p><em><code>init</code></em>：<code>initWithTitle:delegate:cancelButtonTitle:destructiveButtonTitle:otherButtonTitles:</code>，其中，destructiveButton 会显示为红色，用于警示用户该操作的严重性。其它 button 为普通颜色。</p>
</li>
<li><p><em><code>button</code></em>：init 之后，你还可以通过 <code>addButtonWithTitle:</code> 继续给 action sheet 添加其它普通 button。之后想要获取 action sheet 中的这些 button 时，可以通过 action sheet 的这些 property 来完成：<em><code>cancelButtonIndex</code></em>、<em><code>destructiveButtonIndex</code></em>、<em><code>numberOfButtons</code></em>、<em><code>buttonTitleAtIndex:</code></em> 等等。</p>
</li>
<li><p><em><code>display</code></em>：</p>
<ul>
<li><p><code>[actionSheet showInView:]</code></p>
</li>
<li><p><code>[actionSheet showFromBarButtonItem:animated:]</code>，<strong>这里需要注意一点</strong>，对于这种 display 方式（通常是在 iPad 中），action sheet 是显示在一个 popover 中的，是不会显示 cancel button 的，显然这是合理的，因为点击屏幕其它地方后 popover 就可以自己消失。但是别忘了，popover 有个 passthroughViews，点击这里面的 view 不会让 popover 消失，而 bar button item 是在 passthroughViews 中的，所以，如果你不停地点击它，就会不停地叠加 action sheet。所以这里需要你手动处理下，保证只弹出一个 action sheet。</p>
</li>
<li><p><code>[actionSheet showFromRect:inView:animated:]</code></p>
</li>
</ul>
</li>
<li><p><em><code>delegate</code></em>：通过 delegate，你可以知道用户点击的是哪个 button，即 <code>actionSheet:didDismissWithButtonIndex:</code>。</p>
<p>  此外，你可以通过 code 手动触发点击某个 button 这种行为，即 <code>dismissWithClickedButtonIndex:animated:</code>。</p>
</li>
</ul>
<h3 id="UIAlertView">UIAlertView</h3><p><strong><code>UIAlertView</code></strong> 与 UIActionSheet 很相似，具有相似的 init 方式、添加新 button 的函数等。这里只了解几点不同的地方。</p>
<ul>
<li><p><em><code>display</code></em>：只有一种方式，即 <code>[alert show]</code>，alert 就会显示在屏幕中间。</p>
</li>
<li><p><em><code>add UITextField</code></em>：你可以在 UIAlertView 中添加 UITextField，让用户在其中输入，例如登录框。方法是设置 UIAlertView 的 property <em><code>alertViewStyle</code></em>。</p>
</li>
</ul>
<h3 id="UIImagePickerController">UIImagePickerController</h3><p><strong><code>UIImagePickerController</code></strong> 用于呈现一个 Modal view，让用户选择一张照片（photo library 中已有的照片，或者用 camera 新拍一张照片），然后将该照片返回供 app 使用。</p>
<p><strong>注意</strong>，既然是个 Modal view，那就意味着需要这么呈现：通过 <code>Modal Segue</code>，或者调用 <code>presentViewContainer:animated:completion:</code>。参见 <a href="../../../../2015/01/10/Study_iOS_Segue/">Segue</a>。</p>
<p>UIImagePickerController 的使用流程如下：</p>
<ol>
<li><p><em><code>init &amp; delegate</code></em>：delegate 一般设置为 UIImagePickerController 的 presenter。</p>
</li>
<li><p><em><code>configuration</code></em></p>
<p> 主要是设置 UIImagePickerController 的 source type、media type 等等。设置之前，通常需要先进行检查，看看该 device 是否支持要设置的值。</p>
<ul>
<li><p><em><code>source type</code></em>：有的 device 有 camera，有的则没有 camera，只有 photo library。因此你需要检查该 device 是否支持 UIImagePickerController 的某种 source type。通过调用 <code>isSourceTypeAvailable:</code> 即可。</p>
<p>  有3种 source type：UIImagePickerControllerSourceTypePhotoLibrary、UIImagePickerControllerSourceTypeCamera、UIImagePickerControllerSourceTypeSavedPhotosAlbum。</p>
</li>
<li><p><em><code>media type</code></em>：每种 source type 支持的 media type 也不同，有的支持 video，有的只支持 picture。因此 media type 也需要进行检查。通过调用 <code>+(NSArray *)availableMediaTypesForSourceType:</code>即可。</p>
<p>  有2种 media type：kUTTypeImage 和 看UTTypeMovie。</p>
<p>  还有其它一些检查函数，例如检查 front/rear camera 等等，参见文档。</p>
</li>
<li><p><em><code>editability</code></em>：是否允许用户对选取的图片进行编辑。如果允许，UIImagePickerController 会把原始图片和编辑后的图片都返给 app。</p>
</li>
<li><p>其他 configuration，参见文档。</p>
</li>
</ul>
</li>
<li><p><em><code>present</code></em>：前面已经提到了，要采用 Modal view 的呈现方式。</p>
</li>
<li><p><em><code>respond to delegate</code></em></p>
<p> 当用户完成选取照片后：<code>imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary *)info</code>，其中，info 中提供了要返给 app 的图片数据，参见文档。通过 <em><code>ALAssetsLibrary</code></em>，你可以将该图片保存到用户的 photo library。</p>
<p> 当用户取消选取照片后：<code>imagePickerControllerDidCancel:(UIImagePickerController *)picker</code>。</p>
<p> 在用户完成/取消选取照片后，你都需要关闭当前的这个 Modal view，即调用 <code>[self dismissViewControllerAnimated:completion:]</code>。</p>
</li>
</ol>
<h3 id="Settings">Settings</h3><p><strong><code>Settings</code></strong> 指的是 iOS 中的 Settings app，你可以在里面添加自己 app 的设置选项。这个机制利用的是 <em><code>NSUserDefaults</code></em>。</p>
<p>直接上图</p>
<p><img src="/img/Study_iOS_Misc_UI/18.10.Settings.png" alt="Settings"></p>
<p><img src="/img/Study_iOS_Misc_UI/18.11.Settings.png" alt="Settings"></p>
<p><img src="/img/Study_iOS_Misc_UI/18.12.Settings.png" alt="Settings"></p>
<p><img src="/img/Study_iOS_Misc_UI/18.13.Settings.png" alt="Settings"></p>
<p><strong>注意</strong>：code 通常需要监听 NSUserDefaults 的变化，来及时获取 Settings 中新的值。</p>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：Misc_UI">Developing Applications for iOS 观后感系列：Misc UI</h3><p><em>相关视频章节：all</em></p>]]>
    
    </summary>
    
      <category term="iOS" scheme="https://hi.zongquan.wang/tags/iOS/"/>
    
      <category term="Development" scheme="https://hi.zongquan.wang/categories/Development/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Study iOS - CoreData]]></title>
    <link href="https://hi.zongquan.wang/2015/01/11/Study_iOS_CoreData/"/>
    <id>https://hi.zongquan.wang/2015/01/11/Study_iOS_CoreData/</id>
    <published>2015-01-11T08:51:58.000Z</published>
    <updated>2016-12-12T11:53:12.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：CoreData">Developing Applications for iOS 观后感系列：CoreData</h3><p><em>相关视频章节：12，13</em></p>
<a id="more"></a>
<hr>
<p><strong><code>CoreData</code></strong> 是 iOS 提供的一套用于管理 app 的 Model 的 framework，它就像是个 object database，支持对 object 的各种操作：add、delete、query、undo、redo、autosave 等，灰常 NB。但它并不是 database 的某种实现，你可以基于持久化文件（如 sqlite 等）来使用 CoreData，也可以完全基于内存来使用。</p>
<p>使用 CoreData 会涉及 Xcode 和 code 两方面。</p>
<p>首先看一下在 Xcode 中需要做什么。</p>
<h3 id="创建_Data_Model">创建 Data Model</h3><ul>
<li><p>类似于 .storyboard 文件，这里你需要创建一个 <em><code>.xcdatamodeld</code></em> 文件，它存储了 app 的 Data Model。.xcdatamodeld 文件内容如下：</p>
<p>  <img src="/img/Study_iOS_CoreData/12.0.CoreData.png" alt="CoreData"></p>
<p>  就像设计数据库的 ER 图，在这里，你需要设计好 object 对应的 <em><code>Entity</code></em>。这里的 Entity 会对应到 code 中的 <em><code>NSManagedObject（或其 subclass）</code></em>。</p>
<p>  <img src="/img/Study_iOS_CoreData/12.1.CoreData.png" alt="CoreData"></p>
<p>  <img src="/img/Study_iOS_CoreData/12.2.CoreData.png" alt="CoreData"></p>
</li>
<li><p>Model 构建好了之后，下面就需要创建出与这些 Entity 对应的 NSManagedObject，供 code 中使用。</p>
<p>  <img src="/img/Study_iOS_CoreData/12.12.CoreData.Add.png" alt="CoreData"></p>
<p>  <img src="/img/Study_iOS_CoreData/12.13.CoreData.Add.png" alt="CoreData"></p>
<p>  这样我们就可以直接使用这些 NSManagedObject subclass 了，而且也可以方便地访问它们的 properties，而不用去调用繁琐的 valueForKey 和 setValue:forKey。</p>
<p>  <strong>注意</strong>，以后当我们修改了 Model 的 Entity 后，需要重新执行一遍这一步，来更新这些 NSManagedObject subclass。这也意味着，这些 .h 和 .m 会被重新生成。所以这里常常使用的一个技巧是，为这些 NSManagedObject subclass 添加 <em><code>category</code></em>，在 category 中创建一些额外的函数供 NSManagedObject subclass 使用，这样以后更新 NSManagedObject subclass 时，只有最原本的 .h 和 .m 文件被重新生成，而不会影响到我们的 category。</p>
</li>
</ul>
<p>Xcode 这边基本就完成了，下面开始进入 code。</p>
<h3 id="NSManagedObjectContext">NSManagedObjectContext</h3><p>CoreData 的基本要素就是 NSManagedObject。那么如何获取我们的 NSManagedObject 呢？答案就是从 <em><code>NSManagedObjectContext</code></em> 中获取。</p>
<p>有2种方式来获取这个 NSManagedObjectContext：</p>
<ol>
<li><p>创建一个 <em><code>UIManagedDocument</code></em>，它里面有个 property：managedObjectContext。Bingo！</p>
</li>
<li><p>当创建 project 时，下面有个选项：<em><code>&quot;Use Core Data&quot;</code></em>，如果选中这个选项，那么 Xcode 会在 <em><code>AppDelegate</code></em> 中给你提供一个 property：managedObjectContext。以后 code 中访问它就行了。</p>
</li>
</ol>
<p>本篇主要涉及第1种方式，下面就理解一下 UIManagedDocument。</p>
<h3 id="UIManagedDocument">UIManagedDocument</h3><p>UIManagedDocument 是 <em><code>UIDocument</code></em> 的 subclass，提供了管理存储内容的机制。它也支持 iCloud，可以把它理解成 CoreData Model 的一个容器。</p>
<ul>
<li><p><strong>创建 UIManagedDocument</strong>：</p>
<pre><code><span class="built_in">NSURL</span> *documentsDir = [[[<span class="built_in">NSFileManager</span> defaultManager] URLsForDirectory:<span class="built_in">NSDocumentDirectory</span>
                                                              inDomains:<span class="built_in">NSUserDomainMask</span>] firstObject];
<span class="built_in">NSString</span> *managedDocumentName = <span class="string">@"XXX"</span>;
<span class="built_in">NSURL</span> *managedDocumentURL = [documentsDir URLByAppendingPathComponent:managedDocumentName];
<span class="built_in">UIManagedDocument</span> *managedDocument = [[<span class="built_in">UIManagedDocument</span> alloc] initWithFileURL:managedDocumentURL];
</code></pre><p>  上面只是在内存中创建了一个 UIManagedDocument instance，想要从中获取 NSManagedObjectContext，你还需要下面操作。</p>
</li>
<li><p><strong>通过 open / create UIManagedDocument 来获取 NSManagedObjectContext</strong></p>
<pre><code><span class="keyword">if</span> ([[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:[managedDocumentURL path]]) {
    [managedDocument openWithCompletionHandler:^(<span class="built_in">BOOL</span> success) {
        <span class="keyword">if</span> (success) {
            [<span class="keyword">self</span> documentIsReady];
        }
    }];
} <span class="keyword">else</span> {
    [managedDocument saveToURL:managedDocumentURL
              forSaveOperation:<span class="built_in">UIDocumentSaveForCreating</span>
             completionHandler:^(<span class="built_in">BOOL</span> success) {
                 <span class="keyword">if</span> (success) {
                    [<span class="keyword">self</span> documentIsReady];
                }
             }];
}

-(<span class="keyword">void</span>)documentIsReady
{
    <span class="keyword">if</span> (managedDocument<span class="variable">.documentState</span> == <span class="built_in">UIDocumentStateNormal</span>) {
        <span class="built_in">NSManagedObjectContext</span> *context = managedDocument<span class="variable">.managedObjectContext</span>;
        <span class="comment">// use the context to do Core Data stuff</span>
    }
}
</code></pre><p>  上面示例中注意2点：</p>
<p>  为什么需要 <em><code>completionHandler</code></em>？因为 open/save 操作是 <em><code>asynchronous</code></em>（想想看，iCloud 必须要 asynchronous）。</p>
<p>  关于 check <em><code>documentState</code></em>，还有其它一些取值，参见文档。</p>
</li>
<li><p><strong>保存和关闭</strong></p>
<p>  <img src="/img/Study_iOS_CoreData/12.7.UIManagedDocument.png" alt="CoreData"></p>
<p>  虽然 NSManagedObjectContext 是 autosave 的，但你是可以观察到这一动作的：</p>
<p>  <img src="/img/Study_iOS_CoreData/12.8.UIManagedDocument.png" alt="CoreData"></p>
</li>
</ul>
<p>好了，UIManagedDocument 有了，NSManagedObjectContext 也有了，现在轮到 NSManagedObject 了。</p>
<h3 id="NSManagedObject_的_Add">NSManagedObject 的 Add</h3><p><img src="/img/Study_iOS_CoreData/12.14.CoreData.Add.png" alt="CoreData"></p>
<h3 id="NSManagedObject_的_Delete">NSManagedObject 的 Delete</h3><p><img src="/img/Study_iOS_CoreData/12.17.CoreData.Delete.png" alt="CoreData"></p>
<p><strong>注意</strong>，不管是 Add 还是 Delete，这些 change 都是发生在内存中的，直到你手动 save 或由 UIManagedDocument 自己来 autosave。</p>
<h3 id="NSManagedObject_的_Query">NSManagedObject 的 Query</h3><p>query 操作是由 <em><code>NSFetchRequest</code></em> 来完成的。创建 NSFetchRequest 需要一下4点：</p>
<ul>
<li>指定要 fetch 的 Entity。</li>
<li>指定 fetch 结果集的大小，默认是所有。</li>
<li>指定 NSSortDescriptor 对结果集进行排序。</li>
<li>指定 NSPredicate 对结果集进行过滤，默认是所有。</li>
</ul>
<p>(关于 <em><code>NSSortDescriptor</code></em> 和 <em><code>NSPredicate</code></em>，参见文档。)</p>
<p>创建好 NSFetchRequest 后，就可以调用 <code>NSArray *results = [context executeFetchRequest:request error:&amp;error]</code> 来获取结果了。</p>
<p><strong>注意</strong>，出于内存优化，CoreData 在 execute NSFetchRequest 时采用了 <em><code>lazy load</code></em> 的机制，它不会一次性地把 results 中的所有 NSManagedObject 都加载到内存中，而是等到你真正地访问其中的某个 NSManagedObject 时，才会进行加载。</p>
<h3 id="CoreData_的_Thread_Safety">CoreData 的 Thread Safety</h3><p><strong>NSManagedObjectContext 不是线程安全的</strong>，不过 CoreData 一般非常高效，所以没必要去多线程操作（例如查询）。</p>
<p><strong>这里需要注意</strong>，NSManagedObjectContext 在哪个 queue 上创建，你就只能在那个 queue 上访问 NSManagedObjectContext 以及它的 NSManagedObject。很可能就是在 main Q 上。</p>
<p>鉴于上面这个问题，NSManagedObjectContext 提供了一个线程安全的 API：</p>
<pre><code>[context <span class="symbol">performBlock:</span>^{
    <span class="regexp">//</span> <span class="keyword">do</span> stuff <span class="keyword">with</span> <span class="constant">NSManagedObjectContext</span> &amp; <span class="constant">NSManagedObject</span>
}]
</code></pre><p><strong>context 会在自己的 safe queue（即被创建的 queue）上来执行 block。</strong> :)</p>
<p>CoreData 本身就先提这些，下面还有个比较重要的话题。</p>
<h3 id="CoreData_&amp;_UITableView">CoreData &amp; UITableView</h3><p>CoreData 中的数据通常会显示到 UITableView 上，因此 iOS 为我们提供了 <em><code>NSFetchedResultsController</code></em>，用于把 NSFetchRequest hook 到 UITableView 上，实现 CoreData 到 UITableView 上的自动映射。</p>
<ul>
<li><p><strong>NSFetchedResultsController 提供 UITableViewDataSource</strong></p>
<pre><code>-(<span class="built_in">NSUInteger</span>)numberOfSectionsInTableView:(<span class="built_in">UITableView</span> *)sender
{
    <span class="keyword">return</span> [[<span class="keyword">self</span><span class="variable">.fetchedResultsController</span> sections] count];
}

-(<span class="built_in">NSUInteger</span>)tableView:(<span class="built_in">UITableView</span> *)sender numberOfRowsInSection:(<span class="built_in">NSUInteger</span>)section
{
    <span class="keyword">return</span> [[[<span class="keyword">self</span><span class="variable">.fetchedResultsController</span> sections] objectAtIndex:section] numberOfObjects];
}

-(<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)sender
        cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath
{
    <span class="built_in">UITableViewCell</span> *cell = XXX;
    <span class="built_in">NSManagedObject</span> *managedObject = [<span class="keyword">self</span><span class="variable">.fetchedResultsController</span> objectAtIndexPath:indexPath];
    <span class="comment">// setup</span>
    <span class="keyword">return</span> cell;
}
</code></pre><p>  上面需要注意的就是 NSFetchedResultsController 的一个 API：</p>
<p>  <code>-(NSManagedObject *)objectAtIndexPath:(NSIndexPath *)indexPath</code></p>
<p>  也就是说，NSFetchedResultsController 以某种方式将结果集的结构封装的跟 UITableView 的 DataSource 一样，也有个 NSIndexPath。</p>
<p>  那么 NSFetchedResultsController 该如何创建呢？</p>
</li>
<li><p><strong>创建 NSFetchedResultsController</strong></p>
<p>  <img src="/img/Study_iOS_CoreData/13.2.NSFetchedResultsController.png" alt="CoreData"></p>
<p>  <strong>需要注意的是</strong>：NSFetchRequest 中的 sortDescriptor 一定要与 NSFetchedResultsController init 函数中的 sectionNameKeyPath 匹配，这样 NSFetchedResultsController 才能正确地构造出前面提到的 NSIndexPath。<strong>此外</strong>，调用 init 函数后，你就不能再去修改 NSFetchedResultsController 的 fetchRequest 的属性了（例如修改 sortDescriptor 和 predicate）。</p>
</li>
<li><p><strong>通过 NSFetchedResultsController 执行 query</strong></p>
<p>  调用 NSFetchedResultsController 的函数 <code>-(BOOL)performFetch:(NSError **)error</code>，即可实现手动 fetch，这之后，通常伴随着 UITableView 的 reload。</p>
<p>  除了手动 fetch，NSFetchedResultsController 更重要的功能是自动捕获 CoreData 的变化，并以此更新 UITableView。想要实现这一点，需要下面的东西。</p>
</li>
<li><p><strong>NSFetchedResultsControllerDelegate</strong></p>
<p>  当给 NSFetchedResultsController 指定 delegate 后，它就会 keep tracking 自己的 NSFetchRequest，并将更新报告给它的 delegate。显然，在这里，它的 delegate 应该指定为 UITableViewController。如果不指定 delegate，它就不会实现这种机制。</p>
<p>  主要有这些 delegate 函数：</p>
<ul>
<li><p><code>controller:didChangeObject:atIndexPath:forChangeType:newIndexPath:</code>：track 单个 object 的更新（add、remove、move、update）</p>
</li>
<li><p><code>controller:didChangeSection:atIndex:forChangeType:</code>：track 某个 section 的 add 或 remove</p>
</li>
<li><p><code>-controllerDidChangeContent:</code>：track 整个 NSFetchRequest</p>
</li>
</ul>
</li>
</ul>
<p>参见文档 sample code。</p>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：CoreData">Developing Applications for iOS 观后感系列：CoreData</h3><p><em>相关视频章节：12，13</em></p>]]>
    
    </summary>
    
      <category term="iOS" scheme="https://hi.zongquan.wang/tags/iOS/"/>
    
      <category term="Development" scheme="https://hi.zongquan.wang/categories/Development/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Study iOS - UITableView]]></title>
    <link href="https://hi.zongquan.wang/2015/01/11/Study_iOS_UITableView/"/>
    <id>https://hi.zongquan.wang/2015/01/11/Study_iOS_UITableView/</id>
    <published>2015-01-11T06:42:21.000Z</published>
    <updated>2016-12-12T11:53:12.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：UITableView">Developing Applications for iOS 观后感系列：UITableView</h3><p><em>相关视频章节：11</em></p>
<a id="more"></a>
<hr>
<h4 id="UITableView_分类">UITableView 分类</h4><p>按内容分：</p>
<ul>
<li><p><em><code>dynamic</code></em>：在 storyboard 中设定 prototype，在代码中 load 内容。<em>（本篇主要涉及 dynamic NSTableView）</em></p>
</li>
<li><p><em><code>static</code></em>：完全在 storyboard 中设定。</p>
</li>
</ul>
<p>按样式分：</p>
<p><em><code>ungrouped</code></em> / <em><code>grouped</code></em></p>
<p>示例：</p>
<p><img src="/img/Study_iOS_UITableView/11.0.UITableView.png" alt="UITableView"></p>
<h4 id="UITableView_的构成">UITableView 的构成</h4><p>与 Mac 上的NSTableView 不同，iOS 中的 UITableView 都是一维的，只有一列。</p>
<p><img src="/img/Study_iOS_UITableView/11.1.UITableView.png" alt="UITableView"> <img src="/img/Study_iOS_UITableView/11.2.UITableView.png" alt="UITableView"></p>
<h4 id="UITableView_的使用">UITableView 的使用</h4><ol>
<li><p><strong>设定 cell 的 <code>prototype</code></strong></p>
<p> <img src="/img/Study_iOS_UITableView/11.3.UITableView.png" alt="UITableView"></p>
<p> <img src="/img/Study_iOS_UITableView/11.4.UITableView.png" alt="UITableView"></p>
</li>
<li><p><strong>实现 <code>UITableViewDataSource</code></strong></p>
<p> <strong>UITableViewDataSource</strong> 用于控制 what UITableView displays。主要有这些 API：</p>
<ul>
<li><p>基于 prototype，每个 cell 该如何显示在 table 中：</p>
<p>  <img src="/img/Study_iOS_UITableView/11.5.UITableView.png" alt="UITableView"></p>
</li>
<li><p>table 有多少 section，多少 row：</p>
<p>  <img src="/img/Study_iOS_UITableView/11.6.UITableView.png" alt="UITableView"></p>
</li>
</ul>
</li>
<li><p><strong>实现 <code>UITableViewDelegate</code></strong></p>
<p><strong>UITableDelegate</strong> 用于控制 how UITableView displays，以及 observe what UITableView is doing（排序、选择、滚动、插入、删除、更新等等），参见文档。这里简单提几个：</p>
<ul>
<li><p>用户选中某行时，会调用 <em><code>-(void)tableView:didSelectRowAtIndexPath:</code></em></p>
</li>
<li><p>用户点击某行中的 <em><code>accessory button</code></em>，会调用 <em><code>-(void)tableView:accessoryButtonTappedForRowWithIndexPath:</code></em></p>
<p>  <img src="/img/Study_iOS_UITableView/11.9.UITableView.png" alt="UITableView"></p>
</li>
<li><p>当然，你可以不使用这些 delegate，而是借助 Segue：</p>
<p>  <img src="/img/Study_iOS_UITableView/11.10.UITableView.png" alt="UITableView"></p>
<p>  然后 prepareForSegue：</p>
<pre><code>-(<span class="keyword">void</span>)prepareForSegue:(<span class="built_in">UIStoryboardSegue</span> *)segue sender:(<span class="keyword">id</span>)sender
{
    <span class="built_in">NSIndexPath</span> *indexPath = [<span class="keyword">self</span><span class="variable">.tableView</span> indexPathForCell:sender];
    <span class="comment">// indexPath.row in indexPath.section</span>
    <span class="comment">// prepare segue.destinationController</span>
}
</code></pre></li>
</ul>
</li>
<li><p><strong>reload</strong></p>
<p> 当 table 的 Model 发生变化后，你需要去 reload 来更新 table。</p>
<p> <code>-(void)reloadData</code>：更新整个 table，重新调用一遍 UITableViewDataSource，比较 heavyweight。</p>
<p> <code>-(void)reloadRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animationStyle</code>：只更新指定的行，比较 lightweight。</p>
</li>
<li><p><strong>Spinner</strong></p>
<p> UITableView 有个内置的 activity indicator Spinner：<code>@property (strong) UIRefreshControl *refreshControl;</code></p>
<p> <img src="/img/Study_iOS_UITableView/11.12.UITableView.png" alt="UITableView"></p>
<p> <code>[self.refreshControl beginRefreshing]</code>：table 下伸，Spinner 出现并开始 spinning。</p>
<p> <code>[self.refreshControl endRefreshing]</code>：table 上收，Spinner 停止 spinning 并消失。</p>
<p> 有了这个 Spinner，你就可以在 reload 的时候给用户提示适当的状态了。</p>
<p> 这个 Spinner 是可以 <em><code>Control</code></em> + <em><code>Drag</code></em> 出 target-action 的。如果用户 pull down table，那么这个 action 就会触发！这样，你就可以在 action 中让 Spinner start spinning，然后去更新 table。</p>
<p> <img src="/img/Study_iOS_UITableView/11.13.UITableView.png" alt="UITableView"></p>
<p> <img src="/img/Study_iOS_UITableView/11.14.UITableView.png" alt="UITableView"></p>
<p> <strong>注意</strong>，用户 pull down 触发的是 Spinner 的 target-action，而不是触发 beginRefreshing。你需要在 action 中调用 beginRefreshing。</p>
</li>
</ol>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：UITableView">Developing Applications for iOS 观后感系列：UITableView</h3><p><em>相关视频章节：11</em></p>]]>
    
    </summary>
    
      <category term="iOS" scheme="https://hi.zongquan.wang/tags/iOS/"/>
    
      <category term="Development" scheme="https://hi.zongquan.wang/categories/Development/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Study iOS - UIScrollView]]></title>
    <link href="https://hi.zongquan.wang/2015/01/11/Study_iOS_UIScrollView/"/>
    <id>https://hi.zongquan.wang/2015/01/11/Study_iOS_UIScrollView/</id>
    <published>2015-01-11T05:46:10.000Z</published>
    <updated>2016-12-12T11:53:12.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：UIScrollView">Developing Applications for iOS 观后感系列：UIScrollView</h3><p><em>相关视频章节：10</em></p>
<a id="more"></a>
<hr>
<p><strong><code>UIScrollView</code></strong> 是 iOS 中很基础很重要的一种 UIView，用于呈现远大于 app window 大小的 content area，用户通过 <em><code>swiping</code></em> 手势可以在 content area 中进行 scroll，通过 <em><code>pinching</code></em> 手势可以进行 content 的 zoom。就像是拿着一个放大镜在四处移动着观察一副很大的地图。</p>
<p>UIScrollView 也是很多其它重要 UIView 的 super class，例如 <a href="../../../../2015/01/11/Study_iOS_UITableView/"><em><code>UITableView</code></em></a>、<em><code>UICollectionView</code></em>、<a href="../../../../2015/01/11/Study_iOS_Common_UI/"><em><code>UITextView</code></em></a> 等等。</p>
<h4 id="创建_UIScrollView">创建 UIScrollView</h4><p>通过 Storyboard 或者代码中通过 alloc initWithFrame。</p>
<h4 id="使用_UIScrollView">使用 UIScrollView</h4><ul>
<li>向 UIScrollView 的 content area 中添加一个 subview1：</li>
</ul>
<p><img src="/img/Study_iOS_UIScrollView/10.3.UIScrollView.png" alt="UIScrollView"></p>
<ul>
<li><p>再向 UIScrollView 的 content area 中添加一个很大的 subview2：</p>
<p>  <img src="/img/Study_iOS_UIScrollView/10.4.UIScrollView.png" alt="UIScrollView"></p>
<p>  <strong>注意</strong>，千万不要忘记设置 UIScrollView 的 <em><code>contentSize</code></em> property！它指定了 UIScrollView 的 content area 的大小，也就是 UIScrollView 可以游走的范围。所有添加到 UIScrollView 中的 subviews 的 frame 都是位于 UIScrollView 的 content area 坐标系中，即：原点为 (0,0)，size 为 contentSize。</p>
<p>  通常，contentSize 的设定需要考虑 content area 里面容纳的 subviews 的大小。</p>
</li>
<li><p><strong>当前 visible area</strong></p>
<p>  <img src="/img/Study_iOS_UIScrollView/10.6.UIScrollView.png" alt="UIScrollView"></p>
</li>
<li><p><strong>当前 visible area 在 content area 坐标系中的位置</strong></p>
<p>  <img src="/img/Study_iOS_UIScrollView/10.5.UIScrollView.png" alt="UIScrollView"></p>
</li>
<li><p><strong>当前 visible area 在原 subview 坐标系中的大小</strong></p>
<p>  <img src="/img/Study_iOS_UIScrollView/10.7.UIScrollView.png" alt="UIScrollView"></p>
</li>
<li><p><strong>Zoom</strong></p>
<p>  所有 UIView 都有一个 property：<em><code>CGAffineTransform transform</code></em>，包含 <em><code>translate</code></em>，<em><code>scale</code></em>，<em><code>rotate</code></em>。而 UIScrollView 实现 Zoom 的原理就是改变 subview 的 transform 的值。</p>
<p>  <strong>注意</strong>，Zoom 时也会影响 <em><code>contentSize</code></em> 和 <em><code>contentOffset</code></em> 的值。</p>
<p>  <strong>想要支持 Zoom 效果，必须做到下面2点</strong>：</p>
<ol>
<li><p>设定 UIScrollView 的 <em><code>minimumZoomScale</code></em> 和 <em><code>maximumZoomScale</code></em>。不设定的话，默认都是 1.0，即不缩放。</p>
</li>
<li><p>实现 delegate 函数：<code>-(UIView *)viewForZoomingInScrollView:(UIScrollView *)sender;</code>，该函数用于指定你要缩放的是 UIScrollView 中的哪个 subview。</p>
<p>通常缩放都是伴随着 pinching 手势的发生而触发的，但你也可以在代码中手动触发缩放。主要是借助这2个 API：<code>-(void)setZoomScale: animated:</code> 和 <code>-(void)zoomToRect: animated:</code>。</p>
</li>
</ol>
</li>
</ul>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：UIScrollView">Developing Applications for iOS 观后感系列：UIScrollView</h3><p><em>相关视频章节：10</em></p>]]>
    
    </summary>
    
      <category term="iOS" scheme="https://hi.zongquan.wang/tags/iOS/"/>
    
      <category term="Development" scheme="https://hi.zongquan.wang/categories/Development/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Study iOS - Segue]]></title>
    <link href="https://hi.zongquan.wang/2015/01/10/Study_iOS_Segue/"/>
    <id>https://hi.zongquan.wang/2015/01/10/Study_iOS_Segue/</id>
    <published>2015-01-10T15:01:35.000Z</published>
    <updated>2016-12-12T11:53:12.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：Segue">Developing Applications for iOS 观后感系列：Segue</h3><p><em>相关视频章节：6，15，16</em></p>
<a id="more"></a>
<hr>
<p><em><code>Segue</code></em>，中文为“继续”的意思，在 iOS 开发中，其 class 为 <em><code>UIStoryboardSegue</code></em>，用于 storyboard 中不同 UIViewController 之间的转场，即从一个 UIViewController scene 转场到另一个 UIViewController scene。你可以从一个 UIControl、UIBarItem、UIView、UIViewController 等等，向另一个 UIViewController 建立 Segue。</p>
<h3 id="如何创建_Segue">如何创建 Segue</h3><p>起点（UIControl、UIBarItem、UIView、UIViewController 等等）</p>
<p>⇩</p>
<p><em><code>Control</code></em> + <em><code>Drag</code></em></p>
<p>⇩</p>
<p>终点（UIViewController）</p>
<p>⇩</p>
<p>设置 Segue 的 Identifier</p>
<h3 id="Segue_如何执行">Segue 如何执行</h3><ol>
<li><p><strong>触发 Segue</strong>：假如你从 UIButton 建立了一个 Segue，那么 button 点击时，就会触发 Segue。但有时你也需要从代码中手动触发 Segue，此时就需要调用 UIViewController 的 API：<code>-(void)performSegueWithIdentifier:(NSString *)segueID sender:(id)sender</code>。</p>
</li>
<li><p><strong>询问 Segue 是否允许执行</strong>：实现这个 delegate：<code>-(BOOL)shouldPerformSegueWithIdentifier:(NSString *)identifier sender:(id)sender</code>，如果不实现，默认就是允许所有 Segue。</p>
</li>
<li><p><strong>准备 Segue</strong>：真正呈现 <em><code>destination UIViewController</code></em> 之前，你需要为该 Segue 作 preparation。也就是说，Segue 会给 <em><code>source UIViewController</code></em> 机会去准备好将要呈现的 destination UIViewController。可以理解成 destination UIViewController 的 init。这一 preparation 过程是通过实现如下 delegate 来完成的：</p>
<pre><code>-(<span class="typename">void</span>)<span class="string">prepareForSegue:</span>(UIStoryboardSegue *)segue <span class="string">sender:</span>(id)sender
{
    <span class="keyword">if</span> ([segue.identifier <span class="string">isEqualToString:</span>@<span class="string">"XXX"</span>]) {
        <span class="keyword">if</span> ([segue.destinationViewController <span class="string">isKindOfClass:</span>[XXXViewController <span class="class"><span class="keyword">class</span>]]) {</span>
            XXXViewController *xxxVC = (XXXViewController *)segue.destinationViewController;
            xxxVC.xxxProperty = XXX; <span class="comment">// setup <span class="label">xxxVC</span></span>
        }
    }
}
</code></pre><p> <strong>注意</strong>，要记住之前 <a href="../../../../2015/01/05/Study_iOS_MVC/">MVCs</a> 中提到的原则，这个 destination UIViewController 在 source UIViewController 的 MVC 中扮演着 View 的角色，不允许 destination UIViewController 向 source UIViewController 的直接通信，而是要使用 blind 的方式，如 delegate。</p>
<p> <strong>还要注意</strong>，几乎所有类型的 Segue 都是 init 一个 <strong>new</strong> destination UIViewController 给你，所以当你第二次 prepareForSegue 时，第一次 prepareForSegue 拿到的那个 destination UIViewController 已经不复存在了，你需要重新 setup。<strong>这里只有一个例外</strong>，就是后面要提到的 <em><code>Unwind Segue</code></em>，它返给你的 destination UIViewController 就是之前已经存在的 UIViewController，这显然是合理的。举个例子，aVC 通过普通 Segue 转场到 bVC（bVC 会被重新 init），bVC 又通过 Unwind Segue 转回到 aVC，此时，Unwind Segue 的 destination UIViewController 显然必须是之前已经存在的那个 aVC，而不应该去重新 init 一个。</p>
<p> <strong>更要注意</strong>，prepareForSegue 在执行的时候，destination UIViewController 中的 outlet 尚未 set，因为 prepareForSegue 做的事等价于帮助 destination UIViewController 去 init。而 outlet set 是在 init 之后，viewDidLoad 之前做的。参见 <a href="../../../../2015/01/05/Study_iOS_Life_Cycle/">Life Cycle</a>。</p>
</li>
<li><p><strong>系统为你呈现 destination UIViewController</strong></p>
</li>
</ol>
<h3 id="Segue_分类">Segue 分类</h3><ul>
<li><p><strong>Push Segue</strong>：一般用于 <em><code>UINavigationController</code></em> 中。感受一下 <em><code>UINavigationController</code></em>。</p>
<p>  <img src="/img/Study_iOS_Segue/6.0.UINavigationController.png" alt="UINavigationController"></p>
<p>  你可以从一个 Embedded MVC 向另一个 Embedded MVC 创建 Push Segue。</p>
<p>  每一个 Embedded MVC 都可以设定自己的 navigationItem.rightBarButtonItems 和 toolbarItems。</p>
<p>  每一个 Embedded MVC 中的 <em><code>Back Button</code></em> 都是 UINavigationController 自动添加的，显示的是上一个 Embedded MVC 的 Title，如果上一个没有设定 Title，就显示 “Back” 字样。</p>
<p>  <img src="/img/Study_iOS_Segue/6.1.UINavigationController.png" alt="UINavigationController"></p>
<p>  <strong>另外</strong>，一般都是通过 Segue 来呈现 destination UIViewController 的。但极少数情况下，你可能需要通过代码手动呈现，此时，你可以利用 UINavigationController 的 API <code>pushViewController:animated:</code>，那么要 push 的那个 UIViewController 如何获取呢？利用 UIStoryBoard 的 API <code>instantiateViewControllerWithIdentifier:</code>，传入参数是你在 Storyboard 中为该 UIViewController 设定的 Identifier。两者结合起来就是：</p>
<pre><code>-(<span class="keyword">IBAction</span>)pushViewControllerByMyself
{
    XXXViewController *xxxVC = [<span class="keyword">self</span><span class="variable">.storyboard</span> instantiateViewControllerWithIdentifier:<span class="string">@"XXX"</span>];
    xxxVC<span class="variable">.xxxProperty</span> = XXX;
    [<span class="keyword">self</span><span class="variable">.navigationController</span> pushViewController:xxxVC animated:<span class="literal">YES</span>];
}
</code></pre></li>
<li><p><strong>Relationship Segue</strong>：一般用于 <em><code>UITabBarController</code></em> 中。感受一下 <em><code>UITabBarController</code></em> 。</p>
<p>  <img src="/img/Study_iOS_Segue/6.6.UITabBarController.png" alt="UITabBarController"></p>
<p>  <img src="/img/Study_iOS_Segue/6.7.UITabBarController.png" alt="UITabBarController"></p>
<p>  <img src="/img/Study_iOS_Segue/6.8.UITabBarController.png" alt="UITabBarController"></p>
</li>
<li><p><strong>Embedded Segue</strong>：一般用于 <em><code>Container View</code></em> 中。Container View 的作用是，将一个 VC 的 self.view show 到另一个 VC 的 view 中。感受一下 <em><code>Container View</code></em> 。</p>
<p>  <img src="/img/Study_iOS_Segue/15.0.EmbedSegue.png" alt="Container View"></p>
<p>  创建 Embedded Segue 的方式同 Push Segue 一样，通过 <em>Control</em> + <em>Drag</em> 的方式，从 Container View 拖向 destination UIViewController，此时只有一种 Segue 可以选择，那就是 Embedded Segue。</p>
<p>  <strong>注意</strong>，这个 Embedded Segue 是在外层 UIViewController 呈现的时候自动触发的（<em>触发的具体时间点有待进一步研究</em>），你同样是需要去 prepareForSegue，不要忘了，此时 destination UIViewController 的 outlet 尚未 set。</p>
</li>
<li><p><strong>Modal Segue</strong>：一般用于呈现 <em><code>Modal View Controller</code></em>。</p>
<p>  创建 Modal Segue 的方式同 Push Segue 一样，通过 <em>Control</em> + <em>Drag</em> 的方式，从某个 UIButton（举例来说）拖向 destination UIViewController，选择 Modal 即可。当 Segue 触发时，就会以 Modal 的形式呈现 destination UIViewController。同样，你需要去 prepareForSegue。通过设定 destination UIViewController 的属性 modalTransitionStyle，可以让它以不同的动画形式呈现出来。</p>
<p>  当然，你也可以通过代码手动地以 Modal 的形式呈现 destination UIViewController，调用 <code>presentViewContainer:animated:completion:</code> 即可，这里的 completion block 会在 destination UIViewController viewDidAppear 后被调用。</p>
</li>
<li><p><strong>Unwind Segue</strong>：一般用于从 <em><code>Modal View Controller</code></em> 返回到它的 presenter。通过 Unwind Segue，你也只能是返回到自己的 presenter。Unwind Segue 也可以用在 <em><code>UINavigationController</code></em> 机制中。</p>
<p>  正如之前提到的，使用 Unwind Segue 在 prepareForSegue 时，它返给你的 destination UIViewController 就是之前已经存在的 presenter UIViewController，不会去重新 init 一个 new UIViewController。</p>
<p>  <strong>那么创建 Unwind Segue 都需要做些什么呢？</strong></p>
<p>  举例来说，aVC 通过 Modal Segue 的形式呈现出 bVC，现在 bVC 要通过 Unwind Segue 的形式返回到 aVC。那么要创建这个 Unwind Segue 需要2步操作：</p>
<ol>
<li><p>在 aVC 的代码中，实现一个如下这样原型的函数：</p>
<pre><code>-(<span class="keyword">IBAction</span>)handleUnwindSegue:(<span class="built_in">UIStoryboardSegue</span> *)segue
{
    XXXViewController *bVC = (XXXViewController *)segue<span class="variable">.sourceViewController</span>; <span class="comment">// source, not destination. bVC Unwind Segue to aVC, so bVC is source.</span>
    <span class="comment">// get what you want from bVC</span>
}
</code></pre></li>
<li><p>在 bVC 的 scene 中，通过 <em>Control</em> + <em>Drag</em> 拖向下面这个 icon：</p>
<p> <img src="/img/Study_iOS_Segue/16.2.UnwindSegue.png" alt="Unwind Segue"></p>
<p> 然后 Xcode 就会列出 aVC 中所有你实现的那种原型的函数，选择其中匹配的那个 handleUnwindSegue:，并给该 Unwind Segue 设定 Identifier，这样就创建了 bVC 到 aVC 的一个 Unwind Segue。</p>
<p>handleUnwindSegue: 会在 aVC 呈现后被调用，此时，bVC 会自动 dismiss。别忘了在 bVC 的代码中还是需要去 prepareForSegue 的，为这个 Unwind Segue 做 preparation，通常就是准备好供 aVC 在 handleUnwindSegue: 中访问的东西。</p>
<p><strong>另外</strong>，这里再多提一些关于 Modal View 的东西。前面讲到了，在 aVC 通过 Unwind Segue 被呈现出来的时候，bVC 会自动 dismiss。那么如果不借助 Unwind Segue，如何在代码中手动让其 dismiss 呢。可以利用 <code>dismissViewControllerAnimated:completion:</code> 来完成。<strong>注意</strong>，这个消息不是发给 bVC 自己的，而是发给 aVC 的！查看文档就会明白，aVC 调用这个函数后，会 dismiss 掉它 present 出来的 Modal View Controller。所以，在 bVC 的代码中，你通常是这么使用该函数：</p>
<pre><code>[self.presentingViewController <span class="string">dismissViewControllerAnimated:</span>YES <span class="string">completion:</span>XXX];
</code></pre><p>在 bVC 中通过 self.presentingViewController 拿到 aVC。</p>
<p>手动 dismiss 一般是用于 bVC 什么也不做就返回到 aVC，这样就不需要通过 Unwind Segue 向 aVC 返回数据。</p>
</li>
</ol>
</li>
</ul>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：Segue">Developing Applications for iOS 观后感系列：Segue</h3><p><em>相关视频章节：6，15，16</em></p>]]>
    
    </summary>
    
      <category term="iOS" scheme="https://hi.zongquan.wang/tags/iOS/"/>
    
      <category term="Development" scheme="https://hi.zongquan.wang/categories/Development/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Study iOS - Network]]></title>
    <link href="https://hi.zongquan.wang/2015/01/07/Study_iOS_Network/"/>
    <id>https://hi.zongquan.wang/2015/01/07/Study_iOS_Network/</id>
    <published>2015-01-07T02:15:27.000Z</published>
    <updated>2016-12-12T11:53:12.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：Network">Developing Applications for iOS 观后感系列：Network</h3><p><em>相关视频章节：10</em></p>
<a id="more"></a>
<hr>
<p>iOS 中处理 Network 的 API 主要是 <em><code>NSURLSession</code></em>，当然，基于此，<em>Mattt Thompson</em> 开发了一套更加强大易用的 <em>AFNetworking</em>。不管怎样，还是很有必要了解一下 iOS 自己的 <em>NSURLSession</em> 的。</p>
<h4 id="NSURLSession_的一般使用流程："><em>NSURLSession</em> 的一般使用流程：</h4><pre><code><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:XXX];
<span class="built_in">NSURLSessionConfiguration</span> *configuration = XXX;
<span class="built_in">NSURLSession</span> *session = XXX; <span class="comment">// use configuration</span>
<span class="built_in">NSURLSessionXXXTask</span> *task = [session XXXTaskWithRequest:request]; <span class="comment">// downloadTask, uploadTask, dataTask, ...</span>
[task resume];
</code></pre><p>基本上就是上面这几步。当然，如果使用 <em><code>NSURLSessionDelegate</code></em> 的话，还需要实现这些 delegate；如果不使用 delegate，也可以选择使用 <em><code>completionHandler</code></em> 这种 block 的方式。具体选择哪种，取决于 <em>NSURLSessionXXXTask</em> 是如何创建的，下面会详细提到。</p>
<p>下面分别理解一下这些具体步骤：</p>
<ol>
<li><p><strong><code>NSURLRequest</code></strong>：比较简单，不多说了。</p>
</li>
<li><p><strong><code>NSURLSessionConfiguration</code></strong>：这个 configuration 控制着后面创建的 session 的若干属性。通常比较关注这3个 API：</p>
<ul>
<li><p><code>+(NSURLSessionConfiguration *)defaultSessionConfiguration</code>：创建一个 default session，会使用 cache，cookie 机制。</p>
</li>
<li><p><code>+(NSURLSessionConfiguration *) ephemeralSessionConfiguration</code>：创建一个 ephemeral session，不使用 cache，cookie 机制，所有东西都在内存中，除了下载文件时才会真正地有写入 disk 的动作。</p>
</li>
<li><p><code>+(NSURLSessionConfiguration *) backgroundSessionConfigurationWithIdentifier:(NSString *)identifier</code>：创建一个 background session，可以让 session 在 app 处于 background 时能够继续 run。</p>
<p>  这种 session 会把控制权交给系统，正如之前一篇笔记（<a href="../../../../2015/01/05/Study_iOS_Life_Cycle/"><em><code>Life Cycle</code></em></a>）中讲到的那样，有个 <code>UIApplicationDelegate</code> 是专门配合这种 session 使用的，即 <code>(void)application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)())completionHandler</code>，系统首先通过这个 delegate 响应 network events 后，才会再把控制权交给你的 <em><code>NSURLSessionDelegate</code></em>。</p>
<p>  <strong>注意</strong>，这种 session 比前面2种多了一个 <code>identifier</code>，有了它，当 app 被系统 terminate 和 relaunch 后，系统会使用同一个 identifier 重建 background session，继续之前未完成的 network transfer。但是，这里仅限于 app 是被系统 terminate 和 relaunch，如果是用户手动退出 app，则不会去重建 session。</p>
</li>
</ul>
</li>
<li><p><strong><code>NSURLSession</code></strong>：有了 configuration，就可以创建 session 了。session 的 init 方式决定了 network events 的 handle 方式，以及 handle 操作的执行环境是哪里。主要有2种 init 方式：</p>
<ul>
<li><p><code>+(NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration delegate:(id&lt;NSURLSessionDelegate&gt;)delegate delegateQueue:(NSOperationQueue *)queue</code>：</p>
<p>  <strong>delegate</strong> 若不为 nil，就意味着你实现了自己的 <em><code>NSURLSessionDelegate</code></em> 来 handle network events。若为 nil，就意味着该 session 只接受 <em><code>completionHandler</code></em> 这种 handle 操作。</p>
<p>  <strong>queue</strong> 用于指定 handle 操作（不管是 NSURLSessionDelegate 还是 completionHandler）是在什么 NSOperationQueue 上执行的。可以传递 [NSOperationQueue mainQueue]；也可以传递 <strong>[[NSOperationQueue alloc] init]（根据文档，这样 init 出来的 NSOperationQueue 总是并行执行其中的 operation 的</strong>）；还可以传递 <strong>nil，此时，session 会自动创建一个串行 queue（非 mainQueue）</strong>来执行所有的 NSURLSessionDelegate 或者 completionHandler。</p>
</li>
<li><p><code>+(NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration</code>：前一种的简化版，只接受 <em><code>completionHandler</code></em> 这种 handle 操作，同时，<strong>session 会自动创建一个串行的 NSOperationQueue（非 mainQueue）来执行 completionHandler</strong>。</p>
<p><strong>注意</strong>，session 的 delegate 和 delegateQueue 属性是只读的，无法事后修改。</p>
</li>
</ul>
</li>
<li><p><strong><code>NSURLSessionXXXTask</code></strong>：这里不提具体的各种 task 是什么样的，只关注下 session 创建 task 的方式。主要有2类：</p>
<ul>
<li><p><code>XXXTaskWithRequest:completionHandler:</code>：指定 completionHandler 来 handle network events。你可以指定它为 NULL，但前提是在之前创建 session 时已经指定好了 NSURLSessionDelegate，这样就会通过 delegate 来 handle，否则，既没有 completionHandler 又没有 delegate，你就无法 handle 了。</p>
</li>
<li><p><code>XXXTaskWithRequest:</code>    ：只通过 NSURLSessionDelegate 来 handle。</p>
<p><strong>注意</strong>，XXXTask 本身执行时并不在 mainQueue 上，所以不必担心，你所关注的只是 NSURLSessionDelegate 或者 completionHandler 是在哪个 queue 上执行。</p>
</li>
</ul>
</li>
<li><p><strong>不要忘了 <code>[task resume];</code></strong></p>
</li>
</ol>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：Network">Developing Applications for iOS 观后感系列：Network</h3><p><em>相关视频章节：10</em></p>]]>
    
    </summary>
    
      <category term="iOS" scheme="https://hi.zongquan.wang/tags/iOS/"/>
    
      <category term="Development" scheme="https://hi.zongquan.wang/categories/Development/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Study iOS - UIView Animation]]></title>
    <link href="https://hi.zongquan.wang/2015/01/06/Study_iOS_Animation/"/>
    <id>https://hi.zongquan.wang/2015/01/06/Study_iOS_Animation/</id>
    <published>2015-01-06T14:29:21.000Z</published>
    <updated>2016-12-12T11:53:12.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：UIView_Animation">Developing Applications for iOS 观后感系列：UIView Animation</h3><p><em>相关视频章节：8</em></p>
<a id="more"></a>
<hr>
<p>本篇提到的 Animation 主要是基于 UIView 的，并没有涉及到基于 Layer 机制的 Animation。</p>
<p>基于 UIView 的 Animation 有以下3种：</p>
<h3 id="Animation_of_UIView_Property">Animation of UIView Property</h3><p><strong>首先一定要明确一点</strong>：animation 虽然是经历一定时间 show 在屏幕上的，但对 property 的值的修改却是早就已经立即生效了。</p>
<p>UIView 的某些 property 的改变是可以施加 animation 的，例如：</p>
<pre><code>frame
transform（translation，rotation，<span class="built_in">scale</span>）
<span class="built_in">alpha</span>（opacity）
</code></pre><p>实现这一类 animation 的 API 是 UIView 的 <code>class method</code>：</p>
<pre><code>+(<span class="keyword">void</span>)animateWithDuration:(<span class="built_in">NSTimeInterval</span>)duration
                     delay:(<span class="built_in">NSTimeInterval</span>)delay
                   options:(<span class="built_in">NSViewAnimationOptions</span>)options
                animations:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))animationsBlock
                completion:(<span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> finished))completionBlock
</code></pre><p><code>animationsBlock</code> 里面执行你对 UIView property 所做的修改。</p>
<p><code>completionBlock</code> 表示 animation 呈现结束后要做的事，如果 animation 成功地呈现完毕，finished 为 YES，否则，若中断了，则返回 NO。</p>
<p><strong>注意</strong>：animation 是在该 API 返回后开始的，而该 API 返回的时刻是 <code>animationsBlock</code> 执行完毕的时刻。<strong>也就是说</strong>，调用该 API 后，会立刻执行其 <code>animationsBlock</code>，执行完后就立刻返回，然后 animation 开始呈现。所以对 UIView property 的修改在 <code>animationsBlock</code> 执行完后就立即生效了，只不过 property 的变化要经过 duration 才呈现完毕。</p>
<p><strong>另外</strong>：finished 何时为 NO？如果在该 animation 开始后，又调用了该 API 对相同的 property 开始了另一个 animation，这样前一个 animation 没做完就得中断去做另一个 animation 了，这种情况下，前一个 animation 的 completionBlock 的 finished 就为 NO 了。</p>
<h3 id="Animation_of_Entire_UIView">Animation of Entire UIView</h3><p>例如整个 UIView 的 flipping、dissolving、curling 等效果，在呈现这些效果的同时，你可以对整个 UIView 进行任意修改，改变其 appearance。</p>
<p>实现这一类 animation 的 API 是 UIView 的 <code>class method</code>：</p>
<pre><code>+(<span class="keyword">void</span>)transitionWithView:(<span class="built_in">UIView</span> *)viewToModify
                 duration:(<span class="built_in">NSTimeInterval</span>)duration
                  options:(<span class="built_in">NSViewAnimationOptions</span>)options
               animations:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))animationsBlock
               completion:(<span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> finished))completionBlock
</code></pre><p><code>animationsBlock</code> 和 <code>completionBlock</code> 的机制同前面一种 animation 一样，只不过你不再是只单单地修改 UIView 的某个 property，你可以对整个 UIView 做任意的修改（例如重新绘制整个 UIView 等）。</p>
<p><code>options</code> 可以指定 animation 采用的效果：flipping、dissolving、curling 等。</p>
<p>如果不是想对同一个 UIView 进行 animation 修改，而是要转为呈现另一个 UIView，则需要使用这个 API：</p>
<pre><code>+(<span class="keyword">void</span>)transitionFromView:(<span class="built_in">UIView</span> *)fromView
                   toView:(<span class="built_in">UIView</span> *)toView
                 duration:(<span class="built_in">NSTimeInterval</span>)duration
                  options:(<span class="built_in">NSViewAnimationOptions</span>)options
               completion:(<span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> finished))completionBlock
</code></pre><p>此时已经不再需要 <code>animationsBlock</code> 了，因为要呈现的 animation 就是从 fromView 变为 toView。</p>
<p><code>optioins</code> 可以指定：你是想 hide fromView 而呈现 toView，还是想 remove fromView 而重新 add toView。</p>
<h3 id="Dynamic_Animator">Dynamic Animator</h3><p>这一类 animation 是指 <em><code>animatable objects</code></em>（通常就是 UIView）的 <em><code>physics animation</code></em>。将某些 physics 效果施加到 animatable objects 上，这些 objects 就会受到 physics 的影响自行开始动画效果，直到在 physics 的作用下 resolve to stasis（相对静止状态）。</p>
<p>Steps：</p>
<ol>
<li><p>创建 <code>UIDynamicAnimator</code>，并指定其 <code>delegate</code>。</p>
<pre><code>UIDynamicAnimator *animator = [[UIDynamicAnimator alloc] initWithReferenceView:aView]<span class="comment">;</span>
animator.delegate = aDelegate<span class="comment">;</span>
</code></pre><p> 设定 delegate 是为了响应 UIDynamicAnimatorDelegate 的2个函数：</p>
<p> <code>-(void)dynamicAnimatorDidPause:(UIDynamicAnimator *)animator</code>：resolve to stasis 导致动画暂停</p>
<p> <code>-(void)dynamicAnimatorWillResume:(UIDynamicAnimator *)animator</code>：动画重新开始</p>
</li>
<li><p>向 UIDynamicAnimator 中添加各种 physics 效果，即 <code>UIDynamicBehavior</code>（gravity，collisions 等等）。</p>
<p> UIDynamicBehavior 有很多子类，例如创建一个 gravity 作用效果：</p>
<pre><code>UIGravityBehavior *gravity = <span class="comment">[<span class="comment">[UIGravityBehavior alloc]</span> init]</span>;
<span class="comment">[animator addBehavior:gravity]</span>;
</code></pre><ul>
<li><p>有一个比较特殊的 UIDynamicBehavior，即 <code>UIDynamicItemBehavior</code>，它的各个 property 用于指定 objects 的一些固有 physic 属性，例如：allowsRotation，friction，elasticity，density 等。这些属性会间接影响到其他 UIDynamicBehavior 的作用效果。</p>
</li>
<li><p>你也可以 subclass UIDynamicBehavior，进行自定义。可以利用它的函数 <code>addChildBehavior:(UIDynamicBehavior *)behavior</code> 将若干个 UIDynamicBehavior 组合成一种新的 UIDynamicBehavior。通常你还需要 override 它的 <code>init</code>，<code>addItem</code>，<code>removeItem</code>。</p>
</li>
<li><p>UIDynamicBehavior 有一个 property 用于访问自己所在的 UIDynamicAnimator：<code>dynamicAnimator</code>。</p>
</li>
<li><p>UIDynamicBehavior 还有一个重要的 property：<code>@property (copy) void (^action)(void)</code>，每当 UIDynamicBehavior 在 objects 上生效时，该 block 都会被调用。所以，这里的操作最好不要太费时，因为它会被频繁地调用。</p>
</li>
</ul>
</li>
<li><p>将 <code>UIDynamicItem</code>（animatable objects，通常就是 UIView）添加到某些 UIDynamicBehavior 下。</p>
<p> UIDynamicItem 是一个 protocol，指定3个 property：bounds，center，transform。而 UIView 实现了该 protocol。</p>
<pre><code><span class="keyword">id</span> &lt;<span class="built_in">UIDynamicItem</span>&gt; item = XXX <span class="comment">// 例如某个 UIView</span>
[gravity addItem:item];
</code></pre></li>
<li><p>一旦完成 step 3，UIDynamicItem 就会自动在 UIDynamicBehavior 的作用下开始运动。</p>
<p> <strong>注意</strong>，如果你在 UIDynamicAnimator 的作用下，手动修改了 UIDynamicItem 的属性，那么必须调用 UIDynamicAnimator 的函数 <code>updateItemUsingCurrentState:item</code> 来让 UIDynamicAnimator 重新获取其属性，这样作用在 item 上的 UIDynamicBehavior 才能根据当前的最新状态继续产生作用力。</p>
</li>
</ol>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：UIView_Animation">Developing Applications for iOS 观后感系列：UIView Animation</h3><p><em>相关视频章节：8</em></p>]]>
    
    </summary>
    
      <category term="iOS" scheme="https://hi.zongquan.wang/tags/iOS/"/>
    
      <category term="Development" scheme="https://hi.zongquan.wang/categories/Development/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Study iOS - UIView]]></title>
    <link href="https://hi.zongquan.wang/2015/01/06/Study_iOS_UIView/"/>
    <id>https://hi.zongquan.wang/2015/01/06/Study_iOS_UIView/</id>
    <published>2015-01-06T13:23:11.000Z</published>
    <updated>2016-12-12T11:53:12.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：UIView">Developing Applications for iOS 观后感系列：UIView</h3><p><em>相关视频章节：7</em></p>
<a id="more"></a>
<hr>
<h3 id="UIView_的_init">UIView 的 init</h3><p>与 UIViewController 的 init 类似，UIView 的 init 也有2种形式：一种是从 storyboard 中释放出来，另一种是在代码中直接调用相关的 init 函数。两种只会选择一种来完成 init。</p>
<ol>
<li><p><strong>来自 storyboard：</strong> <em><code>awakeFromNib</code></em></p>
<p> awakeFromNib 是 NSObject 的函数，颤抖吧。</p>
</li>
<li><p><strong>来自 code：</strong> <em><code>initWithFrame:(CGRect)rect</code></em></p>
</li>
</ol>
<p>因为有这2种 init 方式，所以，如果希望在 init 阶段做一些 setup，那么这2个地方都要执行 setup。因为从 storyboard 释放出来的 init 方式只会调用 awakeFromNib，不会调用 initWithFrame:；同样，code 中调用 initWithFrame: 进行的 init 方式也不会再调用 awakeFromNib。</p>
<h3 id="Coordinate">Coordinate</h3><p><img src="/img/Study_iOS_UIView/7.1.Coordinate.png" alt="Coordinate"></p>
<p><img src="/img/Study_iOS_UIView/7.2.Coordinate.png" alt="Coordinate"></p>
<h3 id="Draw">Draw</h3><p>基于 CPU 进行绘制时，靠的是 <em><code>drawRect:</code></em> 这个函数。如何实现自己的 <em><code>drawRect:</code></em> 呢？两种方式：</p>
<ul>
<li><p><strong>Core Graphics （C API）</strong></p>
<ol>
<li><p>获取 draw 操作所在的 <em><code>context</code></em>。<strong>注意</strong>，每次调用 <em><code>drawRect:</code></em> 时，iOS 都会重新给你提供一个新的 context，只有这个最新的对本次 <em><code>drawRect:</code></em> 才是有效的，因此不要去 cache 之前的某个 context 来复用，因为它对本次的 <em><code>drawRect:</code></em> 是无效的。</p>
<p> context 决定了 <em><code>drawRect:</code></em> 操作发生在哪里（Screen，Offscreen，PDF，Printer 等）。通过在 <em><code>drawRect:</code></em> 中调用 <em><code>UIGraphicsGetCurrentContext()</code></em> 来获取当前 CGContextRef。</p>
</li>
<li><p>创建 path</p>
</li>
<li><p>设置 color、font、width 等等属性</p>
</li>
<li><p>调用 stroke 或者 fill 进行绘制</p>
</li>
</ol>
</li>
<li><p><strong>UIBezierPath（Cocoa API）</strong></p>
<p>  利用 UIBezierPath 会得到一个 object，然后直接通过该 object 来 stroke 或者 fill。UIBezierPath 是不需要设置 context 的，它会自动地在当前 context 下进行绘制。</p>
<p>  可以利用 UIBezierPath 来 clip 你的后续绘制操作：</p>
<pre><code>UIBezierPath *roundedRect = [UIBezierPath bezierPathWithRoundedRec<span class="variable">t:rect</span> cornerRadiu<span class="variable">s:radius</span>];
[roundedRect addClip]; // this would clip <span class="keyword">all</span> drawing <span class="keyword">to</span> <span class="keyword">be</span> inside the roundedRect
</code></pre></li>
</ul>
<p>基于 GPU 的 draw 用的是另一套机制：Layer。本篇未涉及。</p>
<h3 id="Redraw">Redraw</h3><p><img src="/img/Study_iOS_UIView/7.6.Redraw.png" alt="Redraw"></p>
<h3 id="UIGestureRecognizer">UIGestureRecognizer</h3><p>两种添加方式：</p>
<ol>
<li><p><code>code 中添加</code></p>
<p> <img src="/img/Study_iOS_UIView/7.7.UIGestureRecognizer.png" alt="UIGestureRecognizer"></p>
<p> <img src="/img/Study_iOS_UIView/7.8.UIGestureRecognizer.png" alt="UIGestureRecognizer"></p>
<p> <img src="/img/Study_iOS_UIView/7.9.UIGestureRecognizer.png" alt="UIGestureRecognizer"></p>
</li>
<li><p><code>storyboard 中拖放 UIGestureRecognizer 控件，并设置 target-action。</code></p>
</li>
</ol>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：UIView">Developing Applications for iOS 观后感系列：UIView</h3><p><em>相关视频章节：7</em></p>]]>
    
    </summary>
    
      <category term="iOS" scheme="https://hi.zongquan.wang/tags/iOS/"/>
    
      <category term="Development" scheme="https://hi.zongquan.wang/categories/Development/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Study iOS - Misc]]></title>
    <link href="https://hi.zongquan.wang/2015/01/05/Study_iOS_Misc/"/>
    <id>https://hi.zongquan.wang/2015/01/05/Study_iOS_Misc/</id>
    <published>2015-01-05T14:34:11.000Z</published>
    <updated>2016-12-12T11:53:12.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：Misc">Developing Applications for iOS 观后感系列：Misc</h3><p><em>相关视频章节：all</em></p>
<a id="more"></a>
<hr>
<h4 id="NSObject">NSObject</h4><ul>
<li><p><code>(NSString *)description</code>：当你自己实现一个 myClass 时，如果实现了 <code>(NSString *)description</code> 这个函数，那么你就可以利用 <code>NSLog(@&quot;%@&quot;, myClassInstance)</code> 来输出 description 的内容了，这里的 <em><code>%@</code></em> 会被替换成 <code>[myClassInstance description]</code>。</p>
</li>
<li><p><code>(id)copy</code>：得到 object 的 unmutable 版，不管 object 本身是不是 mutable 的。</p>
</li>
<li><p><code>(id)mutableCopy</code>：得到 object 的 mutable 版，不管 object 本身是不是 mutable 的。</p>
<p>  <strong>注意</strong>，并不是所有的 class 都实现了 copy 和 mutableCopy 机制，如果没有实现，而你调用了，就会抛出异常。另外，这2种 copy 操作效率很高，所以不要有所担心。</p>
</li>
</ul>
<h4 id="UIFont">UIFont</h4><ul>
<li><p>给文本内容（content）设定字体的最佳方式：<code>UIFont *font = [UIFont preferredFontForTextStyle:UIFontTextStyleXXX]</code></p>
</li>
<li><p>给控件（例如 button 的 title）设定字体的最佳方式：<code>UIFont *font = [UIFont systemFontOfSize:(CGFloat)pointSize]</code></p>
<p>  <strong>注意</strong>，preferredFontForTextStyle: 也可以用于设定控件字体，但反过来 systemFontOfSize: 却不能用于设定 content 字体。</p>
</li>
</ul>
<h4 id="NSNotification">NSNotification</h4><ul>
<li><p>对于向 NSNotificationCenter 注册过的 observer，如果不再需要 listen 某个 notification，必须要调用 <code>removeObserver:</code>，因为 NSNotificationCenter 对 observer 的引用方式是 <em><code>unsafe retained</code></em>，所以，如果 observer 变为 nil 了，NSNotificationCenter 会出现引用异常，造成 crash。</p>
<p>  常见的调用 removeObserver: 的地方是 <em><code>viewWillDisappear</code></em> 或者 <em><code>dealloc</code></em>。</p>
</li>
</ul>
<h4 id="Category">Category</h4><ul>
<li><p>添加 Category 无需事先得到 class 的 .m 文件，即无需知道 class 的原始实现。</p>
</li>
<li><p><code>Category 不能添加 instance 变量，只能添加 property 和 function。</code>而 property 本质上也是 function，既然不能添加 instance 变量，<em><code>那也意味着，@synthesize 也是不允许的。</code></em>总结起来就是，Category 中添加的 property 和 function 只能对原有的 instance 变量进行操作。Extension 可以添加 instance 变量。</p>
</li>
</ul>
<h4 id="Network_Activity_Indicator">Network Activity Indicator</h4><ul>
<li>UIApplication 有个属性：<em><code>BOOL networkActivityIndicatorVisible</code></em>，将其设为 YES，status bar 上就会出现表示网络活动的 spinner，设为 NO，spinner 就会消失。使用时需要注意，当多个线程操作该 networkActivityIndicatorVisible 时，需要给它加个<strong>计数的机制</strong>，防止错误地开关该属性。</li>
</ul>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：Misc">Developing Applications for iOS 观后感系列：Misc</h3><p><em>相关视频章节：all</em></p>]]>
    
    </summary>
    
      <category term="iOS" scheme="https://hi.zongquan.wang/tags/iOS/"/>
    
      <category term="Development" scheme="https://hi.zongquan.wang/categories/Development/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Study iOS - Life Cycle]]></title>
    <link href="https://hi.zongquan.wang/2015/01/05/Study_iOS_Life_Cycle/"/>
    <id>https://hi.zongquan.wang/2015/01/05/Study_iOS_Life_Cycle/</id>
    <published>2015-01-05T12:38:32.000Z</published>
    <updated>2016-12-12T11:53:12.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：Life_Cycle">Developing Applications for iOS 观后感系列：Life Cycle</h3><p><em>相关视频章节：5，17</em></p>
<a id="more"></a>
<hr>
<p>这里提到的 Life Cycle 主要包括2方面：</p>
<ul>
<li><p>Application 的 Life Cycle</p>
</li>
<li><p>UIViewController 的 Life Cycle</p>
</li>
</ul>
<h3 id="Application_的_Life_Cycle">Application 的 Life Cycle</h3><p>Application 的 Life Cycle 是靠一些 <em><code>UIApplicationDelegate</code></em> 函数来控制的。</p>
<p>新建一个 iOS 项目的时候，在 Xcode 生成的 AppDelegate.m 中，已经列出了常用的几个 delegate 函数：</p>
<ul>
<li><p><code>(BOOL)application:(UIApplication *)application willFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code>：app 即将完成启动。诸如响应 openURL 这样的事情，需要在这里做，在 app 彻底启动完毕之前，从 launchOptions 中拿到 URL。</p>
</li>
<li><p><code>(BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code>：app 彻底启动完毕。这里一般做 app 的初始化操作。</p>
</li>
<li><p><code>(void)applicationDidBecomeActive:(UIApplication *)application</code>：app 变得 active，也就是说，app 的 UI 可以接收 events 了。这通常是发生在 app 启动后出现 UI 的时候，或者从其它 app 切换而来的时候。伴随该 delegate 有一个 notification <em><code>UIApplicationDidBecomeActiveNotification</code></em>。</p>
</li>
<li><p><code>(void)applicationWillResignActive:(UIApplication *)application</code>：app 变得 not active，也就是说，app 的 UI 无法接收 events 了。这通常是发生在切换到其它 app 的时候，或者双击 Home 的时候，或者接听电话的时候。总之就是，该 app 的 UI 已经不再是 iOS 的 first responder UI 了。伴随该 delegate 有一个 notification <em><code>UIApplicationWillResignActiveNotification</code></em>。</p>
<p>  通常利用以上2个 delegate，来暂停并保存当前 UI 状态，然后在之后重新恢复 UI 状态。</p>
</li>
<li><p><code>(void)applicationDidEnterBackground:(UIApplication *)application</code>：app 进入 background。<strong>注意</strong>，当发生 applicationWillResignActive 后，并不一定会发生 applicationDidEnterBackground，例如，运行该 app 时突然双击 Home 或者接听电话，此时，只会发生applicationWillResignActive。只有等到该 app 进入 background 后，例如已经切换到其它 app 后，才会发生 applicationDidEnterBackground。<strong>此外</strong>，iOS 留给该 delegate 的运行时间很短，如果想在这里做些费时的操作，可以借助 <em><code>beginBackgroundTaskWithExpirationHandler:</code></em>。伴随该 delegate 有一个 notification <em><code>UIApplicationDidEnterBackgroundNotification</code></em>。</p>
</li>
<li><p><code>(void)applicationWillEnterForeground:(UIApplication *)application</code>：app 即将重新回到 foreground。通常做些 undo applicationDidEnterBackground 的操作。applicationWillEnterForeground 发生之后，很快就会发生 applicationDidBecomeActive。<strong>但注意</strong>，app 启动的时候，并没有 applicationWillEnterForeground，而是直接 applicationDidBecomeActive。所以要理解前面提到的“重新”二字，app 启动时并不是重新，只有发生 applicationDidEnterBackground 后，才对应地有“重新”的意思。伴随该 delegate 有一个 notification <em><code>UIApplicationWillEnterForegroundNotification</code></em>。</p>
</li>
<li><p><code>(void)application:(UIApplication *)application performFetchWithCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler</code>：如果 app 开启了 fetch background mode，那么当 iOS 给你机会去做 fetch 时，就会调用该 delegate。在这里你可以做任何操作，并不限于 download fetch。但这里只有30s时间，30s内你必须处理完，然后调用 completionHandler。通常的做法是，首先开线程异步去做该做的操作，然后就立即调用 completionHandler。</p>
<p>  <strong>注意</strong>，如果 iOS 给你机会在这里做 network fetch，那么你应该在这里发起一个普通的 <em><code>ephemeral configuration 类型的 NSURLSession</code></em>，而不是发起 background configuration 类型的 NSURLSession。因为background configuration 类型的 NSURLSession 是 discretionary 的，当 app 已经处于 background 时，这种 NSURLSession 可能会被 iOS 拒绝执行，而这显然不是我们想要的，我们既然已经在 background 了，那么 iOS 给机会执行该函数时，我们想要的是发起一个有效的 NSURLSession，保证它会被执行。当在这里发起 ephemeral configuration 类型的 NSURLSession 后，我们就需要在 NSURLSession 的 completion delegate 中调用 <em><code>completionHandler:UIBackgroundFetchResultNewData</code></em> 来更新 app 的 UI snapshot。</p>
</li>
<li><p><code>(void)application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)())completionHandler</code>：如果之前发起了一个 background configuration 类型的 NSURLSession，那么当 NSURLSession task 完成后，就会调用该 delegate。<strong>注意</strong>，如果发起 background configuration 类型的 NSURLSession，那么必须要实现该 delegate，在其中尽早地调用 completionHandler，只有这样，app 才能调用你之前为 NSURLSession 设定的那些 NSURLSessionDelegate，诸如 didReceiveResponse 等等；否则，那些 NSURLSessionDelegate 不会被调用。</p>
</li>
<li><p><code>LocalNotification / RemoteNotification 系列</code>：处理诸如闹钟（local）、Apple Push Service（remote）这样的 Notification。</p>
</li>
<li><p><code>State Restoration 系列</code>：用于保存并恢复 app 的 UI，即使退出 app 后 再重启，也可以恢复到之前的状态。</p>
</li>
<li><p><code>Data Protection 系列</code>：锁屏后，将文件保护起来。</p>
</li>
</ul>
<p>最后图示一下：</p>
<p><img src="/img/Study_iOS_Life_Cycle/17.0.ApplicationLifeCycle.png" alt="ApplicationLifeCycle"></p>
<h3 id="UIViewController_的_Life_Cycle">UIViewController 的 Life Cycle</h3><p>UIViewController 的 Life Cycle 主要靠一些类似于 delegate 的函数来控制的。</p>
<p>按照执行时间顺序列举几个常用的函数：</p>
<ul>
<li><p><code>init</code>：UIViewController 的初始化有2种，一种是从 storyboard 中释放出来，另一种是在代码中直接调用相关的 init 函数。两种只会选择一种来完成 init。</p>
<ol>
<li><p><strong>来自 storyboard：</strong><code>awakeFromNib</code></p>
<p> 当 app 启动时，所有从 storyboard 释放出来的 object 都会调用该函数，包括其中的 UIViewController（通过在 storyboard 中设置其 class）！<strong>注意</strong>，该函数执行时，outlet 还尚未设置好，因此无法访问。</p>
</li>
<li><p><strong>来自 code：</strong><code>initWithNibName:(NSString *)name bundle:(NSBundle *)bundle</code></p>
<p>因为有这2种 init 方式，所以，如果希望在 init 阶段做一些 setup，那么这2个地方都要执行 setup。因为从 storyboard 释放出来的 init 方式只会调用 awakeFromNib，不会调用 initWithNibName；同样，code 中调用 initWithNibName: 进行的 init 方式也不会再调用 awakeFromNib。</p>
<p>通常在该 init 阶段能做的事很有限，因为 outlet 尚未设置好。所有直接访问 outlet 的操作都无法进行。</p>
</li>
</ol>
</li>
<li><p><code>iOS 设置 outlet</code></p>
</li>
<li><p><code>viewDidLoad</code>：app 运行到这里时，outlet 已经设置好，所以是进行 setup 操作的绝佳之地！但要<strong>注意</strong>：</p>
<ol>
<li>这里总是需要调用一下 <em><code>[super viewDidLoad]</code></em>。</li>
<li>此时 view 的 geometry 尚未设置好，也就是说像 <em><code>bounds 和 frame</code></em> 这些属性是还没有确定的，不能在这里访问，所以不要做些与 geometry 相关的操作。</li>
<li>viewDidLoad 只会调用一次，即在释放之前，view 只会 load 一次。</li>
</ol>
</li>
<li><p><code>iOS 确定 geometry</code></p>
</li>
<li><p><code>viewWillLayoutSubviews: / viewDidLayoutSubviews:</code>：geometry 确定好后，就可以进行 view 的布局了。这通常都是由 AutoLayout 自动完成的，准确的说，<strong>AutoLayout 动作就是发生在 will 与 did 之间</strong>。每当 view 的 frame 发生改变时，就会调用这组函数，这样该 view 的 subviews 就能够重新进行布局了。例如屏幕发生 autorotation 时，就会调用它们。你可以在这里重新设置 subviews 的 frame 或其它 geometry 相关的属性，然后让 AutoLayout 来完成布局。当然，你也可以不管这组函数，只是让 AutoLayout 来做事就行了。</p>
<pre><code>顺便提一下，如果想让 ViewController 响应手机的 rotation，必须同时满足以下<span class="number">3</span>个条件：
    shouldAutorotate 要返回 YES
    supportedInterfaceOrientations 要返回相应的 orientation
    Info<span class="class">.plist</span> 中要设置允许相应的 orientation
</code></pre></li>
<li><p><code>viewWillAppear: / viewDidAppear:</code>：Layout 完成后，就可以让 view 现身了。不像 viewDidLoad，这组函数是可以随着 view 的 visible 状态改变而执行多次的，正如其函数名称表示的意思。</p>
</li>
<li><p><code>在 view visible 期间，每当 geometry 改变就会调用viewWill/DidLayoutSubviews:这组函数。</code></p>
</li>
<li><p><code>viewWillDisappear: / viewDidDisappear:</code>这组函数也会随着 view 的 visible 状态改变而执行多次。</p>
<p>  <strong>注意</strong>，在 viewWill/DidXXX 这4个函数里面总是需要调用 super 的对应函数。在 viewWillXXX 这2个函数里面不要做太费时的操作，因为时间有限，will 这个状态马上就会过去的。</p>
</li>
</ul>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Developing_Applications_for_iOS_观后感系列：Life_Cycle">Developing Applications for iOS 观后感系列：Life Cycle</h3><p><em>相关视频章节：5，17</em></p>]]>
    
    </summary>
    
      <category term="iOS" scheme="https://hi.zongquan.wang/tags/iOS/"/>
    
      <category term="Development" scheme="https://hi.zongquan.wang/categories/Development/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Study iOS - MVC]]></title>
    <link href="https://hi.zongquan.wang/2015/01/05/Study_iOS_MVC/"/>
    <id>https://hi.zongquan.wang/2015/01/05/Study_iOS_MVC/</id>
    <published>2015-01-05T11:38:55.000Z</published>
    <updated>2016-12-12T11:53:12.000Z</updated>
    <content type="html"><![CDATA[<p>iOS学习起步阶段，抽空看完了 Stanford 老头的 Developing Applications for iOS 系列视频，挺不错的，浅显易懂。打算把“观后感”做成笔记，挑些重要的点，理一理，省得以后还要重新看整个教程的文档。</p>
<a id="more"></a>
<h3 id="Developing_Applications_for_iOS_观后感系列：MVC_设计模式">Developing Applications for iOS 观后感系列：MVC 设计模式</h3><p><em>相关视频章节：1</em></p>
<hr>
<p>先上图！</p>
<p><img src="/img/Study_iOS_MVC/1.0.MVC.png" alt="MVC"></p>
<p>这幅图描述的是单一的 <strong><code>MVC</code></strong> 模式。普通的 iOS 开发就靠这个 MVC 模式走遍天下了。（有牛人开创了个 <a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">ReactiveCocoa 模式</a>）</p>
<h4 id="理解一下_MVC_模式：">理解一下 MVC 模式：</h4><ol>
<li>V 和 M 永远也不能在一起，无法做直接通信。C -&gt; M 存在单向的直接通信。C -&gt; V 存在单向的直接通信。也就是说，C 永远是老大，它负责吩咐 V 和 M 办事，而且不受 V 和 M 的直接影响。</li>
<li>通过将 V 设置成 C 的 <em><code>outlet</code></em> <em>(Control Drag)</em>，可以实现 C 对 V 的直接通信，即 C -&gt; V。而 V –&gt; C 的间接通信方式包括2种：<em><code>target-action</code></em> 以及 <em><code>delegate（data source 也可以理解成 delegate）</code></em>。</li>
<li>C -&gt; M 是理所当然的。而 M –&gt; C 的间接通信是通过 <em><code>Notification &amp; KVO</code></em> 实现的。</li>
</ol>
<p>基于单个的 MVC，我们可以构建复杂的多 MVC。</p>
<p><img src="/img/Study_iOS_MVC/1.1.MVCs.png" alt="MVCs"></p>
<p><strong>但不管多复杂，总是坚持这个原则</strong>：一个 MVC 是作为另一个 MVC 的 V 部分而存在的，也就是说，父 MVC 中的 C 控制的是子 MVC 中的 C，而不是直接去干预子 MVC 中的 V。当然，多个 MVC 是可以共享同一个 M 的，毕竟 Notification 是广播性质的，可以有多个 Observer。</p>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p>iOS学习起步阶段，抽空看完了 Stanford 老头的 Developing Applications for iOS 系列视频，挺不错的，浅显易懂。打算把“观后感”做成笔记，挑些重要的点，理一理，省得以后还要重新看整个教程的文档。</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="https://hi.zongquan.wang/tags/iOS/"/>
    
      <category term="Development" scheme="https://hi.zongquan.wang/categories/Development/"/>
    
  </entry>
  
</feed>
